import o,{initSchemaFromDb as d}from"native_postgrest_parser/pkg/postgrest_parser.js";import{createClient as p}from"native_postgrest_parser/pkg/client.js";var i=class s{client;static initPromise=null;constructor(){this.client=p()}static async init(){s.initPromise||(s.initPromise=o()),await s.initPromise}static async initSchema(r){await s.init(),await d(r)}parseSelect(r,e=""){return this.parseRequest("GET",r,e)}parseInsert(r,e,t=""){return this.parseRequest("POST",r,t,e)}parseUpdate(r,e,t){return this.parseRequest("PATCH",r,t,e)}parseDelete(r,e){return this.parseRequest("DELETE",r,e)}parseRpc(r,e,t=""){let n=`rpc/${r}`;return this.parseRequest("POST",n,t,e)}parseRequest(r,e,t="",n){let l=this.client.parseRequest(r,e,t,n??null,null);return this.convertResult(l)}convertResult(r){return{sql:r.query,params:Array.isArray(r.params)?r.params:[],tables:Array.isArray(r.tables)?r.tables:[]}}};var u=class{db;parser;constructor(r,e){this.db=r,this.parser=e}from(r){return new a(this.db,this.parser,r)}async rpc(r,e){try{let t=this.parser.parseRpc(r,e);return{data:(await this.db.query(t.sql,[...t.params])).rows,error:null}}catch(t){return{data:null,error:t}}}},a=class{db;parser;table;selectColumns;filters=[];orderBy;limitCount;offsetCount;insertData;updateData;isDelete=!1;expectSingle=!1;expectMaybeSingle=!1;constructor(r,e,t){this.db=r,this.parser=e,this.table=t}select(r="*"){return this.selectColumns=r,this}insert(r){return this.insertData=r,this}update(r){return this.updateData=r,this}delete(){return this.isDelete=!0,this}eq(r,e){return this.filters.push(`${r}=eq.${String(e)}`),this}neq(r,e){return this.filters.push(`${r}=neq.${String(e)}`),this}gt(r,e){return this.filters.push(`${r}=gt.${String(e)}`),this}gte(r,e){return this.filters.push(`${r}=gte.${String(e)}`),this}lt(r,e){return this.filters.push(`${r}=lt.${String(e)}`),this}lte(r,e){return this.filters.push(`${r}=lte.${String(e)}`),this}like(r,e){return this.filters.push(`${r}=like.${e}`),this}ilike(r,e){return this.filters.push(`${r}=ilike.${e}`),this}in(r,e){let t=e.map(String).join(",");return this.filters.push(`${r}=in.(${t})`),this}is(r,e){let t=e===null?"null":e?"true":"false";return this.filters.push(`${r}=is.${t}`),this}order(r,e){let t=e?.ascending===!1?"desc":"asc",n=e?.nullsFirst?"nullsfirst":"nullslast";return this.orderBy=`${r}.${t}.${n}`,this}limit(r){return this.limitCount=r,this}range(r,e){return this.offsetCount=r,this.limitCount=e-r+1,this}single(){return this.expectSingle=!0,this.limitCount=1,this}maybeSingle(){return this.expectMaybeSingle=!0,this.limitCount=1,this}async then(r){let e=await this.execute();return r?r(e):e}async execute(){try{let r=this.buildQueryString(),e;if(this.insertData!==void 0){let l=Array.isArray(this.insertData)?this.insertData[0]??{}:this.insertData;e=this.parser.parseInsert(this.table,l,r)}else this.updateData!==void 0?e=this.parser.parseUpdate(this.table,this.updateData,r):this.isDelete?e=this.parser.parseDelete(this.table,r):e=this.parser.parseSelect(this.table,r);let t=await this.db.query(e.sql,[...e.params]);if(this.expectSingle&&t.rows.length===0)throw new Error("No rows returned");if(this.expectSingle&&t.rows.length>1)throw new Error("Multiple rows returned");return{data:this.expectSingle||this.expectMaybeSingle?t.rows[0]??null:t.rows,error:null}}catch(r){return{data:null,error:r}}}buildQueryString(){let r=[];return this.selectColumns&&r.push(`select=${this.selectColumns}`),r.push(...this.filters),this.orderBy&&r.push(`order=${this.orderBy}`),this.limitCount!==void 0&&r.push(`limit=${this.limitCount}`),this.offsetCount!==void 0&&r.push(`offset=${this.offsetCount}`),r.join("&")}};async function c(s){await i.init(),await i.initSchema(async e=>({rows:(await s.query(e)).rows}));let r=new i;return new u(s,r)}export{i as PostgrestParser,u as SupabaseClient,c as createSupabaseClient};
//# sourceMappingURL=slim.js.map
