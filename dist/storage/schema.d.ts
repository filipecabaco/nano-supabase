/**
 * Storage schema SQL for PGlite
 *
 * Distilled from the official Supabase Storage tenant migrations
 * (https://github.com/supabase/storage/tree/master/migrations/tenant)
 * into a single idempotent schema that works with PGlite.
 *
 * Tables: storage.buckets, storage.objects
 * Functions: storage.foldername, storage.filename, storage.extension, storage.search
 * RLS: enabled on storage.objects (users write their own policies)
 */
export declare const STORAGE_SCHEMA_SQL = "\n-- Create storage schema\nCREATE SCHEMA IF NOT EXISTS storage;\n\n-- Grant permissions to roles (created by auth schema)\nGRANT USAGE ON SCHEMA storage TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON TABLES TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON FUNCTIONS TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON SEQUENCES TO anon, authenticated, service_role;\n\n-- Buckets table\nCREATE TABLE IF NOT EXISTS storage.buckets (\n  id text PRIMARY KEY,\n  name text NOT NULL,\n  owner uuid,\n  owner_id text,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now(),\n  public boolean DEFAULT false,\n  avif_autodetection boolean DEFAULT false,\n  file_size_limit bigint,\n  allowed_mime_types text[]\n);\n\nCREATE UNIQUE INDEX IF NOT EXISTS bname ON storage.buckets USING btree (name);\n\n-- Objects table\nCREATE TABLE IF NOT EXISTS storage.objects (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  bucket_id text,\n  name text,\n  owner uuid,\n  owner_id text,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now(),\n  last_accessed_at timestamptz DEFAULT now(),\n  metadata jsonb,\n  version text,\n  user_metadata jsonb,\n  CONSTRAINT objects_bucketId_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id),\n  PRIMARY KEY (id)\n);\n\nCREATE UNIQUE INDEX IF NOT EXISTS bucketid_objname ON storage.objects USING btree (bucket_id, name);\nCREATE INDEX IF NOT EXISTS name_prefix_search ON storage.objects(name text_pattern_ops);\n\n-- Enable RLS on objects (users add their own policies)\nALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;\n\n-- Enable RLS on buckets\nALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;\n\n-- Utility functions\n\nCREATE OR REPLACE FUNCTION storage.foldername(name text)\n  RETURNS text[]\n  LANGUAGE plpgsql\nAS $$\nDECLARE\n  _parts text[];\nBEGIN\n  SELECT string_to_array(name, '/') INTO _parts;\n  RETURN _parts[1:array_length(_parts, 1) - 1];\nEND\n$$;\n\nCREATE OR REPLACE FUNCTION storage.filename(name text)\n  RETURNS text\n  LANGUAGE plpgsql\nAS $$\nDECLARE\n  _parts text[];\nBEGIN\n  SELECT string_to_array(name, '/') INTO _parts;\n  RETURN _parts[array_length(_parts, 1)];\nEND\n$$;\n\nCREATE OR REPLACE FUNCTION storage.extension(name text)\n  RETURNS text\n  LANGUAGE plpgsql\nAS $$\nDECLARE\n  _parts text[];\n  _filename text;\nBEGIN\n  SELECT string_to_array(name, '/') INTO _parts;\n  SELECT _parts[array_length(_parts, 1)] INTO _filename;\n  RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$$;\n\nCREATE OR REPLACE FUNCTION storage.search(\n  prefix text,\n  bucketname text,\n  limits int DEFAULT 100,\n  levels int DEFAULT 1,\n  offsets int DEFAULT 0\n)\n  RETURNS TABLE (\n    name text,\n    id uuid,\n    updated_at timestamptz,\n    created_at timestamptz,\n    last_accessed_at timestamptz,\n    metadata jsonb\n  )\n  LANGUAGE plpgsql\nAS $$\nBEGIN\n  RETURN QUERY\n    WITH files_folders AS (\n      SELECT ((string_to_array(objects.name, '/'))[levels]) AS folder\n      FROM storage.objects\n      WHERE objects.name ILIKE prefix || '%'\n        AND bucket_id = bucketname\n      GROUP BY folder\n      LIMIT limits\n      OFFSET offsets\n    )\n    SELECT\n      files_folders.folder AS name,\n      objects.id,\n      objects.updated_at,\n      objects.created_at,\n      objects.last_accessed_at,\n      objects.metadata\n    FROM files_folders\n    LEFT JOIN storage.objects\n      ON prefix || files_folders.folder = objects.name\n      AND objects.bucket_id = bucketname;\nEND\n$$;\n\n-- Grant table permissions explicitly\nGRANT ALL ON storage.buckets TO anon, authenticated, service_role;\nGRANT ALL ON storage.objects TO anon, authenticated, service_role;\n\n-- Grant function permissions\nGRANT EXECUTE ON FUNCTION storage.foldername(text) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION storage.filename(text) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION storage.extension(text) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION storage.search(text, text, int, int, int) TO anon, authenticated, service_role;\n";
//# sourceMappingURL=schema.d.ts.map