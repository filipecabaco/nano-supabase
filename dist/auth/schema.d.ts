/**
 * SQL schema for auth tables (compatible with Supabase auth schema)
 * Uses pgcrypto extension for password hashing (available in PGlite)
 */
export declare const AUTH_SCHEMA_SQL = "\n-- Enable pgcrypto extension for password hashing\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n\n-- Create auth schema\nCREATE SCHEMA IF NOT EXISTS auth;\n\n-- Create PostgreSQL roles for RLS\nDO $$\nBEGIN\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'anon') THEN\n    CREATE ROLE anon NOLOGIN NOINHERIT;\n  END IF;\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'authenticated') THEN\n    CREATE ROLE authenticated NOLOGIN NOINHERIT;\n  END IF;\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'service_role') THEN\n    CREATE ROLE service_role NOLOGIN NOINHERIT BYPASSRLS;\n  END IF;\nEND\n$$;\n\n-- Grant necessary permissions to roles\nGRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;\nGRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;\nGRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO anon, authenticated, service_role;\n\n-- Grant service_role full access to auth schema (needed for auth operations)\nGRANT USAGE ON SCHEMA auth TO service_role;\nGRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;\nGRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON TABLES TO service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON SEQUENCES TO service_role;\n\n-- Users table\nCREATE TABLE IF NOT EXISTS auth.users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  instance_id UUID DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,\n  aud VARCHAR(255) DEFAULT 'authenticated',\n  role VARCHAR(255) DEFAULT 'authenticated',\n  email VARCHAR(255) UNIQUE,\n  encrypted_password VARCHAR(255),\n  email_confirmed_at TIMESTAMPTZ,\n  invited_at TIMESTAMPTZ,\n  confirmation_token VARCHAR(255),\n  confirmation_sent_at TIMESTAMPTZ,\n  recovery_token VARCHAR(255),\n  recovery_sent_at TIMESTAMPTZ,\n  email_change_token_new VARCHAR(255),\n  email_change VARCHAR(255),\n  email_change_sent_at TIMESTAMPTZ,\n  last_sign_in_at TIMESTAMPTZ,\n  raw_app_meta_data JSONB DEFAULT '{}'::jsonb,\n  raw_user_meta_data JSONB DEFAULT '{}'::jsonb,\n  is_super_admin BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  phone VARCHAR(255) UNIQUE,\n  phone_confirmed_at TIMESTAMPTZ,\n  phone_change VARCHAR(255),\n  phone_change_token VARCHAR(255),\n  phone_change_sent_at TIMESTAMPTZ,\n  email_change_token_current VARCHAR(255),\n  email_change_confirm_status SMALLINT DEFAULT 0,\n  banned_until TIMESTAMPTZ,\n  reauthentication_token VARCHAR(255),\n  reauthentication_sent_at TIMESTAMPTZ,\n  is_sso_user BOOLEAN DEFAULT FALSE,\n  deleted_at TIMESTAMPTZ,\n  is_anonymous BOOLEAN DEFAULT FALSE\n);\n\n-- Sessions table\nCREATE TABLE IF NOT EXISTS auth.sessions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  factor_id UUID,\n  aal VARCHAR(255) DEFAULT 'aal1',\n  not_after TIMESTAMPTZ,\n  refreshed_at TIMESTAMPTZ,\n  user_agent TEXT,\n  ip INET,\n  tag TEXT\n);\n\n-- Refresh tokens table\nCREATE TABLE IF NOT EXISTS auth.refresh_tokens (\n  id BIGSERIAL PRIMARY KEY,\n  token VARCHAR(255) UNIQUE NOT NULL,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  revoked BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  parent VARCHAR(255),\n  session_id UUID REFERENCES auth.sessions(id) ON DELETE CASCADE\n);\n\n-- Indexes for performance\nCREATE INDEX IF NOT EXISTS users_email_idx ON auth.users(email);\nCREATE INDEX IF NOT EXISTS users_instance_id_idx ON auth.users(instance_id);\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON auth.sessions(user_id);\nCREATE INDEX IF NOT EXISTS sessions_not_after_idx ON auth.sessions(not_after);\nCREATE INDEX IF NOT EXISTS refresh_tokens_token_idx ON auth.refresh_tokens(token);\nCREATE INDEX IF NOT EXISTS refresh_tokens_user_id_idx ON auth.refresh_tokens(user_id);\nCREATE INDEX IF NOT EXISTS refresh_tokens_session_id_idx ON auth.refresh_tokens(session_id);\n\n-- Function to get current user ID (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.uid() RETURNS UUID AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.sub', true), '')::uuid;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get current user role (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.role() RETURNS TEXT AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.role', true), '');\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get current user email (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.email() RETURNS TEXT AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.email', true), '');\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get JWT claims (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.jwt() RETURNS JSONB AS $$\n  SELECT COALESCE(\n    NULLIF(current_setting('request.jwt.claims', true), ''),\n    '{}'\n  )::jsonb;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to hash a password using pgcrypto\nCREATE OR REPLACE FUNCTION auth.hash_password(password TEXT) RETURNS TEXT AS $$\n  SELECT crypt(password, gen_salt('bf', 10));\n$$ LANGUAGE SQL;\n\n-- Function to verify a password against a hash\nCREATE OR REPLACE FUNCTION auth.verify_password(password TEXT, password_hash TEXT) RETURNS BOOLEAN AS $$\n  SELECT password_hash = crypt(password, password_hash);\n$$ LANGUAGE SQL;\n\n-- Function to generate a secure random token\nCREATE OR REPLACE FUNCTION auth.generate_token(length INT DEFAULT 32) RETURNS TEXT AS $$\n  SELECT encode(gen_random_bytes(length), 'hex');\n$$ LANGUAGE SQL;\n\n-- Function to create a new user with hashed password\nCREATE OR REPLACE FUNCTION auth.create_user(\n  p_email TEXT,\n  p_password TEXT,\n  p_user_metadata JSONB DEFAULT '{}'::jsonb,\n  p_app_metadata JSONB DEFAULT '{}'::jsonb\n) RETURNS auth.users AS $$\nDECLARE\n  v_user auth.users;\nBEGIN\n  INSERT INTO auth.users (\n    email,\n    encrypted_password,\n    email_confirmed_at,\n    raw_user_meta_data,\n    raw_app_meta_data,\n    created_at,\n    updated_at\n  ) VALUES (\n    p_email,\n    auth.hash_password(p_password),\n    NOW(), -- Auto-confirm for local development\n    p_user_metadata,\n    p_app_metadata,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_user;\n\n  RETURN v_user;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify user credentials and return user if valid\nCREATE OR REPLACE FUNCTION auth.verify_user_credentials(\n  p_email TEXT,\n  p_password TEXT\n) RETURNS auth.users AS $$\nDECLARE\n  v_user auth.users;\nBEGIN\n  SELECT * INTO v_user\n  FROM auth.users\n  WHERE email = p_email\n    AND deleted_at IS NULL\n    AND (banned_until IS NULL OR banned_until < NOW());\n\n  IF v_user IS NULL THEN\n    RETURN NULL;\n  END IF;\n\n  IF NOT auth.verify_password(p_password, v_user.encrypted_password) THEN\n    RETURN NULL;\n  END IF;\n\n  -- Update last sign in time\n  UPDATE auth.users\n  SET last_sign_in_at = NOW(), updated_at = NOW()\n  WHERE id = v_user.id;\n\n  RETURN v_user;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to create a session for a user\nCREATE OR REPLACE FUNCTION auth.create_session(\n  p_user_id UUID,\n  p_user_agent TEXT DEFAULT NULL,\n  p_ip TEXT DEFAULT NULL\n) RETURNS auth.sessions AS $$\nDECLARE\n  v_session auth.sessions;\nBEGIN\n  INSERT INTO auth.sessions (\n    user_id,\n    user_agent,\n    ip,\n    created_at,\n    updated_at,\n    refreshed_at\n  ) VALUES (\n    p_user_id,\n    p_user_agent,\n    p_ip::inet,\n    NOW(),\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_session;\n\n  RETURN v_session;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to create a refresh token for a session\nCREATE OR REPLACE FUNCTION auth.create_refresh_token(\n  p_user_id UUID,\n  p_session_id UUID\n) RETURNS auth.refresh_tokens AS $$\nDECLARE\n  v_refresh_token auth.refresh_tokens;\nBEGIN\n  INSERT INTO auth.refresh_tokens (\n    token,\n    user_id,\n    session_id,\n    created_at,\n    updated_at\n  ) VALUES (\n    auth.generate_token(32),\n    p_user_id,\n    p_session_id,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_refresh_token;\n\n  RETURN v_refresh_token;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to refresh a token (revoke old, create new)\nCREATE OR REPLACE FUNCTION auth.refresh_token(\n  p_refresh_token TEXT\n) RETURNS TABLE(\n  new_token TEXT,\n  user_id UUID,\n  session_id UUID\n) AS $$\nDECLARE\n  v_old_token auth.refresh_tokens;\n  v_new_token auth.refresh_tokens;\nBEGIN\n  -- Find and validate the old token\n  SELECT * INTO v_old_token\n  FROM auth.refresh_tokens rt\n  WHERE rt.token = p_refresh_token\n    AND rt.revoked = FALSE;\n\n  IF v_old_token IS NULL THEN\n    RETURN;\n  END IF;\n\n  -- Revoke the old token\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE id = v_old_token.id;\n\n  -- Update session refreshed_at\n  UPDATE auth.sessions\n  SET refreshed_at = NOW(), updated_at = NOW()\n  WHERE id = v_old_token.session_id;\n\n  -- Create new token\n  INSERT INTO auth.refresh_tokens (\n    token,\n    user_id,\n    session_id,\n    parent,\n    created_at,\n    updated_at\n  ) VALUES (\n    auth.generate_token(32),\n    v_old_token.user_id,\n    v_old_token.session_id,\n    v_old_token.token,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_new_token;\n\n  RETURN QUERY SELECT v_new_token.token, v_new_token.user_id, v_new_token.session_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to revoke all sessions for a user (sign out)\nCREATE OR REPLACE FUNCTION auth.sign_out(p_session_id UUID) RETURNS VOID AS $$\nBEGIN\n  -- Revoke all refresh tokens for this session\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE session_id = p_session_id;\n\n  -- Delete the session\n  DELETE FROM auth.sessions WHERE id = p_session_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to sign out all sessions for a user\nCREATE OR REPLACE FUNCTION auth.sign_out_all(p_user_id UUID) RETURNS VOID AS $$\nBEGIN\n  -- Revoke all refresh tokens\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE user_id = p_user_id;\n\n  -- Delete all sessions\n  DELETE FROM auth.sessions WHERE user_id = p_user_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Config table for storing signing key\nCREATE TABLE IF NOT EXISTS auth.config (\n  key TEXT PRIMARY KEY,\n  value TEXT NOT NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Function to get or create the signing key\nCREATE OR REPLACE FUNCTION auth.get_signing_key() RETURNS TEXT AS $$\nDECLARE\n  v_key TEXT;\nBEGIN\n  SELECT value INTO v_key FROM auth.config WHERE key = 'jwt_signing_key';\n\n  IF v_key IS NULL THEN\n    v_key := encode(gen_random_bytes(32), 'hex');\n    INSERT INTO auth.config (key, value) VALUES ('jwt_signing_key', v_key);\n  END IF;\n\n  RETURN v_key;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to base64url encode\nCREATE OR REPLACE FUNCTION auth.base64url_encode(data BYTEA) RETURNS TEXT AS $$\n  SELECT replace(replace(rtrim(encode(data, 'base64'), '='), '+', '-'), '/', '_');\n$$ LANGUAGE SQL IMMUTABLE;\n\n-- Function to base64url decode\nCREATE OR REPLACE FUNCTION auth.base64url_decode(data TEXT) RETURNS BYTEA AS $$\nDECLARE\n  v_padded TEXT;\n  v_converted TEXT;\nBEGIN\n  v_converted := replace(replace(data, '-', '+'), '_', '/');\n  v_padded := v_converted || repeat('=', (4 - length(v_converted) % 4) % 4);\n  RETURN decode(v_padded, 'base64');\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE;\n\n-- Function to create an access token (JWT-like structure using HMAC)\nCREATE OR REPLACE FUNCTION auth.create_access_token(\n  p_user_id UUID,\n  p_session_id UUID,\n  p_email TEXT,\n  p_role TEXT DEFAULT 'authenticated',\n  p_user_metadata JSONB DEFAULT '{}'::jsonb,\n  p_app_metadata JSONB DEFAULT '{}'::jsonb,\n  p_expires_in INT DEFAULT 3600\n) RETURNS TEXT AS $$\nDECLARE\n  v_key TEXT;\n  v_now BIGINT;\n  v_exp BIGINT;\n  v_header TEXT;\n  v_payload TEXT;\n  v_header_b64 TEXT;\n  v_payload_b64 TEXT;\n  v_signature_input TEXT;\n  v_signature TEXT;\nBEGIN\n  v_key := auth.get_signing_key();\n  v_now := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  v_exp := v_now + p_expires_in;\n\n  -- Create header\n  v_header := '{\"alg\":\"HS256\",\"typ\":\"JWT\"}';\n  v_header_b64 := auth.base64url_encode(v_header::bytea);\n\n  -- Create payload\n  v_payload := json_build_object(\n    'sub', p_user_id,\n    'aud', 'authenticated',\n    'role', p_role,\n    'email', p_email,\n    'session_id', p_session_id,\n    'iat', v_now,\n    'exp', v_exp,\n    'user_metadata', p_user_metadata,\n    'app_metadata', p_app_metadata\n  )::text;\n  v_payload_b64 := auth.base64url_encode(v_payload::bytea);\n\n  -- Create signature\n  v_signature_input := v_header_b64 || '.' || v_payload_b64;\n  v_signature := auth.base64url_encode(\n    hmac(v_signature_input::bytea, decode(v_key, 'hex'), 'sha256')\n  );\n\n  RETURN v_signature_input || '.' || v_signature;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify an access token and return payload\nCREATE OR REPLACE FUNCTION auth.verify_access_token(p_token TEXT) RETURNS TABLE(\n  valid BOOLEAN,\n  user_id UUID,\n  session_id UUID,\n  email TEXT,\n  role TEXT,\n  exp BIGINT,\n  user_metadata JSONB,\n  app_metadata JSONB,\n  error TEXT\n) AS $$\nDECLARE\n  v_parts TEXT[];\n  v_header_b64 TEXT;\n  v_payload_b64 TEXT;\n  v_signature_b64 TEXT;\n  v_key TEXT;\n  v_signature_input TEXT;\n  v_expected_sig TEXT;\n  v_payload JSONB;\n  v_now BIGINT;\nBEGIN\n  -- Split token into parts\n  v_parts := string_to_array(p_token, '.');\n\n  IF array_length(v_parts, 1) != 3 THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid token format'::TEXT;\n    RETURN;\n  END IF;\n\n  v_header_b64 := v_parts[1];\n  v_payload_b64 := v_parts[2];\n  v_signature_b64 := v_parts[3];\n\n  -- Verify signature\n  v_key := auth.get_signing_key();\n  v_signature_input := v_header_b64 || '.' || v_payload_b64;\n  v_expected_sig := auth.base64url_encode(\n    hmac(v_signature_input::bytea, decode(v_key, 'hex'), 'sha256')\n  );\n\n  IF v_signature_b64 != v_expected_sig THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid signature'::TEXT;\n    RETURN;\n  END IF;\n\n  -- Decode payload\n  BEGIN\n    v_payload := convert_from(auth.base64url_decode(v_payload_b64), 'UTF8')::jsonb;\n  EXCEPTION WHEN OTHERS THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid payload'::TEXT;\n    RETURN;\n  END;\n\n  -- Check expiration\n  v_now := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  IF (v_payload->>'exp')::BIGINT < v_now THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Token expired'::TEXT;\n    RETURN;\n  END IF;\n\n  -- Return valid token data\n  RETURN QUERY SELECT\n    true,\n    (v_payload->>'sub')::UUID,\n    (v_payload->>'session_id')::UUID,\n    v_payload->>'email',\n    v_payload->>'role',\n    (v_payload->>'exp')::BIGINT,\n    COALESCE(v_payload->'user_metadata', '{}'::jsonb),\n    COALESCE(v_payload->'app_metadata', '{}'::jsonb),\n    NULL::TEXT;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Grant execute permissions on auth schema functions to roles\n-- This allows RLS policies and DEFAULT values to use these functions\nGRANT USAGE ON SCHEMA auth TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.uid() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.role() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.email() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.jwt() TO anon, authenticated, service_role;\n\n-- Grant execute on auth management functions\n-- These have SECURITY DEFINER so they run with elevated privileges\nGRANT EXECUTE ON FUNCTION auth.create_user(TEXT, TEXT, JSONB, JSONB) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.verify_user_credentials(TEXT, TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_session(UUID, TEXT, TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_refresh_token(UUID, UUID) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.refresh_token(TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.sign_out(UUID) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.sign_out_all(UUID) TO authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.get_signing_key() TO service_role;\nGRANT EXECUTE ON FUNCTION auth.create_access_token(UUID, UUID, TEXT, TEXT, JSONB, JSONB, INT) TO service_role;\nGRANT EXECUTE ON FUNCTION auth.verify_access_token(TEXT) TO service_role;\n";
/**
 * SQL to set auth context for a request (called before each query when authenticated)
 */
export declare function getSetAuthContextSQL(userId: string, role: string, email: string): string;
/**
 * SQL to clear auth context (for anonymous/unauthenticated requests)
 */
export declare const CLEAR_AUTH_CONTEXT_SQL = "\n  SET ROLE anon;\n  SELECT set_config('request.jwt.claim.sub', '', false);\n  SELECT set_config('request.jwt.claim.role', 'anon', false);\n  SELECT set_config('request.jwt.claim.email', '', false);\n  SELECT set_config('request.jwt.claims', '{\"role\": \"anon\"}', false);\n";
//# sourceMappingURL=schema.d.ts.map