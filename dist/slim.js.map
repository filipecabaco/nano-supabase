{
  "version": 3,
  "sources": ["../src/postgrest-parser.ts", "../src/supabase-client.ts"],
  "sourcesContent": ["/**\n * PostgREST Query Parser Wrapper\n * Uses native_postgrest_parser WASM to convert PostgREST queries to SQL\n */\n\nimport init, { initSchemaFromDb } from 'native_postgrest_parser/pkg/postgrest_parser.js'\nimport { createClient } from 'native_postgrest_parser/pkg/client.js'\nimport type { QueryResult as ParserQueryResult } from 'native_postgrest_parser/pkg/types.js'\n\n/**\n * Query executor function type for schema introspection\n */\nexport type QueryExecutor = (sql: string) => Promise<{ rows: unknown[] }>\n\n/**\n * Parsed SQL query with parameters\n */\nexport interface ParsedQuery {\n  readonly sql: string\n  readonly params: readonly unknown[]\n  readonly tables: readonly string[]\n}\n\n/**\n * PostgREST parser for converting REST queries to SQL\n */\nexport class PostgrestParser {\n  private readonly client: ReturnType<typeof createClient>\n  private static initPromise: Promise<unknown> | null = null\n\n  constructor() {\n    this.client = createClient()\n  }\n\n  /**\n   * Initialize the WASM module (must be called before first use)\n   * Safe to call multiple times - initialization happens only once\n   *\n   * Note: This uses the web target build which works in webcontainers and edge workers.\n   * For Node.js, the native_postgrest_parser package needs to be built with --target nodejs.\n   */\n  static async init(): Promise<void> {\n    if (!PostgrestParser.initPromise) {\n      PostgrestParser.initPromise = init()\n    }\n    await PostgrestParser.initPromise\n  }\n\n  /**\n   * Initialize schema introspection from a database connection\n   * This enables the parser to validate queries against the actual database schema\n   *\n   * @param queryExecutor - Function that executes SQL queries and returns rows\n   *\n   * @example\n   * ```typescript\n   * import { PGlite } from '@electric-sql/pglite'\n   * import { PostgrestParser } from './postgrest-parser'\n   *\n   * const db = new PGlite()\n   * await PostgrestParser.init()\n   *\n   * // Initialize schema introspection\n   * await PostgrestParser.initSchema(async (sql) => {\n   *   const result = await db.query(sql)\n   *   return { rows: result.rows }\n   * })\n   * ```\n   */\n  static async initSchema(queryExecutor: QueryExecutor): Promise<void> {\n    await PostgrestParser.init()\n    await initSchemaFromDb(queryExecutor)\n  }\n\n  /**\n   * Parse a SELECT query from PostgREST format\n   *\n   * @example\n   * parseSelect('users', 'id=eq.1&select=id,name')\n   * // => { sql: 'SELECT \"id\", \"name\" FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseSelect(table: string, queryString: string = ''): ParsedQuery {\n    return this.parseRequest('GET', table, queryString)\n  }\n\n  /**\n   * Parse an INSERT query from PostgREST format\n   *\n   * @example\n   * parseInsert('users', { name: 'Alice', email: 'alice@example.com' })\n   * // => { sql: 'INSERT INTO \"users\" (\"name\", \"email\") VALUES ($1, $2)', params: ['Alice', 'alice@example.com'] }\n   */\n  parseInsert(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string = ''\n  ): ParsedQuery {\n    return this.parseRequest('POST', table, queryString, data)\n  }\n\n  /**\n   * Parse an UPDATE query from PostgREST format\n   *\n   * @example\n   * parseUpdate('users', { name: 'Alice' }, 'id=eq.1')\n   * // => { sql: 'UPDATE \"users\" SET \"name\" = $1 WHERE \"id\" = $2', params: ['Alice', 1] }\n   */\n  parseUpdate(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string\n  ): ParsedQuery {\n    return this.parseRequest('PATCH', table, queryString, data)\n  }\n\n  /**\n   * Parse a DELETE query from PostgREST format\n   *\n   * @example\n   * parseDelete('users', 'id=eq.1')\n   * // => { sql: 'DELETE FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseDelete(table: string, queryString: string): ParsedQuery {\n    return this.parseRequest('DELETE', table, queryString)\n  }\n\n  /**\n   * Parse an RPC (function call) from PostgREST format\n   *\n   * @example\n   * parseRpc('calculate_total', { order_id: 123 })\n   * // => { sql: 'SELECT * FROM \"calculate_total\"($1)', params: [123] }\n   */\n  parseRpc(\n    functionName: string,\n    args?: Record<string, unknown>,\n    queryString: string = ''\n  ): ParsedQuery {\n    const path = `rpc/${functionName}`\n    return this.parseRequest('POST', path, queryString, args)\n  }\n\n  /**\n   * Parse a generic HTTP request to SQL\n   *\n   * @param method - HTTP method (GET, POST, PATCH, DELETE)\n   * @param path - Path without leading slash (e.g., 'users' or 'rpc/function_name')\n   * @param queryString - URL query parameters\n   * @param body - Request body (for POST/PATCH)\n   */\n  parseRequest(\n    method: 'GET' | 'POST' | 'PATCH' | 'DELETE',\n    path: string,\n    queryString: string = '',\n    body?: Record<string, unknown>\n  ): ParsedQuery {\n    const result = this.client.parseRequest(method, path, queryString, body ?? null, null)\n    return this.convertResult(result)\n  }\n\n  /**\n   * Convert WASM result to our ParsedQuery format\n   */\n  private convertResult(result: ParserQueryResult): ParsedQuery {\n    return {\n      sql: result.query,\n      params: Array.isArray(result.params) ? result.params : [],\n      tables: Array.isArray(result.tables) ? result.tables : [],\n    }\n  }\n}\n", "/**\n * Supabase-compatible client for PGlite\n * Intercepts PostgREST-style API calls and converts them to SQL\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport { PostgrestParser } from './postgrest-parser.js'\n\n/**\n * Query builder interface compatible with Supabase-js\n */\nexport interface QueryBuilder<T = unknown> {\n  select(columns?: string): QueryBuilder<T>\n  insert(data: Record<string, unknown> | Record<string, unknown>[]): QueryBuilder<T>\n  update(data: Record<string, unknown>): QueryBuilder<T>\n  delete(): QueryBuilder<T>\n  eq(column: string, value: unknown): QueryBuilder<T>\n  neq(column: string, value: unknown): QueryBuilder<T>\n  gt(column: string, value: unknown): QueryBuilder<T>\n  gte(column: string, value: unknown): QueryBuilder<T>\n  lt(column: string, value: unknown): QueryBuilder<T>\n  lte(column: string, value: unknown): QueryBuilder<T>\n  like(column: string, pattern: string): QueryBuilder<T>\n  ilike(column: string, pattern: string): QueryBuilder<T>\n  in(column: string, values: unknown[]): QueryBuilder<T>\n  is(column: string, value: null | boolean): QueryBuilder<T>\n  order(column: string, options?: { ascending?: boolean; nullsFirst?: boolean }): QueryBuilder<T>\n  limit(count: number): QueryBuilder<T>\n  range(from: number, to: number): QueryBuilder<T>\n  single(): QueryBuilder<T>\n  maybeSingle(): QueryBuilder<T>\n  then<TResult>(\n    onfulfilled?: ((value: { data: T | null; error: Error | null }) => TResult) | null\n  ): Promise<TResult>\n}\n\n/**\n * Supabase-compatible database client\n */\nexport class SupabaseClient {\n  private readonly db: PGlite\n  private readonly parser: PostgrestParser\n\n  constructor(db: PGlite, parser: PostgrestParser) {\n    this.db = db\n    this.parser = parser\n  }\n\n  /**\n   * Access a table for querying\n   */\n  from<T = unknown>(table: string): QueryBuilder<T> {\n    return new PostgrestQueryBuilder<T>(this.db, this.parser, table)\n  }\n\n  /**\n   * Call a stored procedure\n   */\n  async rpc<T = unknown>(\n    functionName: string,\n    params?: Record<string, unknown>\n  ): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const parsed = this.parser.parseRpc(functionName, params)\n      const result = await this.db.query(parsed.sql, [...parsed.params])\n      return { data: result.rows as T, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n}\n\n/**\n * Query builder implementation\n */\nclass PostgrestQueryBuilder<T> implements QueryBuilder<T> {\n  private readonly db: PGlite\n  private readonly parser: PostgrestParser\n  private readonly table: string\n  private selectColumns?: string\n  private filters: string[] = []\n  private orderBy?: string\n  private limitCount?: number\n  private offsetCount?: number\n  private insertData?: Record<string, unknown> | Record<string, unknown>[]\n  private updateData?: Record<string, unknown>\n  private isDelete = false\n  private expectSingle = false\n  private expectMaybeSingle = false\n\n  constructor(db: PGlite, parser: PostgrestParser, table: string) {\n    this.db = db\n    this.parser = parser\n    this.table = table\n  }\n\n  select(columns = '*'): QueryBuilder<T> {\n    this.selectColumns = columns\n    return this\n  }\n\n  insert(data: Record<string, unknown> | Record<string, unknown>[]): QueryBuilder<T> {\n    this.insertData = data\n    return this\n  }\n\n  update(data: Record<string, unknown>): QueryBuilder<T> {\n    this.updateData = data\n    return this\n  }\n\n  delete(): QueryBuilder<T> {\n    this.isDelete = true\n    return this\n  }\n\n  eq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=eq.${String(value)}`)\n    return this\n  }\n\n  neq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=neq.${String(value)}`)\n    return this\n  }\n\n  gt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gt.${String(value)}`)\n    return this\n  }\n\n  gte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gte.${String(value)}`)\n    return this\n  }\n\n  lt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lt.${String(value)}`)\n    return this\n  }\n\n  lte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lte.${String(value)}`)\n    return this\n  }\n\n  like(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=like.${pattern}`)\n    return this\n  }\n\n  ilike(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=ilike.${pattern}`)\n    return this\n  }\n\n  in(column: string, values: unknown[]): QueryBuilder<T> {\n    const joined = values.map(String).join(',')\n    this.filters.push(`${column}=in.(${joined})`)\n    return this\n  }\n\n  is(column: string, value: null | boolean): QueryBuilder<T> {\n    const val = value === null ? 'null' : value ? 'true' : 'false'\n    this.filters.push(`${column}=is.${val}`)\n    return this\n  }\n\n  order(column: string, options?: { ascending?: boolean; nullsFirst?: boolean }): QueryBuilder<T> {\n    const direction = options?.ascending === false ? 'desc' : 'asc'\n    const nulls = options?.nullsFirst ? 'nullsfirst' : 'nullslast'\n    this.orderBy = `${column}.${direction}.${nulls}`\n    return this\n  }\n\n  limit(count: number): QueryBuilder<T> {\n    this.limitCount = count\n    return this\n  }\n\n  range(from: number, to: number): QueryBuilder<T> {\n    this.offsetCount = from\n    this.limitCount = to - from + 1\n    return this\n  }\n\n  single(): QueryBuilder<T> {\n    this.expectSingle = true\n    this.limitCount = 1\n    return this\n  }\n\n  maybeSingle(): QueryBuilder<T> {\n    this.expectMaybeSingle = true\n    this.limitCount = 1\n    return this\n  }\n\n  async then<TResult>(\n    onfulfilled?: ((value: { data: T | null; error: Error | null }) => TResult) | null\n  ): Promise<TResult> {\n    const result = await this.execute()\n    return onfulfilled ? onfulfilled(result) : (result as unknown as TResult)\n  }\n\n  private async execute(): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const queryString = this.buildQueryString()\n\n      let parsed\n      if (this.insertData !== undefined) {\n        const data: Record<string, unknown> = Array.isArray(this.insertData)\n          ? (this.insertData[0] ?? {})\n          : this.insertData\n        parsed = this.parser.parseInsert(this.table, data, queryString)\n      } else if (this.updateData !== undefined) {\n        parsed = this.parser.parseUpdate(this.table, this.updateData, queryString)\n      } else if (this.isDelete) {\n        parsed = this.parser.parseDelete(this.table, queryString)\n      } else {\n        parsed = this.parser.parseSelect(this.table, queryString)\n      }\n\n      const result = await this.db.query(parsed.sql, [...parsed.params])\n\n      if (this.expectSingle && result.rows.length === 0) {\n        throw new Error('No rows returned')\n      }\n\n      if (this.expectSingle && result.rows.length > 1) {\n        throw new Error('Multiple rows returned')\n      }\n\n      const data = this.expectSingle || this.expectMaybeSingle\n        ? (result.rows[0] as T) ?? null\n        : (result.rows as T)\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  private buildQueryString(): string {\n    const parts: string[] = []\n\n    if (this.selectColumns) {\n      parts.push(`select=${this.selectColumns}`)\n    }\n\n    parts.push(...this.filters)\n\n    if (this.orderBy) {\n      parts.push(`order=${this.orderBy}`)\n    }\n\n    if (this.limitCount !== undefined) {\n      parts.push(`limit=${this.limitCount}`)\n    }\n\n    if (this.offsetCount !== undefined) {\n      parts.push(`offset=${this.offsetCount}`)\n    }\n\n    return parts.join('&')\n  }\n}\n\n/**\n * Create a Supabase-compatible client with schema introspection\n */\nexport async function createSupabaseClient(db: PGlite): Promise<SupabaseClient> {\n  await PostgrestParser.init()\n\n  // Initialize schema introspection from the database\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql)\n    return { rows: result.rows }\n  })\n\n  const parser = new PostgrestParser()\n  return new SupabaseClient(db, parser)\n}\n"],
  "mappings": "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",
  "names": ["init", "initSchemaFromDb", "createClient", "PostgrestParser", "_PostgrestParser", "queryExecutor", "table", "queryString", "data", "functionName", "args", "path", "method", "body", "result", "SupabaseClient", "db", "parser", "table", "PostgrestQueryBuilder", "functionName", "params", "parsed", "error", "columns", "data", "column", "value", "pattern", "values", "joined", "val", "options", "direction", "nulls", "count", "from", "to", "onfulfilled", "result", "queryString", "parts", "createSupabaseClient", "PostgrestParser", "sql"]
}
