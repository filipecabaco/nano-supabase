{
  "version": 3,
  "sources": ["../node_modules/postgrest-parser/pkg/postgrest_parser.js", "../node_modules/postgrest-parser/pkg/client.js", "../src/postgrest-parser.ts", "../src/auth/schema.ts", "../src/auth/jwt.ts", "../src/auth/crypto.ts", "../src/auth/handler.ts", "../src/storage/backend.ts", "../src/storage/schema.ts", "../src/storage/handler.ts", "../src/fetch-adapter/auth-routes.ts", "../src/fetch-adapter/auth-context.ts", "../src/fetch-adapter/error-handler.ts", "../src/fetch-adapter/data-routes.ts", "../src/fetch-adapter/storage-routes.ts", "../src/fetch-adapter/index.ts", "../src/client.ts", "../src/supabase-client.ts", "../src/queue.ts", "../src/pooler.ts", "../src/types.ts"],
  "sourcesContent": ["/* @ts-self-types=\"./postgrest_parser.d.ts\" */\n\n/**\n * Result of parsing a PostgREST query, designed for TypeScript consumption.\n */\nexport class WasmQueryResult {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WasmQueryResult.prototype);\n        obj.__wbg_ptr = ptr;\n        WasmQueryResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WasmQueryResultFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_wasmqueryresult_free(ptr, 0);\n    }\n    /**\n     * Get the query parameters as a JSON string\n     * @returns {any}\n     */\n    get params() {\n        const ret = wasm.wasmqueryresult_params(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the SQL query string\n     * @returns {string}\n     */\n    get query() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.wasmqueryresult_query(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export4(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the list of tables as a JSON array\n     * @returns {any}\n     */\n    get tables() {\n        const ret = wasm.wasmqueryresult_tables(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the entire result as a JSON object\n     * @returns {any}\n     */\n    toJSON() {\n        const ret = wasm.wasmqueryresult_toJSON(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) WasmQueryResult.prototype[Symbol.dispose] = WasmQueryResult.prototype.free;\n\n/**\n * Build a WHERE clause from parsed filters.\n *\n * # Arguments\n *\n * * `filters_json` - JSON array of filter conditions\n *\n * # Returns\n *\n * Returns an object with `clause` (SQL string) and `params` (array of values).\n * @param {any} filters_json\n * @returns {any}\n */\nexport function buildFilterClause(filters_json) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.buildFilterClause(retptr, addHeapObject(filters_json));\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Initialize schema cache from a database query executor.\n *\n * This function accepts a JavaScript async function that executes SQL queries\n * and returns results. The schema introspection queries will be executed via\n * this callback to populate the relationship cache.\n *\n * # Arguments\n *\n * * `query_executor` - An async JavaScript function with signature:\n *   `async (sql: string) => { rows: any[] }`\n *\n * # Example (TypeScript with PGlite)\n *\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite';\n * import { initSchemaFromDb } from './pkg/postgrest_parser.js';\n *\n * const db = new PGlite();\n *\n * // Create query executor for WASM\n * const queryExecutor = async (sql: string) => {\n *   const result = await db.query(sql);\n *   return { rows: result.rows };\n * };\n *\n * // Initialize schema from database\n * await initSchemaFromDb(queryExecutor);\n * ```\n * @param {Function} query_executor\n * @returns {Promise<void>}\n */\nexport function initSchemaFromDb(query_executor) {\n    const ret = wasm.initSchemaFromDb(addHeapObject(query_executor));\n    return takeObject(ret);\n}\n\n/**\n * Initialize WASM module (call this first from JavaScript)\n */\nexport function init_panic_hook() {\n    wasm.init_panic_hook();\n}\n\n/**\n * Parse and generate SQL for a DELETE operation.\n *\n * # Arguments\n *\n * * `table` - The table name\n * * `query_string` - Query string with filters and optional returning\n * * `headers` - Optional headers as JSON string\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseDelete(\"users\", \"id=eq.123&returning=id\", null);\n * console.log(result.query);   // DELETE FROM \"users\" WHERE ...\n * console.log(result.params);  // [\"123\"]\n * ```\n * @param {string} table\n * @param {string} query_string\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseDelete(table, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.parseDelete(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse and generate SQL for an INSERT operation.\n *\n * # Arguments\n *\n * * `table` - The table name\n * * `body` - JSON body (single object or array of objects)\n * * `query_string` - Optional query string for returning, on_conflict, etc.\n * * `headers` - Optional headers as JSON string (e.g., '{\"Prefer\":\"return=representation\"}')\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseInsert(\"users\",\n *   JSON.stringify({ name: \"Alice\", email: \"alice@example.com\" }),\n *   \"on_conflict=email&returning=id,name\",\n *   JSON.stringify({ Prefer: \"return=representation\" })\n * );\n * console.log(result.query);   // INSERT INTO \"users\" ...\n * console.log(result.params);  // [\"Alice\", \"alice@example.com\"]\n * ```\n * @param {string} table\n * @param {string} body\n * @param {string | null} [query_string]\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseInsert(table, body, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(query_string) ? 0 : passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.parseInsert(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse only the query string without generating SQL.\n *\n * Useful if you want to inspect the parsed structure before generating SQL.\n *\n * # Arguments\n *\n * * `query_string` - The PostgREST query string\n *\n * # Returns\n *\n * Returns the parsed parameters as a JSON object.\n * @param {string} query_string\n * @returns {any}\n */\nexport function parseOnly(query_string) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.parseOnly(retptr, ptr0, len0);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse a PostgREST query string and convert it to SQL.\n *\n * # Arguments\n *\n * * `table` - The table name to query\n * * `query_string` - The PostgREST query string (e.g., \"select=id,name&age=gte.18\")\n *\n * # Returns\n *\n * Returns a `WasmQueryResult` containing the SQL query, parameters, and affected tables.\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseQueryString(\"users\", \"age=gte.18&status=eq.active\");\n * console.log(result.query);   // SELECT * FROM \"users\" WHERE ...\n * console.log(result.params);  // [\"18\", \"active\"]\n * console.log(result.tables);  // [\"users\"]\n * ```\n * @param {string} table\n * @param {string} query_string\n * @returns {WasmQueryResult}\n */\nexport function parseQueryString(table, query_string) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.parseQueryString(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse a complete HTTP request and generate appropriate SQL.\n *\n * This is the most comprehensive function - it handles all HTTP methods\n * and automatically chooses between SELECT, INSERT, UPDATE, DELETE, or RPC.\n *\n * # Arguments\n *\n * * `method` - HTTP method: \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"\n * * `path` - Resource path (table name or \"rpc/function_name\")\n * * `query_string` - URL query string\n * * `body` - Request body as JSON string (or null)\n * * `headers` - Optional headers as JSON object (for Prefer header)\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * // SELECT query\n * const getResult = parseRequest(\"GET\", \"users\", \"age=gte.18&limit=10\", null, null);\n *\n * // INSERT with upsert\n * const postResult = parseRequest(\"POST\", \"users\", \"on_conflict=email\",\n *   JSON.stringify({ name: \"Alice\", email: \"alice@example.com\" }),\n *   JSON.stringify({ Prefer: \"return=representation\" })\n * );\n *\n * // RPC call\n * const rpcResult = parseRequest(\"POST\", \"rpc/my_function\",\n *   \"select=result\",\n *   JSON.stringify({ arg1: \"value\" }),\n *   null\n * );\n * ```\n * @param {string} method\n * @param {string} path\n * @param {string} query_string\n * @param {string | null} [body]\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseRequest(method, path, query_string, body, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(method, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        var ptr4 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len4 = WASM_VECTOR_LEN;\n        wasm.parseRequest(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse and generate SQL for an RPC (stored procedure/function) call.\n *\n * # Arguments\n *\n * * `function_name` - The function name (can include schema: \"schema.function\")\n * * `body` - JSON object with function arguments (or null for no args)\n * * `query_string` - Optional query string for filtering/ordering results\n * * `headers` - Optional headers as JSON string\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseRpc(\"calculate_total\",\n *   JSON.stringify({ order_id: 123, tax_rate: 0.08 }),\n *   \"select=total,tax&limit=1\",\n *   null\n * );\n * console.log(result.query);   // SELECT * FROM calculate_total(...)\n * console.log(result.params);  // [123, 0.08]\n * ```\n * @param {string} function_name\n * @param {string | null} [body]\n * @param {string | null} [query_string]\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseRpc(function_name, body, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(query_string) ? 0 : passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.parseRpc(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse and generate SQL for an UPDATE operation.\n *\n * # Arguments\n *\n * * `table` - The table name\n * * `body` - JSON object with fields to update\n * * `query_string` - Query string with filters and optional returning\n * * `headers` - Optional headers as JSON string\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseUpdate(\"users\",\n *   JSON.stringify({ status: \"active\" }),\n *   \"id=eq.123&returning=id,status\",\n *   null\n * );\n * console.log(result.query);   // UPDATE \"users\" SET ...\n * console.log(result.params);  // [\"active\", \"123\"]\n * ```\n * @param {string} table\n * @param {string} body\n * @param {string} query_string\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseUpdate(table, body, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.parseUpdate(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction __wbg_get_imports() {\n    const import0 = {\n        __proto__: null,\n        __wbg_Error_8c4e43fe74559d73: function(arg0, arg1) {\n            const ret = Error(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        },\n        __wbg_Number_04624de7d0e8332d: function(arg0) {\n            const ret = Number(getObject(arg0));\n            return ret;\n        },\n        __wbg_String_8f0eb39a4a4c2f66: function(arg0, arg1) {\n            const ret = String(getObject(arg1));\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_bigint_get_as_i64_8fcf4ce7f1ca72a2: function(arg0, arg1) {\n            const v = getObject(arg1);\n            const ret = typeof(v) === 'bigint' ? v : undefined;\n            getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_boolean_get_bbbb1c18aa2f5e25: function(arg0) {\n            const v = getObject(arg0);\n            const ret = typeof(v) === 'boolean' ? v : undefined;\n            return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n        },\n        __wbg___wbindgen_debug_string_0bc8482c6e3508ae: function(arg0, arg1) {\n            const ret = debugString(getObject(arg1));\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_in_47fa6863be6f2f25: function(arg0, arg1) {\n            const ret = getObject(arg0) in getObject(arg1);\n            return ret;\n        },\n        __wbg___wbindgen_is_bigint_31b12575b56f32fc: function(arg0) {\n            const ret = typeof(getObject(arg0)) === 'bigint';\n            return ret;\n        },\n        __wbg___wbindgen_is_function_0095a73b8b156f76: function(arg0) {\n            const ret = typeof(getObject(arg0)) === 'function';\n            return ret;\n        },\n        __wbg___wbindgen_is_object_5ae8e5880f2c1fbd: function(arg0) {\n            const val = getObject(arg0);\n            const ret = typeof(val) === 'object' && val !== null;\n            return ret;\n        },\n        __wbg___wbindgen_is_string_cd444516edc5b180: function(arg0) {\n            const ret = typeof(getObject(arg0)) === 'string';\n            return ret;\n        },\n        __wbg___wbindgen_is_undefined_9e4d92534c42d778: function(arg0) {\n            const ret = getObject(arg0) === undefined;\n            return ret;\n        },\n        __wbg___wbindgen_jsval_eq_11888390b0186270: function(arg0, arg1) {\n            const ret = getObject(arg0) === getObject(arg1);\n            return ret;\n        },\n        __wbg___wbindgen_jsval_loose_eq_9dd77d8cd6671811: function(arg0, arg1) {\n            const ret = getObject(arg0) == getObject(arg1);\n            return ret;\n        },\n        __wbg___wbindgen_number_get_8ff4255516ccad3e: function(arg0, arg1) {\n            const obj = getObject(arg1);\n            const ret = typeof(obj) === 'number' ? obj : undefined;\n            getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_string_get_72fb696202c56729: function(arg0, arg1) {\n            const obj = getObject(arg1);\n            const ret = typeof(obj) === 'string' ? obj : undefined;\n            var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_throw_be289d5034ed271b: function(arg0, arg1) {\n            throw new Error(getStringFromWasm0(arg0, arg1));\n        },\n        __wbg__wbg_cb_unref_d9b87ff7982e3b21: function(arg0) {\n            getObject(arg0)._wbg_cb_unref();\n        },\n        __wbg_call_389efe28435a9388: function() { return handleError(function (arg0, arg1) {\n            const ret = getObject(arg0).call(getObject(arg1));\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_call_4708e0c13bdc8e95: function() { return handleError(function (arg0, arg1, arg2) {\n            const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_done_57b39ecd9addfe81: function(arg0) {\n            const ret = getObject(arg0).done;\n            return ret;\n        },\n        __wbg_entries_58c7934c745daac7: function(arg0) {\n            const ret = Object.entries(getObject(arg0));\n            return addHeapObject(ret);\n        },\n        __wbg_error_7534b8e9a36f1ab4: function(arg0, arg1) {\n            let deferred0_0;\n            let deferred0_1;\n            try {\n                deferred0_0 = arg0;\n                deferred0_1 = arg1;\n                console.error(getStringFromWasm0(arg0, arg1));\n            } finally {\n                wasm.__wbindgen_export4(deferred0_0, deferred0_1, 1);\n            }\n        },\n        __wbg_get_9b94d73e6221f75c: function(arg0, arg1) {\n            const ret = getObject(arg0)[arg1 >>> 0];\n            return addHeapObject(ret);\n        },\n        __wbg_get_b3ed3ad4be2bc8ac: function() { return handleError(function (arg0, arg1) {\n            const ret = Reflect.get(getObject(arg0), getObject(arg1));\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_get_with_ref_key_1dc361bd10053bfe: function(arg0, arg1) {\n            const ret = getObject(arg0)[getObject(arg1)];\n            return addHeapObject(ret);\n        },\n        __wbg_instanceof_ArrayBuffer_c367199e2fa2aa04: function(arg0) {\n            let result;\n            try {\n                result = getObject(arg0) instanceof ArrayBuffer;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Map_53af74335dec57f4: function(arg0) {\n            let result;\n            try {\n                result = getObject(arg0) instanceof Map;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Uint8Array_9b9075935c74707c: function(arg0) {\n            let result;\n            try {\n                result = getObject(arg0) instanceof Uint8Array;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_isArray_d314bb98fcf08331: function(arg0) {\n            const ret = Array.isArray(getObject(arg0));\n            return ret;\n        },\n        __wbg_isSafeInteger_bfbc7332a9768d2a: function(arg0) {\n            const ret = Number.isSafeInteger(getObject(arg0));\n            return ret;\n        },\n        __wbg_iterator_6ff6560ca1568e55: function() {\n            const ret = Symbol.iterator;\n            return addHeapObject(ret);\n        },\n        __wbg_length_32ed9a279acd054c: function(arg0) {\n            const ret = getObject(arg0).length;\n            return ret;\n        },\n        __wbg_length_35a7bace40f36eac: function(arg0) {\n            const ret = getObject(arg0).length;\n            return ret;\n        },\n        __wbg_log_6b5ca2e6124b2808: function(arg0) {\n            console.log(getObject(arg0));\n        },\n        __wbg_new_361308b2356cecd0: function() {\n            const ret = new Object();\n            return addHeapObject(ret);\n        },\n        __wbg_new_3eb36ae241fe6f44: function() {\n            const ret = new Array();\n            return addHeapObject(ret);\n        },\n        __wbg_new_8a6f238a6ece86ea: function() {\n            const ret = new Error();\n            return addHeapObject(ret);\n        },\n        __wbg_new_b5d9e2fb389fef91: function(arg0, arg1) {\n            try {\n                var state0 = {a: arg0, b: arg1};\n                var cb0 = (arg0, arg1) => {\n                    const a = state0.a;\n                    state0.a = 0;\n                    try {\n                        return __wasm_bindgen_func_elem_443(a, state0.b, arg0, arg1);\n                    } finally {\n                        state0.a = a;\n                    }\n                };\n                const ret = new Promise(cb0);\n                return addHeapObject(ret);\n            } finally {\n                state0.a = state0.b = 0;\n            }\n        },\n        __wbg_new_dca287b076112a51: function() {\n            const ret = new Map();\n            return addHeapObject(ret);\n        },\n        __wbg_new_dd2b680c8bf6ae29: function(arg0) {\n            const ret = new Uint8Array(getObject(arg0));\n            return addHeapObject(ret);\n        },\n        __wbg_new_no_args_1c7c842f08d00ebb: function(arg0, arg1) {\n            const ret = new Function(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        },\n        __wbg_next_3482f54c49e8af19: function() { return handleError(function (arg0) {\n            const ret = getObject(arg0).next();\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_next_418f80d8f5303233: function(arg0) {\n            const ret = getObject(arg0).next;\n            return addHeapObject(ret);\n        },\n        __wbg_prototypesetcall_bdcdcc5842e4d77d: function(arg0, arg1, arg2) {\n            Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), getObject(arg2));\n        },\n        __wbg_queueMicrotask_0aa0a927f78f5d98: function(arg0) {\n            const ret = getObject(arg0).queueMicrotask;\n            return addHeapObject(ret);\n        },\n        __wbg_queueMicrotask_5bb536982f78a56f: function(arg0) {\n            queueMicrotask(getObject(arg0));\n        },\n        __wbg_resolve_002c4b7d9d8f6b64: function(arg0) {\n            const ret = Promise.resolve(getObject(arg0));\n            return addHeapObject(ret);\n        },\n        __wbg_set_1eb0999cf5d27fc8: function(arg0, arg1, arg2) {\n            const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n            return addHeapObject(ret);\n        },\n        __wbg_set_3f1d0b984ed272ed: function(arg0, arg1, arg2) {\n            getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n        },\n        __wbg_set_f43e577aea94465b: function(arg0, arg1, arg2) {\n            getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n        },\n        __wbg_stack_0ed75d68575b0f3c: function(arg0, arg1) {\n            const ret = getObject(arg1).stack;\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg_static_accessor_GLOBAL_12837167ad935116: function() {\n            const ret = typeof global === 'undefined' ? null : global;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_static_accessor_GLOBAL_THIS_e628e89ab3b1c95f: function() {\n            const ret = typeof globalThis === 'undefined' ? null : globalThis;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_static_accessor_SELF_a621d3dfbb60d0ce: function() {\n            const ret = typeof self === 'undefined' ? null : self;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_static_accessor_WINDOW_f8727f0cf888e0bd: function() {\n            const ret = typeof window === 'undefined' ? null : window;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_then_0d9fe2c7b1857d32: function(arg0, arg1, arg2) {\n            const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n            return addHeapObject(ret);\n        },\n        __wbg_then_b9e7b3b5f1a9e1b5: function(arg0, arg1) {\n            const ret = getObject(arg0).then(getObject(arg1));\n            return addHeapObject(ret);\n        },\n        __wbg_value_0546255b415e96c1: function(arg0) {\n            const ret = getObject(arg0).value;\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000001: function(arg0, arg1) {\n            // Cast intrinsic for `Closure(Closure { dtor_idx: 51, function: Function { arguments: [Externref], shim_idx: 52, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n            const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_363, __wasm_bindgen_func_elem_364);\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000002: function(arg0) {\n            // Cast intrinsic for `F64 -> Externref`.\n            const ret = arg0;\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000003: function(arg0) {\n            // Cast intrinsic for `I64 -> Externref`.\n            const ret = arg0;\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000004: function(arg0, arg1) {\n            // Cast intrinsic for `Ref(String) -> Externref`.\n            const ret = getStringFromWasm0(arg0, arg1);\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000005: function(arg0) {\n            // Cast intrinsic for `U64 -> Externref`.\n            const ret = BigInt.asUintN(64, arg0);\n            return addHeapObject(ret);\n        },\n        __wbindgen_object_clone_ref: function(arg0) {\n            const ret = getObject(arg0);\n            return addHeapObject(ret);\n        },\n        __wbindgen_object_drop_ref: function(arg0) {\n            takeObject(arg0);\n        },\n    };\n    return {\n        __proto__: null,\n        \"./postgrest_parser_bg.js\": import0,\n    };\n}\n\nfunction __wasm_bindgen_func_elem_364(arg0, arg1, arg2) {\n    wasm.__wasm_bindgen_func_elem_364(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wasm_bindgen_func_elem_443(arg0, arg1, arg2, arg3) {\n    wasm.__wasm_bindgen_func_elem_443(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\nconst WasmQueryResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_wasmqueryresult_free(ptr >>> 0, 1));\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => state.dtor(state.a, state.b));\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedDataViewMemory0 = null;\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export3(addHeapObject(e));\n    }\n}\n\nlet heap = new Array(128).fill(undefined);\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            state.a = a;\n            real._wbg_cb_unref();\n        }\n    };\n    real._wbg_cb_unref = () => {\n        if (--state.cnt === 0) {\n            state.dtor(state.a, state.b);\n            state.a = 0;\n            CLOSURE_DTORS.unregister(state);\n        }\n    };\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\ncachedTextDecoder.decode();\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet wasmModule, wasm;\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    wasmModule = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && expectedResponseType(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else { throw e; }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        } else {\n            return instance;\n        }\n    }\n\n    function expectedResponseType(type) {\n        switch (type) {\n            case 'basic': case 'cors': case 'default': return true;\n        }\n        return false;\n    }\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module !== undefined) {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module_or_path !== undefined) {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (module_or_path === undefined) {\n        module_or_path = new URL('postgrest_parser_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync, __wbg_init as default };\n", "/**\n * Type-safe TypeScript wrapper for PostgREST Parser\n *\n * This module provides a type-safe, idiomatic TypeScript API on top of\n * the auto-generated WASM bindings, improving developer experience.\n */\nimport { parseRequest as wasmParseRequest, parseInsert as wasmParseInsert, parseUpdate as wasmParseUpdate, parseDelete as wasmParseDelete, parseRpc as wasmParseRpc, parseOnly as wasmParseOnly, buildFilterClause as wasmBuildFilterClause, } from \"./postgrest_parser.js\";\n// Re-export WASM initialization functions\nexport { default as init, initSchemaFromDb } from \"./postgrest_parser.js\";\n/**\n * Convert WASM result to typed QueryResult\n */\nfunction toQueryResult(wasmResult) {\n    return {\n        query: wasmResult.query,\n        params: wasmResult.params,\n        tables: wasmResult.tables,\n    };\n}\n/**\n * Convert headers object to JSON string\n */\nfunction headersToJson(headers) {\n    return headers ? JSON.stringify(headers) : undefined;\n}\n/**\n * Convert PreferOptions to Prefer header value\n */\nfunction preferToHeader(prefer) {\n    if (!prefer)\n        return undefined;\n    const parts = [];\n    if (prefer.return)\n        parts.push(`return=${prefer.return}`);\n    if (prefer.resolution)\n        parts.push(`resolution=${prefer.resolution}`);\n    if (prefer.missing)\n        parts.push(`missing=${prefer.missing}`);\n    if (prefer.count)\n        parts.push(`count=${prefer.count}`);\n    return parts.length > 0 ? parts.join(\",\") : undefined;\n}\n/**\n * Build query string from filters and options\n */\nfunction buildQueryString(filters, options) {\n    const parts = [];\n    // Add filters\n    if (filters) {\n        for (const [key, value] of Object.entries(filters)) {\n            parts.push(`${key}=${value}`);\n        }\n    }\n    // Add select\n    if (options?.select) {\n        const select = Array.isArray(options.select)\n            ? options.select.join(\",\")\n            : options.select;\n        parts.push(`select=${select}`);\n    }\n    // Add order\n    if (options?.order) {\n        const order = Array.isArray(options.order)\n            ? options.order.join(\",\")\n            : options.order;\n        parts.push(`order=${order}`);\n    }\n    // Add limit\n    if (options?.limit !== undefined) {\n        parts.push(`limit=${options.limit}`);\n    }\n    // Add offset\n    if (options?.offset !== undefined) {\n        parts.push(`offset=${options.offset}`);\n    }\n    // Add on_conflict\n    if (options?.onConflict) {\n        const onConflict = Array.isArray(options.onConflict)\n            ? options.onConflict.join(\",\")\n            : options.onConflict;\n        parts.push(`on_conflict=${onConflict}`);\n    }\n    // Add returning\n    if (options?.returning) {\n        const returning = Array.isArray(options.returning)\n            ? options.returning.join(\",\")\n            : options.returning;\n        parts.push(`returning=${returning}`);\n    }\n    return parts.join(\"&\");\n}\n/**\n * Type-safe PostgREST Parser client\n *\n * Provides strongly-typed methods for generating PostgREST-compatible SQL queries.\n *\n * @example\n * ```typescript\n * const client = new PostgRESTParser();\n *\n * // SELECT query\n * const getUsers = client.select(\"users\", {\n *   filters: { \"age\": \"gte.18\", \"status\": \"eq.active\" },\n *   order: [\"created_at.desc\"],\n *   limit: 10\n * });\n *\n * // INSERT query\n * const createUser = client.insert(\"users\", {\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * }, {\n *   returning: \"*\",\n *   prefer: { return: \"representation\" }\n * });\n *\n * // Execute with your database client\n * const rows = await db.query(getUsers.query, getUsers.params);\n * ```\n */\nexport class PostgRESTParser {\n    /**\n     * Parse a complete HTTP request and generate appropriate SQL\n     *\n     * This is the universal routing method that handles all HTTP methods.\n     *\n     * @param method - HTTP method: \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"\n     * @param path - Resource path (table name or \"rpc/function_name\")\n     * @param queryString - URL query string\n     * @param body - Request body (object or null)\n     * @param headers - Request headers (object or null)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.parseRequest(\"GET\", \"users\", \"age=gte.18\", null, null);\n     * const rows = await db.query(result.query, result.params);\n     * ```\n     */\n    parseRequest(method, path, queryString, body, headers) {\n        const bodyJson = body ? JSON.stringify(body) : undefined;\n        const headersJson = headers ? headersToJson(headers) : undefined;\n        const result = wasmParseRequest(method, path, queryString, bodyJson, headersJson);\n        return toQueryResult(result);\n    }\n    /**\n     * Generate a SELECT query\n     *\n     * @param table - Table name to query\n     * @param options - Query options (filters, ordering, pagination)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.select(\"users\", {\n     *   filters: { \"age\": \"gte.18\", \"status\": \"eq.active\" },\n     *   order: [\"created_at.desc\"],\n     *   limit: 10,\n     *   offset: 0\n     * });\n     * ```\n     */\n    select(table, options = {}) {\n        const queryString = buildQueryString(options.filters, options);\n        const headers = options.count\n            ? { Prefer: `count=${options.count}` }\n            : undefined;\n        const result = wasmParseRequest(\"GET\", table, queryString, undefined, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an INSERT query\n     *\n     * @param table - Table name\n     * @param data - Data to insert (single object or array of objects)\n     * @param options - Insert options (returning, onConflict, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.insert(\"users\", {\n     *   name: \"Alice\",\n     *   email: \"alice@example.com\"\n     * }, {\n     *   returning: \"*\",\n     *   prefer: { return: \"representation\" }\n     * });\n     * ```\n     */\n    insert(table, data, options = {}) {\n        const queryString = buildQueryString(undefined, {\n            onConflict: options.onConflict,\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseInsert(table, JSON.stringify(data), queryString || undefined, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an UPSERT query (INSERT with ON CONFLICT)\n     *\n     * PUT method auto-generates ON CONFLICT from filter columns.\n     *\n     * @param table - Table name\n     * @param data - Data to upsert\n     * @param conflictColumns - Columns to use for conflict detection\n     * @param options - Upsert options (returning, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.upsert(\"users\", {\n     *   email: \"alice@example.com\",\n     *   name: \"Alice Updated\"\n     * }, [\"email\"], {\n     *   returning: \"*\"\n     * });\n     * ```\n     */\n    upsert(table, data, conflictColumns, options = {}) {\n        // Build filters from conflict columns for PUT auto-conflict\n        const filters = {};\n        for (const col of conflictColumns) {\n            if (col in data) {\n                filters[col] = `eq.${data[col]}`;\n            }\n        }\n        const queryString = buildQueryString(filters, {\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseRequest(\"PUT\", table, queryString, JSON.stringify(data), headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an UPDATE query\n     *\n     * @param table - Table name\n     * @param data - Data to update\n     * @param filters - Filter conditions to match rows\n     * @param options - Update options (returning, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.update(\"users\", {\n     *   status: \"active\"\n     * }, {\n     *   \"id\": \"eq.123\"\n     * }, {\n     *   returning: \"id,status\"\n     * });\n     * ```\n     */\n    update(table, data, filters, options = {}) {\n        const queryString = buildQueryString(filters, {\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseUpdate(table, JSON.stringify(data), queryString, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate a DELETE query\n     *\n     * @param table - Table name\n     * @param filters - Filter conditions to match rows to delete\n     * @param options - Delete options (returning, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.delete(\"users\", {\n     *   \"status\": \"eq.inactive\",\n     *   \"last_login\": \"lt.2023-01-01\"\n     * }, {\n     *   returning: \"id\"\n     * });\n     * ```\n     */\n    delete(table, filters, options = {}) {\n        const queryString = buildQueryString(filters, {\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseDelete(table, queryString, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an RPC (stored procedure/function) call\n     *\n     * @param functionName - Function name (can include schema)\n     * @param args - Function arguments as object\n     * @param options - RPC options (select, filters, ordering)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.rpc(\"calculate_total\", {\n     *   order_id: 123,\n     *   tax_rate: 0.08\n     * }, {\n     *   select: [\"total\", \"tax\"],\n     *   limit: 1\n     * });\n     * ```\n     */\n    rpc(functionName, args = {}, options = {}) {\n        const queryString = buildQueryString(options.filters, options);\n        const result = wasmParseRpc(functionName, JSON.stringify(args), queryString || undefined, undefined);\n        return toQueryResult(result);\n    }\n    /**\n     * Parse a query string without generating SQL\n     *\n     * Useful for inspecting the parsed structure before generating SQL.\n     *\n     * @param queryString - PostgREST query string\n     * @returns Parsed query parameters as object\n     *\n     * @example\n     * ```typescript\n     * const parsed = client.parseOnly(\"age=gte.18&status=eq.active&order=created_at.desc\");\n     * console.log(parsed); // { filters: [...], order: [...] }\n     * ```\n     */\n    parseOnly(queryString) {\n        return wasmParseOnly(queryString);\n    }\n    /**\n     * Build a WHERE clause from filter conditions\n     *\n     * @param filters - Filter conditions as object\n     * @returns Object with clause (SQL string) and params (array of values)\n     *\n     * @example\n     * ```typescript\n     * const filters = [\n     *   { column: \"age\", operator: \"gte\", value: \"18\" },\n     *   { column: \"status\", operator: \"eq\", value: \"active\" }\n     * ];\n     * const result = client.buildFilterClause(filters);\n     * console.log(result.clause); // \"age >= $1 AND status = $2\"\n     * console.log(result.params);  // [\"18\", \"active\"]\n     * ```\n     */\n    buildFilterClause(filters) {\n        return wasmBuildFilterClause(filters);\n    }\n}\n/**\n * Create a new PostgREST Parser client instance\n *\n * @returns New PostgRESTParser instance\n *\n * @example\n * ```typescript\n * import { createClient } from './pkg/client.js';\n *\n * const client = createClient();\n * const result = client.select(\"users\", { limit: 10 });\n * ```\n */\nexport function createClient() {\n    return new PostgRESTParser();\n}\n", "/**\n * PostgREST Query Parser Wrapper\n * Uses native_postgrest_parser WASM to convert PostgREST queries to SQL\n */\n\nimport init, {\n  initSchemaFromDb,\n} from \"postgrest-parser/pkg/postgrest_parser.js\";\nimport { createClient } from \"postgrest-parser/pkg/client.js\";\nimport type { QueryResult as ParserQueryResult } from \"postgrest-parser/pkg/types.js\";\n\n/**\n * Query executor function type for schema introspection\n */\nexport type QueryExecutor = (sql: string) => Promise<{ rows: unknown[] }>;\n\n/**\n * Parsed SQL query with parameters\n */\nexport interface ParsedQuery {\n  readonly sql: string;\n  readonly params: readonly unknown[];\n  readonly tables: readonly string[];\n}\n\n/**\n * PostgREST parser for converting REST queries to SQL\n */\nexport class PostgrestParser {\n  private readonly client: ReturnType<typeof createClient>;\n  private static initPromise: Promise<unknown> | null = null;\n\n  constructor() {\n    this.client = createClient();\n  }\n\n  /**\n   * Initialize the WASM module (must be called before first use)\n   * Safe to call multiple times - initialization happens only once\n   *\n   * Note: This uses the web target build which works in webcontainers and edge workers.\n   * For Node.js, the native_postgrest_parser package needs to be built with --target nodejs.\n   */\n  static async init(): Promise<void> {\n    if (!PostgrestParser.initPromise) {\n      PostgrestParser.initPromise = init();\n    }\n    await PostgrestParser.initPromise;\n  }\n\n  /**\n   * Initialize schema introspection from a database connection\n   * This enables the parser to validate queries against the actual database schema\n   *\n   * @param queryExecutor - Function that executes SQL queries and returns rows\n   *\n   * @example\n   * ```typescript\n   * import { PGlite } from '@electric-sql/pglite'\n   * import { PostgrestParser } from './postgrest-parser'\n   *\n   * const db = new PGlite()\n   * await PostgrestParser.init()\n   *\n   * // Initialize schema introspection\n   * await PostgrestParser.initSchema(async (sql) => {\n   *   const result = await db.query(sql)\n   *   return { rows: result.rows }\n   * })\n   * ```\n   */\n  static async initSchema(queryExecutor: QueryExecutor): Promise<void> {\n    await PostgrestParser.init();\n    await initSchemaFromDb(queryExecutor);\n  }\n\n  /**\n   * Parse a SELECT query from PostgREST format\n   *\n   * @example\n   * parseSelect('users', 'id=eq.1&select=id,name')\n   * // => { sql: 'SELECT \"id\", \"name\" FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseSelect(table: string, queryString: string = \"\"): ParsedQuery {\n    return this.parseRequest(\"GET\", table, queryString);\n  }\n\n  /**\n   * Parse an INSERT query from PostgREST format\n   *\n   * @example\n   * parseInsert('users', { name: 'Alice', email: 'alice@example.com' })\n   * // => { sql: 'INSERT INTO \"users\" (\"name\", \"email\") VALUES ($1, $2)', params: ['Alice', 'alice@example.com'] }\n   */\n  parseInsert(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string = \"\",\n  ): ParsedQuery {\n    return this.parseRequest(\"POST\", table, queryString, data);\n  }\n\n  /**\n   * Parse an UPDATE query from PostgREST format\n   *\n   * @example\n   * parseUpdate('users', { name: 'Alice' }, 'id=eq.1')\n   * // => { sql: 'UPDATE \"users\" SET \"name\" = $1 WHERE \"id\" = $2', params: ['Alice', 1] }\n   */\n  parseUpdate(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string,\n  ): ParsedQuery {\n    return this.parseRequest(\"PATCH\", table, queryString, data);\n  }\n\n  /**\n   * Parse a DELETE query from PostgREST format\n   *\n   * @example\n   * parseDelete('users', 'id=eq.1')\n   * // => { sql: 'DELETE FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseDelete(table: string, queryString: string): ParsedQuery {\n    return this.parseRequest(\"DELETE\", table, queryString);\n  }\n\n  /**\n   * Parse an RPC (function call) from PostgREST format\n   *\n   * @example\n   * parseRpc('calculate_total', { order_id: 123 })\n   * // => { sql: 'SELECT * FROM \"calculate_total\"($1)', params: [123] }\n   */\n  parseRpc(\n    functionName: string,\n    args?: Record<string, unknown>,\n    queryString: string = \"\",\n  ): ParsedQuery {\n    const path = `rpc/${functionName}`;\n    return this.parseRequest(\"POST\", path, queryString, args);\n  }\n\n  /**\n   * Parse a generic HTTP request to SQL\n   *\n   * @param method - HTTP method (GET, POST, PATCH, DELETE)\n   * @param path - Path without leading slash (e.g., 'users' or 'rpc/function_name')\n   * @param queryString - URL query parameters\n   * @param body - Request body (for POST/PATCH)\n   */\n  parseRequest(\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\",\n    path: string,\n    queryString: string = \"\",\n    body?: Record<string, unknown>,\n  ): ParsedQuery {\n    const result = this.client.parseRequest(\n      method,\n      path,\n      queryString,\n      body ?? null,\n      null,\n    );\n    return this.convertResult(result);\n  }\n\n  /**\n   * Convert WASM result to our ParsedQuery format\n   */\n  private convertResult(result: ParserQueryResult): ParsedQuery {\n    return {\n      sql: result.query,\n      params: Array.isArray(result.params) ? result.params : [],\n      tables: Array.isArray(result.tables) ? result.tables : [],\n    };\n  }\n}\n", "/**\n * SQL schema for auth tables (compatible with Supabase auth schema)\n * Uses pgcrypto extension for password hashing (available in PGlite)\n */\n\nexport const AUTH_SCHEMA_SQL = `\n-- Enable pgcrypto extension for password hashing\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n\n-- Create auth schema\nCREATE SCHEMA IF NOT EXISTS auth;\n\n-- Create PostgreSQL roles for RLS\nDO $$\nBEGIN\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'anon') THEN\n    CREATE ROLE anon NOLOGIN NOINHERIT;\n  END IF;\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'authenticated') THEN\n    CREATE ROLE authenticated NOLOGIN NOINHERIT;\n  END IF;\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'service_role') THEN\n    CREATE ROLE service_role NOLOGIN NOINHERIT BYPASSRLS;\n  END IF;\nEND\n$$;\n\n-- Grant necessary permissions to roles\nGRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;\nGRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;\nGRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO anon, authenticated, service_role;\n\n-- Grant service_role full access to auth schema (needed for auth operations)\nGRANT USAGE ON SCHEMA auth TO service_role;\nGRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;\nGRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON TABLES TO service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON SEQUENCES TO service_role;\n\n-- Users table\nCREATE TABLE IF NOT EXISTS auth.users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  instance_id UUID DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,\n  aud VARCHAR(255) DEFAULT 'authenticated',\n  role VARCHAR(255) DEFAULT 'authenticated',\n  email VARCHAR(255) UNIQUE,\n  encrypted_password VARCHAR(255),\n  email_confirmed_at TIMESTAMPTZ,\n  invited_at TIMESTAMPTZ,\n  confirmation_token VARCHAR(255),\n  confirmation_sent_at TIMESTAMPTZ,\n  recovery_token VARCHAR(255),\n  recovery_sent_at TIMESTAMPTZ,\n  email_change_token_new VARCHAR(255),\n  email_change VARCHAR(255),\n  email_change_sent_at TIMESTAMPTZ,\n  last_sign_in_at TIMESTAMPTZ,\n  raw_app_meta_data JSONB DEFAULT '{}'::jsonb,\n  raw_user_meta_data JSONB DEFAULT '{}'::jsonb,\n  is_super_admin BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  phone VARCHAR(255) UNIQUE,\n  phone_confirmed_at TIMESTAMPTZ,\n  phone_change VARCHAR(255),\n  phone_change_token VARCHAR(255),\n  phone_change_sent_at TIMESTAMPTZ,\n  email_change_token_current VARCHAR(255),\n  email_change_confirm_status SMALLINT DEFAULT 0,\n  banned_until TIMESTAMPTZ,\n  reauthentication_token VARCHAR(255),\n  reauthentication_sent_at TIMESTAMPTZ,\n  is_sso_user BOOLEAN DEFAULT FALSE,\n  deleted_at TIMESTAMPTZ,\n  is_anonymous BOOLEAN DEFAULT FALSE\n);\n\n-- Sessions table\nCREATE TABLE IF NOT EXISTS auth.sessions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  factor_id UUID,\n  aal VARCHAR(255) DEFAULT 'aal1',\n  not_after TIMESTAMPTZ,\n  refreshed_at TIMESTAMPTZ,\n  user_agent TEXT,\n  ip INET,\n  tag TEXT\n);\n\n-- Refresh tokens table\nCREATE TABLE IF NOT EXISTS auth.refresh_tokens (\n  id BIGSERIAL PRIMARY KEY,\n  token VARCHAR(255) UNIQUE NOT NULL,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  revoked BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  parent VARCHAR(255),\n  session_id UUID REFERENCES auth.sessions(id) ON DELETE CASCADE\n);\n\n-- Indexes for performance\nCREATE INDEX IF NOT EXISTS users_email_idx ON auth.users(email);\nCREATE INDEX IF NOT EXISTS users_instance_id_idx ON auth.users(instance_id);\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON auth.sessions(user_id);\nCREATE INDEX IF NOT EXISTS sessions_not_after_idx ON auth.sessions(not_after);\nCREATE INDEX IF NOT EXISTS refresh_tokens_token_idx ON auth.refresh_tokens(token);\nCREATE INDEX IF NOT EXISTS refresh_tokens_user_id_idx ON auth.refresh_tokens(user_id);\nCREATE INDEX IF NOT EXISTS refresh_tokens_session_id_idx ON auth.refresh_tokens(session_id);\n\n-- Function to get current user ID (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.uid() RETURNS UUID AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.sub', true), '')::uuid;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get current user role (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.role() RETURNS TEXT AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.role', true), '');\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get current user email (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.email() RETURNS TEXT AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.email', true), '');\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get JWT claims (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.jwt() RETURNS JSONB AS $$\n  SELECT COALESCE(\n    NULLIF(current_setting('request.jwt.claims', true), ''),\n    '{}'\n  )::jsonb;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to hash a password using pgcrypto\nCREATE OR REPLACE FUNCTION auth.hash_password(password TEXT) RETURNS TEXT AS $$\n  SELECT crypt(password, gen_salt('bf', 10));\n$$ LANGUAGE SQL;\n\n-- Function to verify a password against a hash\nCREATE OR REPLACE FUNCTION auth.verify_password(password TEXT, password_hash TEXT) RETURNS BOOLEAN AS $$\n  SELECT password_hash = crypt(password, password_hash);\n$$ LANGUAGE SQL;\n\n-- Function to generate a secure random token\nCREATE OR REPLACE FUNCTION auth.generate_token(length INT DEFAULT 32) RETURNS TEXT AS $$\n  SELECT encode(gen_random_bytes(length), 'hex');\n$$ LANGUAGE SQL;\n\n-- Function to create a new user with hashed password\nCREATE OR REPLACE FUNCTION auth.create_user(\n  p_email TEXT,\n  p_password TEXT,\n  p_user_metadata JSONB DEFAULT '{}'::jsonb,\n  p_app_metadata JSONB DEFAULT '{}'::jsonb\n) RETURNS auth.users AS $$\nDECLARE\n  v_user auth.users;\nBEGIN\n  INSERT INTO auth.users (\n    email,\n    encrypted_password,\n    email_confirmed_at,\n    raw_user_meta_data,\n    raw_app_meta_data,\n    created_at,\n    updated_at\n  ) VALUES (\n    p_email,\n    auth.hash_password(p_password),\n    NOW(), -- Auto-confirm for local development\n    p_user_metadata,\n    p_app_metadata,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_user;\n\n  RETURN v_user;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify user credentials and return user if valid\nCREATE OR REPLACE FUNCTION auth.verify_user_credentials(\n  p_email TEXT,\n  p_password TEXT\n) RETURNS auth.users AS $$\nDECLARE\n  v_user auth.users;\nBEGIN\n  SELECT * INTO v_user\n  FROM auth.users\n  WHERE email = p_email\n    AND deleted_at IS NULL\n    AND (banned_until IS NULL OR banned_until < NOW());\n\n  IF v_user IS NULL THEN\n    RETURN NULL;\n  END IF;\n\n  IF NOT auth.verify_password(p_password, v_user.encrypted_password) THEN\n    RETURN NULL;\n  END IF;\n\n  -- Update last sign in time\n  UPDATE auth.users\n  SET last_sign_in_at = NOW(), updated_at = NOW()\n  WHERE id = v_user.id;\n\n  RETURN v_user;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to create a session for a user\nCREATE OR REPLACE FUNCTION auth.create_session(\n  p_user_id UUID,\n  p_user_agent TEXT DEFAULT NULL,\n  p_ip TEXT DEFAULT NULL\n) RETURNS auth.sessions AS $$\nDECLARE\n  v_session auth.sessions;\nBEGIN\n  INSERT INTO auth.sessions (\n    user_id,\n    user_agent,\n    ip,\n    created_at,\n    updated_at,\n    refreshed_at\n  ) VALUES (\n    p_user_id,\n    p_user_agent,\n    p_ip::inet,\n    NOW(),\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_session;\n\n  RETURN v_session;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to create a refresh token for a session\nCREATE OR REPLACE FUNCTION auth.create_refresh_token(\n  p_user_id UUID,\n  p_session_id UUID\n) RETURNS auth.refresh_tokens AS $$\nDECLARE\n  v_refresh_token auth.refresh_tokens;\nBEGIN\n  INSERT INTO auth.refresh_tokens (\n    token,\n    user_id,\n    session_id,\n    created_at,\n    updated_at\n  ) VALUES (\n    auth.generate_token(32),\n    p_user_id,\n    p_session_id,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_refresh_token;\n\n  RETURN v_refresh_token;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to refresh a token (revoke old, create new)\nCREATE OR REPLACE FUNCTION auth.refresh_token(\n  p_refresh_token TEXT\n) RETURNS TABLE(\n  new_token TEXT,\n  user_id UUID,\n  session_id UUID\n) AS $$\nDECLARE\n  v_old_token_id BIGINT;\n  v_old_user_id UUID;\n  v_old_session_id UUID;\n  v_old_token_value TEXT;\n  v_new_token TEXT;\nBEGIN\n  -- Find and validate the old token\n  SELECT rt.id, rt.user_id, rt.session_id, rt.token\n  INTO v_old_token_id, v_old_user_id, v_old_session_id, v_old_token_value\n  FROM auth.refresh_tokens rt\n  WHERE rt.token = p_refresh_token\n    AND rt.revoked = FALSE;\n\n  IF v_old_token_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  -- Revoke the old token\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE id = v_old_token_id;\n\n  -- Update session refreshed_at\n  UPDATE auth.sessions\n  SET refreshed_at = NOW(), updated_at = NOW()\n  WHERE id = v_old_session_id;\n\n  -- Create new token\n  INSERT INTO auth.refresh_tokens (\n    token,\n    user_id,\n    session_id,\n    parent,\n    created_at,\n    updated_at\n  ) VALUES (\n    auth.generate_token(32),\n    v_old_user_id,\n    v_old_session_id,\n    v_old_token_value,\n    NOW(),\n    NOW()\n  ) RETURNING token INTO v_new_token;\n\n  -- Return the result\n  RETURN QUERY SELECT v_new_token, v_old_user_id, v_old_session_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to revoke all sessions for a user (sign out)\nCREATE OR REPLACE FUNCTION auth.sign_out(p_session_id UUID) RETURNS VOID AS $$\nBEGIN\n  -- Revoke all refresh tokens for this session\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE session_id = p_session_id;\n\n  -- Delete the session\n  DELETE FROM auth.sessions WHERE id = p_session_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to sign out all sessions for a user\nCREATE OR REPLACE FUNCTION auth.sign_out_all(p_user_id UUID) RETURNS VOID AS $$\nBEGIN\n  -- Revoke all refresh tokens\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE user_id = p_user_id;\n\n  -- Delete all sessions\n  DELETE FROM auth.sessions WHERE user_id = p_user_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Config table for storing signing key\nCREATE TABLE IF NOT EXISTS auth.config (\n  key TEXT PRIMARY KEY,\n  value TEXT NOT NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Function to get or create the signing key\nCREATE OR REPLACE FUNCTION auth.get_signing_key() RETURNS TEXT AS $$\nDECLARE\n  v_key TEXT;\nBEGIN\n  SELECT value INTO v_key FROM auth.config WHERE key = 'jwt_signing_key';\n\n  IF v_key IS NULL THEN\n    v_key := encode(gen_random_bytes(32), 'hex');\n    INSERT INTO auth.config (key, value) VALUES ('jwt_signing_key', v_key);\n  END IF;\n\n  RETURN v_key;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to base64url encode\nCREATE OR REPLACE FUNCTION auth.base64url_encode(data BYTEA) RETURNS TEXT AS $$\n  SELECT replace(replace(rtrim(encode(data, 'base64'), '='), '+', '-'), '/', '_');\n$$ LANGUAGE SQL IMMUTABLE;\n\n-- Function to base64url decode\nCREATE OR REPLACE FUNCTION auth.base64url_decode(data TEXT) RETURNS BYTEA AS $$\nDECLARE\n  v_padded TEXT;\n  v_converted TEXT;\nBEGIN\n  v_converted := replace(replace(data, '-', '+'), '_', '/');\n  v_padded := v_converted || repeat('=', (4 - length(v_converted) % 4) % 4);\n  RETURN decode(v_padded, 'base64');\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE;\n\n-- Function to create an access token (JWT-like structure using HMAC)\nCREATE OR REPLACE FUNCTION auth.create_access_token(\n  p_user_id UUID,\n  p_session_id UUID,\n  p_email TEXT,\n  p_role TEXT DEFAULT 'authenticated',\n  p_user_metadata JSONB DEFAULT '{}'::jsonb,\n  p_app_metadata JSONB DEFAULT '{}'::jsonb,\n  p_expires_in INT DEFAULT 3600\n) RETURNS TEXT AS $$\nDECLARE\n  v_key TEXT;\n  v_now BIGINT;\n  v_exp BIGINT;\n  v_header TEXT;\n  v_payload TEXT;\n  v_header_b64 TEXT;\n  v_payload_b64 TEXT;\n  v_signature_input TEXT;\n  v_signature TEXT;\nBEGIN\n  v_key := auth.get_signing_key();\n  v_now := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  v_exp := v_now + p_expires_in;\n\n  -- Create header\n  v_header := '{\"alg\":\"HS256\",\"typ\":\"JWT\"}';\n  v_header_b64 := auth.base64url_encode(v_header::bytea);\n\n  -- Create payload\n  v_payload := json_build_object(\n    'sub', p_user_id,\n    'aud', 'authenticated',\n    'role', p_role,\n    'email', p_email,\n    'session_id', p_session_id,\n    'iat', v_now,\n    'exp', v_exp,\n    'user_metadata', p_user_metadata,\n    'app_metadata', p_app_metadata\n  )::text;\n  v_payload_b64 := auth.base64url_encode(v_payload::bytea);\n\n  -- Create signature\n  v_signature_input := v_header_b64 || '.' || v_payload_b64;\n  v_signature := auth.base64url_encode(\n    hmac(v_signature_input::bytea, decode(v_key, 'hex'), 'sha256')\n  );\n\n  RETURN v_signature_input || '.' || v_signature;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify an access token and return payload\nCREATE OR REPLACE FUNCTION auth.verify_access_token(p_token TEXT) RETURNS TABLE(\n  valid BOOLEAN,\n  user_id UUID,\n  session_id UUID,\n  email TEXT,\n  role TEXT,\n  exp BIGINT,\n  user_metadata JSONB,\n  app_metadata JSONB,\n  error TEXT\n) AS $$\nDECLARE\n  v_parts TEXT[];\n  v_header_b64 TEXT;\n  v_payload_b64 TEXT;\n  v_signature_b64 TEXT;\n  v_key TEXT;\n  v_signature_input TEXT;\n  v_expected_sig TEXT;\n  v_payload JSONB;\n  v_now BIGINT;\nBEGIN\n  -- Split token into parts\n  v_parts := string_to_array(p_token, '.');\n\n  IF array_length(v_parts, 1) != 3 THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid token format'::TEXT;\n    RETURN;\n  END IF;\n\n  v_header_b64 := v_parts[1];\n  v_payload_b64 := v_parts[2];\n  v_signature_b64 := v_parts[3];\n\n  -- Verify signature\n  v_key := auth.get_signing_key();\n  v_signature_input := v_header_b64 || '.' || v_payload_b64;\n  v_expected_sig := auth.base64url_encode(\n    hmac(v_signature_input::bytea, decode(v_key, 'hex'), 'sha256')\n  );\n\n  IF v_signature_b64 != v_expected_sig THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid signature'::TEXT;\n    RETURN;\n  END IF;\n\n  -- Decode payload\n  BEGIN\n    v_payload := convert_from(auth.base64url_decode(v_payload_b64), 'UTF8')::jsonb;\n  EXCEPTION WHEN OTHERS THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid payload'::TEXT;\n    RETURN;\n  END;\n\n  -- Check expiration\n  v_now := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  IF (v_payload->>'exp')::BIGINT < v_now THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Token expired'::TEXT;\n    RETURN;\n  END IF;\n\n  -- Return valid token data\n  RETURN QUERY SELECT\n    true,\n    (v_payload->>'sub')::UUID,\n    (v_payload->>'session_id')::UUID,\n    v_payload->>'email',\n    v_payload->>'role',\n    (v_payload->>'exp')::BIGINT,\n    COALESCE(v_payload->'user_metadata', '{}'::jsonb),\n    COALESCE(v_payload->'app_metadata', '{}'::jsonb),\n    NULL::TEXT;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Grant execute permissions on auth schema functions to roles\n-- This allows RLS policies and DEFAULT values to use these functions\nGRANT USAGE ON SCHEMA auth TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.uid() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.role() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.email() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.jwt() TO anon, authenticated, service_role;\n\n-- Grant execute on auth management functions\n-- These have SECURITY DEFINER so they run with elevated privileges\nGRANT EXECUTE ON FUNCTION auth.create_user(TEXT, TEXT, JSONB, JSONB) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.verify_user_credentials(TEXT, TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_session(UUID, TEXT, TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_refresh_token(UUID, UUID) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.refresh_token(TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.sign_out(UUID) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.sign_out_all(UUID) TO authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.get_signing_key() TO authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_access_token(UUID, UUID, TEXT, TEXT, JSONB, JSONB, INT) TO service_role;\nGRANT EXECUTE ON FUNCTION auth.verify_access_token(TEXT) TO service_role;\n`;\n\n/**\n * Escape single quotes for SQL string literals\n */\nfunction escapeSqlString(value: string): string {\n  return value.replace(/'/g, \"''\");\n}\n\n/**\n * SQL to set auth context for a request (called before each query when authenticated)\n */\nexport function getSetAuthContextSQL(\n  userId: string,\n  role: string,\n  email: string,\n): string {\n  const claims = JSON.stringify({\n    sub: userId,\n    role: role,\n    email: email,\n    aud: \"authenticated\",\n  });\n\n  // Properly escape all values for SQL\n  const escapedUserId = escapeSqlString(userId);\n  const escapedRole = escapeSqlString(role);\n  const escapedEmail = escapeSqlString(email);\n  const escapedClaims = escapeSqlString(claims);\n\n  // IMPORTANT: SET ROLE switches the database role to enforce RLS\n  // Without this, queries run as superuser which bypasses RLS entirely\n  // Note: Using SET ROLE (not SET LOCAL ROLE) because each db call may be in a separate transaction\n  return `\n    SET ROLE ${escapedRole};\n    SELECT set_config('request.jwt.claim.sub', '${escapedUserId}', false);\n    SELECT set_config('request.jwt.claim.role', '${escapedRole}', false);\n    SELECT set_config('request.jwt.claim.email', '${escapedEmail}', false);\n    SELECT set_config('request.jwt.claims', '${escapedClaims}', false);\n  `;\n}\n\n/**\n * SQL to clear auth context (for anonymous/unauthenticated requests)\n */\nexport const CLEAR_AUTH_CONTEXT_SQL = `\n  SET ROLE anon;\n  SELECT set_config('request.jwt.claim.sub', '', false);\n  SELECT set_config('request.jwt.claim.role', 'anon', false);\n  SELECT set_config('request.jwt.claim.email', '', false);\n  SELECT set_config('request.jwt.claims', '{\"role\": \"anon\"}', false);\n`;\n", "/**\n * JWT utilities using Web Crypto API\n * Compatible with: Browser, Cloudflare Workers, Deno, Bun\n */\n\n/**\n * Base64URL encode (no padding)\n */\nfunction base64UrlEncode(data: Uint8Array): string {\n  const base64 = btoa(String.fromCharCode(...data));\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\n/**\n * Base64URL decode\n */\nfunction base64UrlDecode(str: string): Uint8Array<ArrayBuffer> {\n  const base64 = str\n    .replace(/-/g, \"+\")\n    .replace(/_/g, \"/\")\n    .padEnd(str.length + ((4 - (str.length % 4)) % 4), \"=\");\n\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\n * Text encoder/decoder (available in all modern runtimes)\n */\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\n/**\n * JWT payload structure\n */\nexport interface JWTPayload {\n  sub: string; // user ID\n  aud: string; // audience ('authenticated')\n  role: string; // user role\n  email?: string; // user email\n  session_id: string; // session ID\n  iat: number; // issued at (seconds)\n  exp: number; // expires at (seconds)\n  user_metadata: Record<string, unknown>;\n  app_metadata: Record<string, unknown>;\n}\n\n/**\n * Sign a JWT using HMAC-SHA256 (Web Crypto API)\n */\nexport async function signJWT(\n  payload: JWTPayload,\n  secret: string,\n): Promise<string> {\n  // Create header\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\",\n  };\n\n  // Encode header and payload\n  const headerB64 = base64UrlEncode(encoder.encode(JSON.stringify(header)));\n  const payloadB64 = base64UrlEncode(encoder.encode(JSON.stringify(payload)));\n  const data = `${headerB64}.${payloadB64}`;\n\n  // Sign with HMAC-SHA256\n  const key = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(secret),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"],\n  );\n\n  const signature = await crypto.subtle.sign(\"HMAC\", key, encoder.encode(data));\n\n  const signatureB64 = base64UrlEncode(new Uint8Array(signature));\n\n  return `${data}.${signatureB64}`;\n}\n\n/**\n * Verify a JWT signature using HMAC-SHA256 (Web Crypto API)\n */\nexport async function verifyJWT(\n  token: string,\n  secret: string,\n): Promise<{\n  valid: boolean;\n  payload?: JWTPayload;\n  error?: string;\n}> {\n  try {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n      return { valid: false, error: \"Invalid token format\" };\n    }\n\n    const [headerB64, payloadB64, signatureB64] = parts;\n\n    if (!headerB64 || !payloadB64 || !signatureB64) {\n      return { valid: false, error: \"Invalid token format\" };\n    }\n\n    const data = `${headerB64}.${payloadB64}`;\n\n    // Verify signature\n    const key = await crypto.subtle.importKey(\n      \"raw\",\n      encoder.encode(secret),\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"verify\"],\n    );\n\n    const signature = base64UrlDecode(signatureB64);\n    const isValid = await crypto.subtle.verify(\n      \"HMAC\",\n      key,\n      signature,\n      encoder.encode(data),\n    );\n\n    if (!isValid) {\n      return { valid: false, error: \"Invalid signature\" };\n    }\n\n    // Decode payload\n    const payloadJson = decoder.decode(base64UrlDecode(payloadB64));\n    const payload = JSON.parse(payloadJson) as JWTPayload;\n\n    // Check expiration\n    const now = Math.floor(Date.now() / 1000);\n    if (payload.exp && payload.exp < now) {\n      return { valid: false, error: \"Token expired\" };\n    }\n\n    return { valid: true, payload };\n  } catch (err) {\n    return {\n      valid: false,\n      error: err instanceof Error ? err.message : \"Verification failed\",\n    };\n  }\n}\n\n/**\n * Decode JWT payload without verification (for quick checks)\n */\nexport function decodeJWT(token: string): JWTPayload | null {\n  try {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) return null;\n\n    const payloadB64 = parts[1];\n    if (!payloadB64) return null;\n\n    const payloadJson = decoder.decode(base64UrlDecode(payloadB64));\n    return JSON.parse(payloadJson) as JWTPayload;\n  } catch {\n    return null;\n  }\n}\n", "/**\n * Crypto utilities for auth tokens\n * Uses Web Crypto API for JWT operations (browser/edge runtime compatible)\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport type { User, TokenPair } from \"./types.ts\";\nimport { signJWT, verifyJWT, decodeJWT, type JWTPayload } from \"./jwt.ts\";\n\n// Default token expiry: 1 hour (in seconds)\nconst DEFAULT_ACCESS_TOKEN_EXPIRY = 3600;\n\n// JWT secret key (in production, this should come from environment)\n// For now, we'll store it in the database and retrieve it\nlet cachedSecret: string | null = null;\n\n/**\n * Get or create JWT secret from database\n */\nasync function getJWTSecret(db: PGlite): Promise<string> {\n  if (cachedSecret) return cachedSecret;\n\n  // Get or create secret from database\n  const result = await db.query<{ value: string }>(\n    `SELECT value FROM auth.config WHERE key = 'jwt_secret'`,\n  );\n\n  if (result.rows.length > 0 && result.rows[0]) {\n    cachedSecret = result.rows[0].value;\n    return cachedSecret;\n  }\n\n  // Generate new secret (256-bit random hex string)\n  const bytes = new Uint8Array(32);\n  crypto.getRandomValues(bytes);\n  const secret = Array.from(bytes, (b) => b.toString(16).padStart(2, \"0\")).join(\n    \"\",\n  );\n\n  await db.exec(`\n    INSERT INTO auth.config (key, value)\n    VALUES ('jwt_secret', '${secret}')\n    ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value\n  `);\n\n  cachedSecret = secret;\n  return secret;\n}\n\n/**\n * Create an access token using Web Crypto API\n */\nexport async function createAccessToken(\n  db: PGlite,\n  user: User,\n  sessionId: string,\n  expiresIn: number = DEFAULT_ACCESS_TOKEN_EXPIRY,\n): Promise<string> {\n  const secret = await getJWTSecret(db);\n  const now = Math.floor(Date.now() / 1000);\n\n  const payload: JWTPayload = {\n    sub: user.id,\n    aud: \"authenticated\",\n    role: user.role,\n    email: user.email || undefined,\n    session_id: sessionId,\n    iat: now,\n    exp: now + expiresIn,\n    user_metadata: user.user_metadata || {},\n    app_metadata: user.app_metadata || {},\n  };\n\n  return signJWT(payload, secret);\n}\n\n/**\n * Verify and decode an access token using Web Crypto API\n */\nexport async function verifyAccessToken(\n  db: PGlite,\n  token: string,\n): Promise<{\n  valid: boolean;\n  payload?: {\n    sub: string;\n    aud: string;\n    role: string;\n    email?: string;\n    session_id: string;\n    iat: number;\n    exp: number;\n    user_metadata: Record<string, unknown>;\n    app_metadata: Record<string, unknown>;\n  };\n  error?: string;\n}> {\n  const secret = await getJWTSecret(db);\n  return verifyJWT(token, secret);\n}\n\n/**\n * Generate a token pair (access + refresh) for a user session\n */\nexport async function generateTokenPair(\n  db: PGlite,\n  user: User,\n  sessionId: string,\n  refreshToken: string,\n  expiresIn: number = DEFAULT_ACCESS_TOKEN_EXPIRY,\n): Promise<TokenPair> {\n  const accessToken = await createAccessToken(db, user, sessionId, expiresIn);\n  const now = Math.floor(Date.now() / 1000);\n\n  return {\n    accessToken,\n    refreshToken,\n    expiresIn,\n    expiresAt: now + expiresIn,\n  };\n}\n\n/**\n * Extract user ID from access token without full verification\n * (useful for quick checks, but should verify for security-sensitive operations)\n */\nexport function extractUserIdFromToken(token: string): string | null {\n  const payload = decodeJWT(token);\n  return payload?.sub || null;\n}\n\n/**\n * Extract session ID from access token without full verification\n */\nexport function extractSessionIdFromToken(token: string): string | null {\n  const payload = decodeJWT(token);\n  return payload?.session_id || null;\n}\n", "/**\n * Auth handler - processes auth requests and manages auth state\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport type {\n  User,\n  Session,\n  AuthResponse,\n  AuthError,\n  AuthChangeEvent,\n  AuthStateChangeCallback,\n  AuthSubscription,\n  StoredUser,\n  StoredSession,\n  StoredRefreshToken,\n} from \"./types.ts\";\nimport { AUTH_SCHEMA_SQL } from \"./schema.ts\";\nimport {\n  createAccessToken,\n  verifyAccessToken,\n  extractSessionIdFromToken,\n} from \"./crypto.ts\";\n\n// Default access token expiry: 1 hour\nconst ACCESS_TOKEN_EXPIRY = 3600;\n\n/**\n * Convert stored user to public user format\n */\nfunction toPublicUser(storedUser: StoredUser): User {\n  return {\n    id: storedUser.id,\n    aud: storedUser.aud,\n    role: storedUser.role,\n    email: storedUser.email,\n    email_confirmed_at: storedUser.email_confirmed_at || undefined,\n    phone: storedUser.phone || undefined,\n    phone_confirmed_at: storedUser.phone_confirmed_at || undefined,\n    confirmed_at:\n      storedUser.email_confirmed_at ||\n      storedUser.phone_confirmed_at ||\n      undefined,\n    last_sign_in_at: storedUser.last_sign_in_at || undefined,\n    app_metadata: storedUser.raw_app_meta_data || {},\n    user_metadata: storedUser.raw_user_meta_data || {},\n    created_at: storedUser.created_at,\n    updated_at: storedUser.updated_at,\n  };\n}\n\n/**\n * Create auth error response\n */\nfunction authError(message: string, status: number, code?: string): AuthError {\n  return { message, status, code };\n}\n\n/**\n * Auth handler class\n */\nexport class AuthHandler {\n  private db: PGlite;\n  private initialized = false;\n  private subscriptions = new Map<string, AuthStateChangeCallback>();\n  private currentSession: Session | null = null;\n\n  constructor(db: PGlite) {\n    this.db = db;\n  }\n\n  /**\n   * Initialize auth schema in the database\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    await this.db.exec(AUTH_SCHEMA_SQL);\n    this.initialized = true;\n  }\n\n  /**\n   * Emit auth state change to all subscribers\n   */\n  private emitAuthStateChange(\n    event: AuthChangeEvent,\n    session: Session | null,\n  ): void {\n    this.currentSession = session;\n    for (const callback of this.subscriptions.values()) {\n      try {\n        callback(event, session);\n      } catch (err) {\n        console.error(\"Auth state change callback error:\", err);\n      }\n    }\n  }\n\n  /**\n   * Subscribe to auth state changes\n   */\n  onAuthStateChange(callback: AuthStateChangeCallback): AuthSubscription {\n    const id = crypto.randomUUID();\n    this.subscriptions.set(id, callback);\n\n    // Emit initial session state\n    queueMicrotask(() => {\n      callback(\"INITIAL_SESSION\", this.currentSession);\n    });\n\n    return {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.subscriptions.delete(id);\n      },\n    };\n  }\n\n  /**\n   * Sign up a new user\n   */\n  async signUp(\n    email: string,\n    password: string,\n    options?: { data?: Record<string, unknown> },\n  ): Promise<AuthResponse> {\n    await this.initialize();\n\n    // Reset role to default before auth operation\n    await this.db.exec(\"RESET ROLE\");\n\n    try {\n      // Check if user already exists\n      const existingUser = await this.db.query<StoredUser>(\n        \"SELECT * FROM auth.users WHERE email = $1\",\n        [email],\n      );\n\n      if (existingUser.rows.length > 0) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\n            \"User already registered\",\n            400,\n            \"user_already_exists\",\n          ),\n        };\n      }\n\n      // Create user using database function\n      const userMetadata = options?.data ? JSON.stringify(options.data) : \"{}\";\n      const result = await this.db.query<StoredUser>(\n        `SELECT * FROM auth.create_user($1, $2, $3::jsonb)`,\n        [email, password, userMetadata],\n      );\n\n      if (result.rows.length === 0) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\n            \"Failed to create user\",\n            500,\n            \"user_creation_failed\",\n          ),\n        };\n      }\n\n      const storedUser = result.rows[0];\n      if (!storedUser) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\n            \"Failed to create user\",\n            500,\n            \"user_creation_failed\",\n          ),\n        };\n      }\n      const user = toPublicUser(storedUser);\n\n      // Create session\n      const session = await this.createSession(storedUser);\n\n      this.emitAuthStateChange(\"SIGNED_IN\", session);\n\n      return {\n        data: { user, session },\n        error: null,\n      };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : \"Sign up failed\";\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, \"sign_up_failed\"),\n      };\n    }\n  }\n\n  /**\n   * Sign in with email and password\n   */\n  async signInWithPassword(\n    email: string,\n    password: string,\n  ): Promise<AuthResponse> {\n    await this.initialize();\n\n    // Reset role to default before auth operation\n    await this.db.exec(\"RESET ROLE\");\n\n    try {\n      // Verify credentials using database function\n      const result = await this.db.query<StoredUser>(\n        \"SELECT * FROM auth.verify_user_credentials($1, $2)\",\n        [email, password],\n      );\n\n      const storedUser = result.rows[0];\n      if (!storedUser || !storedUser.id) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\n            \"Invalid login credentials\",\n            400,\n            \"invalid_credentials\",\n          ),\n        };\n      }\n\n      const user = toPublicUser(storedUser);\n\n      // Create session\n      const session = await this.createSession(storedUser);\n\n      this.emitAuthStateChange(\"SIGNED_IN\", session);\n\n      return {\n        data: { user, session },\n        error: null,\n      };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : \"Sign in failed\";\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, \"sign_in_failed\"),\n      };\n    }\n  }\n\n  /**\n   * Create a session for a user\n   */\n  private async createSession(storedUser: StoredUser): Promise<Session> {\n    // Create session in database\n    const sessionResult = await this.db.query<StoredSession>(\n      \"SELECT * FROM auth.create_session($1)\",\n      [storedUser.id],\n    );\n    const session = sessionResult.rows[0];\n    if (!session) {\n      throw new Error(\"Failed to create session\");\n    }\n\n    // Create refresh token in database\n    const refreshResult = await this.db.query<StoredRefreshToken>(\n      \"SELECT * FROM auth.create_refresh_token($1, $2)\",\n      [storedUser.id, session.id],\n    );\n    const refreshToken = refreshResult.rows[0];\n    if (!refreshToken) {\n      throw new Error(\"Failed to create refresh token\");\n    }\n\n    const user = toPublicUser(storedUser);\n\n    // Generate access token\n    const accessToken = await createAccessToken(\n      this.db,\n      user,\n      session.id,\n      ACCESS_TOKEN_EXPIRY,\n    );\n\n    return {\n      access_token: accessToken,\n      token_type: \"bearer\",\n      expires_in: ACCESS_TOKEN_EXPIRY,\n      expires_at: Math.floor(Date.now() / 1000) + ACCESS_TOKEN_EXPIRY,\n      refresh_token: refreshToken.token,\n      user,\n    };\n  }\n\n  /**\n   * Refresh the session using a refresh token\n   */\n  async refreshSession(refreshToken: string): Promise<AuthResponse> {\n    await this.initialize();\n\n    try {\n      // Use database function to refresh token\n      const result = await this.db.query<{\n        new_token: string;\n        user_id: string;\n        session_id: string;\n      }>(\"SELECT * FROM auth.refresh_token($1)\", [refreshToken]);\n\n      const tokenResult = result.rows[0];\n      if (!tokenResult || !tokenResult.new_token) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\n            \"Invalid refresh token\",\n            401,\n            \"invalid_refresh_token\",\n          ),\n        };\n      }\n\n      const { new_token, user_id, session_id } = tokenResult;\n\n      // Get user\n      const userResult = await this.db.query<StoredUser>(\n        \"SELECT * FROM auth.users WHERE id = $1\",\n        [user_id],\n      );\n\n      const storedUser = userResult.rows[0];\n      if (!storedUser) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\"User not found\", 404, \"user_not_found\"),\n        };\n      }\n\n      const user = toPublicUser(storedUser);\n\n      // Generate new access token\n      const accessToken = await createAccessToken(\n        this.db,\n        user,\n        session_id,\n        ACCESS_TOKEN_EXPIRY,\n      );\n\n      const session: Session = {\n        access_token: accessToken,\n        token_type: \"bearer\",\n        expires_in: ACCESS_TOKEN_EXPIRY,\n        expires_at: Math.floor(Date.now() / 1000) + ACCESS_TOKEN_EXPIRY,\n        refresh_token: new_token,\n        user,\n      };\n\n      this.emitAuthStateChange(\"TOKEN_REFRESHED\", session);\n\n      return {\n        data: { user, session },\n        error: null,\n      };\n    } catch (err) {\n      const message =\n        err instanceof Error ? err.message : \"Token refresh failed\";\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, \"refresh_failed\"),\n      };\n    }\n  }\n\n  /**\n   * Sign out the current session\n   */\n  async signOut(accessToken?: string): Promise<{ error: AuthError | null }> {\n    await this.initialize();\n\n    try {\n      if (accessToken) {\n        const sessionId = extractSessionIdFromToken(accessToken);\n        if (sessionId) {\n          await this.db.query(\"SELECT auth.sign_out($1::uuid)\", [sessionId]);\n        }\n      }\n\n      // Reset role to default after sign out\n      await this.db.exec(\"RESET ROLE\");\n\n      this.emitAuthStateChange(\"SIGNED_OUT\", null);\n      return { error: null };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : \"Sign out failed\";\n      return { error: authError(message, 500, \"sign_out_failed\") };\n    }\n  }\n\n  /**\n   * Get user from access token\n   */\n  async getUser(accessToken: string): Promise<{\n    data: { user: User | null };\n    error: AuthError | null;\n  }> {\n    await this.initialize();\n\n    try {\n      const verified = await verifyAccessToken(this.db, accessToken);\n\n      if (!verified.valid || !verified.payload) {\n        return {\n          data: { user: null },\n          error: authError(\n            verified.error || \"Invalid token\",\n            401,\n            \"invalid_token\",\n          ),\n        };\n      }\n\n      // Get fresh user data from database\n      const result = await this.db.query<StoredUser>(\n        \"SELECT * FROM auth.users WHERE id = $1\",\n        [verified.payload.sub],\n      );\n\n      const storedUser = result.rows[0];\n      if (!storedUser) {\n        return {\n          data: { user: null },\n          error: authError(\"User not found\", 404, \"user_not_found\"),\n        };\n      }\n\n      return {\n        data: { user: toPublicUser(storedUser) },\n        error: null,\n      };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : \"Get user failed\";\n      return {\n        data: { user: null },\n        error: authError(message, 500, \"get_user_failed\"),\n      };\n    }\n  }\n\n  /**\n   * Update user data\n   */\n  async updateUser(\n    accessToken: string,\n    attributes: {\n      email?: string;\n      password?: string;\n      data?: Record<string, unknown>;\n    },\n  ): Promise<AuthResponse> {\n    await this.initialize();\n\n    try {\n      const verified = await verifyAccessToken(this.db, accessToken);\n\n      if (!verified.valid || !verified.payload) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\n            verified.error || \"Invalid token\",\n            401,\n            \"invalid_token\",\n          ),\n        };\n      }\n\n      const userId = verified.payload.sub;\n      const updates: string[] = [];\n      const params: unknown[] = [];\n      let paramIndex = 1;\n\n      if (attributes.email) {\n        updates.push(`email = $${paramIndex}`);\n        params.push(attributes.email);\n        paramIndex++;\n      }\n\n      if (attributes.password) {\n        updates.push(`encrypted_password = auth.hash_password($${paramIndex})`);\n        params.push(attributes.password);\n        paramIndex++;\n      }\n\n      if (attributes.data) {\n        updates.push(\n          `raw_user_meta_data = raw_user_meta_data || $${paramIndex}::jsonb`,\n        );\n        params.push(JSON.stringify(attributes.data));\n        paramIndex++;\n      }\n\n      if (updates.length === 0) {\n        // No updates, just return current user\n        const result = await this.db.query<StoredUser>(\n          \"SELECT * FROM auth.users WHERE id = $1\",\n          [userId],\n        );\n        const storedUser = result.rows[0];\n        if (!storedUser) {\n          return {\n            data: { user: null, session: null },\n            error: authError(\"User not found\", 404, \"user_not_found\"),\n          };\n        }\n        return {\n          data: {\n            user: toPublicUser(storedUser),\n            session: this.currentSession,\n          },\n          error: null,\n        };\n      }\n\n      updates.push(\"updated_at = NOW()\");\n      params.push(userId);\n\n      const result = await this.db.query<StoredUser>(\n        `UPDATE auth.users SET ${updates.join(\", \")} WHERE id = $${paramIndex} RETURNING *`,\n        params,\n      );\n\n      const storedUser = result.rows[0];\n      if (!storedUser) {\n        return {\n          data: { user: null, session: null },\n          error: authError(\"User not found\", 404, \"user_not_found\"),\n        };\n      }\n\n      const user = toPublicUser(storedUser);\n\n      // Update session with new user data if we have a current session\n      let session = this.currentSession;\n      if (session) {\n        const newAccessToken = await createAccessToken(\n          this.db,\n          user,\n          verified.payload.session_id,\n          ACCESS_TOKEN_EXPIRY,\n        );\n        session = {\n          ...session,\n          access_token: newAccessToken,\n          user,\n        };\n      }\n\n      this.emitAuthStateChange(\"USER_UPDATED\", session);\n\n      return {\n        data: { user, session },\n        error: null,\n      };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : \"Update user failed\";\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, \"update_user_failed\"),\n      };\n    }\n  }\n\n  /**\n   * Get current session\n   */\n  getSession(): Session | null {\n    return this.currentSession;\n  }\n\n  /**\n   * Set current session (for restoring from storage)\n   */\n  setSession(session: Session | null): void {\n    this.currentSession = session;\n    if (session) {\n      this.emitAuthStateChange(\"SIGNED_IN\", session);\n    }\n  }\n\n  /**\n   * Verify access token and return payload\n   */\n  async verifyToken(accessToken: string) {\n    return verifyAccessToken(this.db, accessToken);\n  }\n}\n", "/**\n * Pluggable blob storage backends for storing file data\n *\n * Default: in-memory Map (works everywhere \u2014 web containers, browsers, Deno, Node)\n * Users can provide their own backend (e.g., IndexedDB, OPFS, filesystem)\n */\n\n/**\n * Metadata stored alongside each blob\n */\nexport interface BlobMetadata {\n  /** MIME type of the file */\n  contentType: string;\n  /** Size in bytes */\n  size: number;\n  /** Cache-Control header value */\n  cacheControl?: string;\n}\n\n/**\n * Interface for pluggable blob storage\n */\nexport interface StorageBackend {\n  /** Store a blob. Key format: \"bucketId/objectName\" */\n  put(key: string, data: Uint8Array, metadata: BlobMetadata): Promise<void>;\n\n  /** Retrieve a blob. Returns null if not found. */\n  get(key: string): Promise<{ data: Uint8Array; metadata: BlobMetadata } | null>;\n\n  /** Delete a blob. Returns true if it existed. */\n  delete(key: string): Promise<boolean>;\n\n  /** Delete all blobs with the given key prefix (e.g., \"bucketId/\") */\n  deleteByPrefix(prefix: string): Promise<number>;\n\n  /** Check if a blob exists */\n  exists(key: string): Promise<boolean>;\n\n  /** Copy a blob from one key to another */\n  copy(fromKey: string, toKey: string): Promise<boolean>;\n}\n\n/**\n * In-memory blob storage backend\n *\n * Best default for web containers and AI agent workflows:\n * - Zero dependencies, zero config\n * - Works in every JS runtime\n * - Fast (no async I/O overhead)\n * - Ephemeral (data lost on reload \u2014 fine for dev/prototyping)\n */\nexport class MemoryStorageBackend implements StorageBackend {\n  private store = new Map<\n    string,\n    { data: Uint8Array; metadata: BlobMetadata }\n  >();\n\n  async put(\n    key: string,\n    data: Uint8Array,\n    metadata: BlobMetadata,\n  ): Promise<void> {\n    this.store.set(key, { data, metadata });\n  }\n\n  async get(\n    key: string,\n  ): Promise<{ data: Uint8Array; metadata: BlobMetadata } | null> {\n    return this.store.get(key) ?? null;\n  }\n\n  async delete(key: string): Promise<boolean> {\n    return this.store.delete(key);\n  }\n\n  async deleteByPrefix(prefix: string): Promise<number> {\n    let count = 0;\n    for (const key of this.store.keys()) {\n      if (key.startsWith(prefix)) {\n        this.store.delete(key);\n        count++;\n      }\n    }\n    return count;\n  }\n\n  async exists(key: string): Promise<boolean> {\n    return this.store.has(key);\n  }\n\n  async copy(fromKey: string, toKey: string): Promise<boolean> {\n    const entry = this.store.get(fromKey);\n    if (!entry) return false;\n    // Copy the data buffer to avoid shared references\n    this.store.set(toKey, {\n      data: new Uint8Array(entry.data),\n      metadata: { ...entry.metadata },\n    });\n    return true;\n  }\n}\n", "/**\n * Storage schema SQL for PGlite\n *\n * Distilled from the official Supabase Storage tenant migrations\n * (https://github.com/supabase/storage/tree/master/migrations/tenant)\n * into a single idempotent schema that works with PGlite.\n *\n * Tables: storage.buckets, storage.objects\n * Functions: storage.foldername, storage.filename, storage.extension, storage.search\n * RLS: enabled on storage.objects (users write their own policies)\n */\n\nexport const STORAGE_SCHEMA_SQL = `\n-- Create storage schema\nCREATE SCHEMA IF NOT EXISTS storage;\n\n-- Grant permissions to roles (created by auth schema)\nGRANT USAGE ON SCHEMA storage TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON TABLES TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON FUNCTIONS TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON SEQUENCES TO anon, authenticated, service_role;\n\n-- Buckets table\nCREATE TABLE IF NOT EXISTS storage.buckets (\n  id text PRIMARY KEY,\n  name text NOT NULL,\n  owner uuid,\n  owner_id text,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now(),\n  public boolean DEFAULT false,\n  avif_autodetection boolean DEFAULT false,\n  file_size_limit bigint,\n  allowed_mime_types text[]\n);\n\nCREATE UNIQUE INDEX IF NOT EXISTS bname ON storage.buckets USING btree (name);\n\n-- Objects table\nCREATE TABLE IF NOT EXISTS storage.objects (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  bucket_id text,\n  name text,\n  owner uuid,\n  owner_id text,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now(),\n  last_accessed_at timestamptz DEFAULT now(),\n  metadata jsonb,\n  version text,\n  user_metadata jsonb,\n  CONSTRAINT objects_bucketId_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id),\n  PRIMARY KEY (id)\n);\n\nCREATE UNIQUE INDEX IF NOT EXISTS bucketid_objname ON storage.objects USING btree (bucket_id, name);\nCREATE INDEX IF NOT EXISTS name_prefix_search ON storage.objects(name text_pattern_ops);\n\n-- Enable RLS on objects (users add their own policies)\nALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;\n\n-- Enable RLS on buckets\nALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;\n\n-- Utility functions\n\nCREATE OR REPLACE FUNCTION storage.foldername(name text)\n  RETURNS text[]\n  LANGUAGE plpgsql\nAS $$\nDECLARE\n  _parts text[];\nBEGIN\n  SELECT string_to_array(name, '/') INTO _parts;\n  RETURN _parts[1:array_length(_parts, 1) - 1];\nEND\n$$;\n\nCREATE OR REPLACE FUNCTION storage.filename(name text)\n  RETURNS text\n  LANGUAGE plpgsql\nAS $$\nDECLARE\n  _parts text[];\nBEGIN\n  SELECT string_to_array(name, '/') INTO _parts;\n  RETURN _parts[array_length(_parts, 1)];\nEND\n$$;\n\nCREATE OR REPLACE FUNCTION storage.extension(name text)\n  RETURNS text\n  LANGUAGE plpgsql\nAS $$\nDECLARE\n  _parts text[];\n  _filename text;\nBEGIN\n  SELECT string_to_array(name, '/') INTO _parts;\n  SELECT _parts[array_length(_parts, 1)] INTO _filename;\n  RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$$;\n\nCREATE OR REPLACE FUNCTION storage.search(\n  prefix text,\n  bucketname text,\n  limits int DEFAULT 100,\n  levels int DEFAULT 1,\n  offsets int DEFAULT 0\n)\n  RETURNS TABLE (\n    name text,\n    id uuid,\n    updated_at timestamptz,\n    created_at timestamptz,\n    last_accessed_at timestamptz,\n    metadata jsonb\n  )\n  LANGUAGE plpgsql\nAS $$\nBEGIN\n  RETURN QUERY\n    WITH files_folders AS (\n      SELECT ((string_to_array(objects.name, '/'))[levels]) AS folder\n      FROM storage.objects\n      WHERE objects.name ILIKE prefix || '%'\n        AND bucket_id = bucketname\n      GROUP BY folder\n      LIMIT limits\n      OFFSET offsets\n    )\n    SELECT\n      files_folders.folder AS name,\n      objects.id,\n      objects.updated_at,\n      objects.created_at,\n      objects.last_accessed_at,\n      objects.metadata\n    FROM files_folders\n    LEFT JOIN storage.objects\n      ON prefix || files_folders.folder = objects.name\n      AND objects.bucket_id = bucketname;\nEND\n$$;\n\n-- Grant table permissions explicitly\nGRANT ALL ON storage.buckets TO anon, authenticated, service_role;\nGRANT ALL ON storage.objects TO anon, authenticated, service_role;\n\n-- Grant function permissions\nGRANT EXECUTE ON FUNCTION storage.foldername(text) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION storage.filename(text) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION storage.extension(text) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION storage.search(text, text, int, int, int) TO anon, authenticated, service_role;\n`;\n", "/**\n * StorageHandler \u2014 manages bucket and object operations against PGlite\n *\n * All metadata lives in storage.buckets / storage.objects (with RLS).\n * File blobs are stored in a pluggable StorageBackend (in-memory by default).\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport type { StorageBackend, BlobMetadata } from \"./backend.ts\";\nimport { MemoryStorageBackend } from \"./backend.ts\";\nimport { STORAGE_SCHEMA_SQL } from \"./schema.ts\";\n\n// \u2500\u2500\u2500 Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport interface StorageBucket {\n  id: string;\n  name: string;\n  owner: string | null;\n  owner_id: string | null;\n  created_at: string;\n  updated_at: string;\n  public: boolean;\n  avif_autodetection: boolean;\n  file_size_limit: number | null;\n  allowed_mime_types: string[] | null;\n}\n\nexport interface StorageObject {\n  id: string;\n  bucket_id: string;\n  name: string;\n  owner: string | null;\n  owner_id: string | null;\n  created_at: string;\n  updated_at: string;\n  last_accessed_at: string;\n  metadata: Record<string, unknown> | null;\n  version: string | null;\n  user_metadata: Record<string, unknown> | null;\n}\n\nexport interface CreateBucketOptions {\n  id?: string;\n  name: string;\n  public?: boolean;\n  file_size_limit?: number;\n  allowed_mime_types?: string[];\n}\n\nexport interface SignedUrlToken {\n  bucket_id: string;\n  object_name: string;\n  exp: number;\n}\n\nfunction toUrlSafeBase64(b64: string): string {\n  return b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n\nfunction fromUrlSafeBase64(b64url: string): string {\n  let s = b64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (s.length % 4) s += \"=\";\n  return s;\n}\n\n// \u2500\u2500\u2500 Handler \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport class StorageHandler {\n  private db: PGlite;\n  private backend: StorageBackend;\n  private initialized = false;\n\n  constructor(db: PGlite, backend?: StorageBackend) {\n    this.db = db;\n    this.backend = backend ?? new MemoryStorageBackend();\n  }\n\n  /** Initialize the storage schema in PGlite */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n    await this.db.exec(STORAGE_SCHEMA_SQL);\n    this.initialized = true;\n  }\n\n  /** Get the blob backend (for advanced use) */\n  getBackend(): StorageBackend {\n    return this.backend;\n  }\n\n  // \u2500\u2500 Bucket operations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n  async listBuckets(): Promise<StorageBucket[]> {\n    await this.initialize();\n    const result = await this.db.query<StorageBucket>(\n      \"SELECT * FROM storage.buckets ORDER BY name\",\n    );\n    return result.rows;\n  }\n\n  async getBucket(id: string): Promise<StorageBucket | null> {\n    await this.initialize();\n    const result = await this.db.query<StorageBucket>(\n      \"SELECT * FROM storage.buckets WHERE id = $1\",\n      [id],\n    );\n    return result.rows[0] ?? null;\n  }\n\n  async createBucket(options: CreateBucketOptions): Promise<StorageBucket> {\n    await this.initialize();\n    const id = options.id ?? options.name;\n    const result = await this.db.query<StorageBucket>(\n      `INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)\n       VALUES ($1, $2, $3, $4, $5)\n       RETURNING *`,\n      [\n        id,\n        options.name,\n        options.public ?? false,\n        options.file_size_limit ?? null,\n        options.allowed_mime_types ?? null,\n      ],\n    );\n    const bucket = result.rows[0];\n    if (!bucket) throw new Error(\"Failed to create bucket\");\n    return bucket;\n  }\n\n  async updateBucket(\n    id: string,\n    options: Partial<\n      Pick<\n        CreateBucketOptions,\n        \"public\" | \"file_size_limit\" | \"allowed_mime_types\"\n      >\n    >,\n  ): Promise<StorageBucket> {\n    await this.initialize();\n    const sets: string[] = [];\n    const params: unknown[] = [];\n    let idx = 1;\n\n    if (options.public !== undefined) {\n      sets.push(`public = $${idx++}`);\n      params.push(options.public);\n    }\n    if (options.file_size_limit !== undefined) {\n      sets.push(`file_size_limit = $${idx++}`);\n      params.push(options.file_size_limit);\n    }\n    if (options.allowed_mime_types !== undefined) {\n      sets.push(`allowed_mime_types = $${idx++}`);\n      params.push(options.allowed_mime_types);\n    }\n\n    if (sets.length === 0) {\n      const bucket = await this.getBucket(id);\n      if (!bucket) throw new Error(\"Bucket not found\");\n      return bucket;\n    }\n\n    sets.push(\"updated_at = now()\");\n    params.push(id);\n\n    const result = await this.db.query<StorageBucket>(\n      `UPDATE storage.buckets SET ${sets.join(\", \")} WHERE id = $${idx} RETURNING *`,\n      params,\n    );\n    const bucket = result.rows[0];\n    if (!bucket) throw new Error(\"Bucket not found\");\n    return bucket;\n  }\n\n  async emptyBucket(id: string): Promise<void> {\n    await this.initialize();\n    // Delete all object rows (RLS applies)\n    await this.db.query(\"DELETE FROM storage.objects WHERE bucket_id = $1\", [\n      id,\n    ]);\n    // Delete all blobs for this bucket\n    await this.backend.deleteByPrefix(`${id}/`);\n  }\n\n  async deleteBucket(id: string): Promise<void> {\n    await this.initialize();\n    // Check bucket is empty\n    const objects = await this.db.query<{ count: string }>(\n      \"SELECT count(*)::text as count FROM storage.objects WHERE bucket_id = $1\",\n      [id],\n    );\n    if (objects.rows[0] && parseInt(objects.rows[0].count, 10) > 0) {\n      throw new Error(\"Bucket not empty\");\n    }\n    await this.db.query(\"DELETE FROM storage.buckets WHERE id = $1\", [id]);\n  }\n\n  // \u2500\u2500 Object operations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n  async uploadObject(\n    bucketId: string,\n    objectName: string,\n    data: Uint8Array,\n    contentType: string,\n    options?: {\n      cacheControl?: string;\n      upsert?: boolean;\n      userMetadata?: Record<string, unknown>;\n      ownerId?: string;\n    },\n  ): Promise<StorageObject> {\n    await this.initialize();\n\n    // Validate bucket exists and check constraints\n    const bucket = await this.getBucket(bucketId);\n    if (!bucket) throw new Error(\"Bucket not found\");\n\n    // Check file size limit\n    if (bucket.file_size_limit && data.byteLength > bucket.file_size_limit) {\n      throw new Error(\n        `File size ${data.byteLength} exceeds bucket limit of ${bucket.file_size_limit}`,\n      );\n    }\n\n    // Check allowed MIME types\n    if (bucket.allowed_mime_types && bucket.allowed_mime_types.length > 0) {\n      const allowed = bucket.allowed_mime_types.some((mime) => {\n        if (mime.endsWith(\"/*\")) {\n          return contentType.startsWith(mime.slice(0, -1));\n        }\n        return contentType === mime;\n      });\n      if (!allowed) {\n        throw new Error(`MIME type ${contentType} is not allowed in this bucket`);\n      }\n    }\n\n    const metadata: Record<string, unknown> = {\n      eTag: `\"${await this.computeETag(data)}\"`,\n      size: data.byteLength,\n      mimetype: contentType,\n      cacheControl: options?.cacheControl ?? \"max-age=3600\",\n      lastModified: new Date().toISOString(),\n      contentLength: data.byteLength,\n      httpStatusCode: 200,\n    };\n\n    const upsert = options?.upsert ?? false;\n\n    let result;\n    if (upsert) {\n      result = await this.db.query<StorageObject>(\n        `INSERT INTO storage.objects (bucket_id, name, owner_id, metadata, user_metadata, version)\n         VALUES ($1, $2, $3, $4, $5, gen_random_uuid()::text)\n         ON CONFLICT (bucket_id, name)\n         DO UPDATE SET\n           metadata = $4,\n           user_metadata = $5,\n           updated_at = now(),\n           last_accessed_at = now(),\n           version = gen_random_uuid()::text,\n           owner_id = EXCLUDED.owner_id\n         RETURNING *`,\n        [\n          bucketId,\n          objectName,\n          options?.ownerId ?? null,\n          JSON.stringify(metadata),\n          options?.userMetadata ? JSON.stringify(options.userMetadata) : null,\n        ],\n      );\n    } else {\n      result = await this.db.query<StorageObject>(\n        `INSERT INTO storage.objects (bucket_id, name, owner_id, metadata, user_metadata, version)\n         VALUES ($1, $2, $3, $4, $5, gen_random_uuid()::text)\n         RETURNING *`,\n        [\n          bucketId,\n          objectName,\n          options?.ownerId ?? null,\n          JSON.stringify(metadata),\n          options?.userMetadata ? JSON.stringify(options.userMetadata) : null,\n        ],\n      );\n    }\n\n    const obj = result.rows[0];\n    if (!obj) throw new Error(\"Failed to create object\");\n\n    // Store the blob\n    const blobKey = `${bucketId}/${objectName}`;\n    await this.backend.put(blobKey, data, {\n      contentType,\n      size: data.byteLength,\n      cacheControl: options?.cacheControl,\n    });\n\n    return obj;\n  }\n\n  async downloadObject(\n    bucketId: string,\n    objectName: string,\n  ): Promise<{ data: Uint8Array; metadata: BlobMetadata; object: StorageObject } | null> {\n    await this.initialize();\n\n    // Check object exists in DB (RLS applies)\n    const result = await this.db.query<StorageObject>(\n      `UPDATE storage.objects\n       SET last_accessed_at = now()\n       WHERE bucket_id = $1 AND name = $2\n       RETURNING *`,\n      [bucketId, objectName],\n    );\n    const obj = result.rows[0];\n    if (!obj) return null;\n\n    // Get blob\n    const blobKey = `${bucketId}/${objectName}`;\n    const blob = await this.backend.get(blobKey);\n    if (!blob) return null;\n\n    return { data: blob.data, metadata: blob.metadata, object: obj };\n  }\n\n  async getObjectInfo(\n    bucketId: string,\n    objectName: string,\n  ): Promise<StorageObject | null> {\n    await this.initialize();\n    const result = await this.db.query<StorageObject>(\n      \"SELECT * FROM storage.objects WHERE bucket_id = $1 AND name = $2\",\n      [bucketId, objectName],\n    );\n    return result.rows[0] ?? null;\n  }\n\n  async objectExists(\n    bucketId: string,\n    objectName: string,\n  ): Promise<boolean> {\n    await this.initialize();\n    const result = await this.db.query<{ exists: boolean }>(\n      \"SELECT EXISTS(SELECT 1 FROM storage.objects WHERE bucket_id = $1 AND name = $2) as exists\",\n      [bucketId, objectName],\n    );\n    return result.rows[0]?.exists ?? false;\n  }\n\n  async removeObjects(\n    bucketId: string,\n    paths: string[],\n  ): Promise<StorageObject[]> {\n    await this.initialize();\n    if (paths.length === 0) return [];\n\n    // Delete from DB (RLS applies)\n    const placeholders = paths.map((_, i) => `$${i + 2}`).join(\", \");\n    const result = await this.db.query<StorageObject>(\n      `DELETE FROM storage.objects\n       WHERE bucket_id = $1 AND name IN (${placeholders})\n       RETURNING *`,\n      [bucketId, ...paths],\n    );\n\n    // Delete blobs\n    for (const obj of result.rows) {\n      await this.backend.delete(`${bucketId}/${obj.name}`);\n    }\n\n    return result.rows;\n  }\n\n  async listObjects(\n    bucketId: string,\n    options?: {\n      prefix?: string;\n      limit?: number;\n      offset?: number;\n      sortBy?: { column: string; order: string };\n      search?: string;\n    },\n  ): Promise<StorageObject[]> {\n    await this.initialize();\n\n    const prefix = options?.prefix ?? \"\";\n    const limit = options?.limit ?? 100;\n    const offset = options?.offset ?? 0;\n    const sortColumn = options?.sortBy?.column ?? \"name\";\n    const sortOrder =\n      options?.sortBy?.order?.toLowerCase() === \"desc\" ? \"DESC\" : \"ASC\";\n\n    // Allowed sort columns for safety\n    const allowedColumns = [\n      \"name\",\n      \"created_at\",\n      \"updated_at\",\n      \"last_accessed_at\",\n    ];\n    const safeColumn = allowedColumns.includes(sortColumn)\n      ? sortColumn\n      : \"name\";\n\n    // Use the search function pattern: find objects at the given prefix level\n    // The supabase-js client sends prefix as the folder path, and we need to list\n    // items one level deep within that prefix\n    const searchPattern = prefix ? `${prefix}%` : \"%\";\n\n    const result = await this.db.query<StorageObject>(\n      `SELECT * FROM storage.objects\n       WHERE bucket_id = $1 AND name LIKE $2\n       ORDER BY ${safeColumn} ${sortOrder}\n       LIMIT $3 OFFSET $4`,\n      [bucketId, searchPattern, limit, offset],\n    );\n\n    return result.rows;\n  }\n\n  async moveObject(\n    bucketId: string,\n    sourceKey: string,\n    destinationKey: string,\n    destinationBucket?: string,\n  ): Promise<void> {\n    await this.initialize();\n\n    const destBucket = destinationBucket ?? bucketId;\n\n    // Update DB row\n    const result = await this.db.query(\n      `UPDATE storage.objects\n       SET bucket_id = $3, name = $4, updated_at = now()\n       WHERE bucket_id = $1 AND name = $2`,\n      [bucketId, sourceKey, destBucket, destinationKey],\n    );\n\n    if ((result as { rowCount?: number }).rowCount === 0) {\n      throw new Error(\"Object not found\");\n    }\n\n    // Move blob\n    const fromKey = `${bucketId}/${sourceKey}`;\n    const toKey = `${destBucket}/${destinationKey}`;\n    const copied = await this.backend.copy(fromKey, toKey);\n    if (copied) {\n      await this.backend.delete(fromKey);\n    }\n  }\n\n  async copyObject(\n    bucketId: string,\n    sourceKey: string,\n    destinationKey: string,\n    destinationBucket?: string,\n  ): Promise<string> {\n    await this.initialize();\n\n    const destBucket = destinationBucket ?? bucketId;\n\n    // Get source object (RLS applies)\n    const source = await this.db.query<StorageObject>(\n      \"SELECT * FROM storage.objects WHERE bucket_id = $1 AND name = $2\",\n      [bucketId, sourceKey],\n    );\n    const srcObj = source.rows[0];\n    if (!srcObj) throw new Error(\"Object not found\");\n\n    // Insert new object row\n    const result = await this.db.query<StorageObject>(\n      `INSERT INTO storage.objects (bucket_id, name, owner_id, metadata, user_metadata, version)\n       VALUES ($1, $2, $3, $4, $5, gen_random_uuid()::text)\n       ON CONFLICT (bucket_id, name)\n       DO UPDATE SET\n         metadata = EXCLUDED.metadata,\n         user_metadata = EXCLUDED.user_metadata,\n         updated_at = now(),\n         version = gen_random_uuid()::text\n       RETURNING *`,\n      [\n        destBucket,\n        destinationKey,\n        srcObj.owner_id,\n        JSON.stringify(srcObj.metadata),\n        srcObj.user_metadata ? JSON.stringify(srcObj.user_metadata) : null,\n      ],\n    );\n    const newObj = result.rows[0];\n    if (!newObj) throw new Error(\"Failed to copy object\");\n\n    // Copy blob\n    const fromKey = `${bucketId}/${sourceKey}`;\n    const toKey = `${destBucket}/${destinationKey}`;\n    await this.backend.copy(fromKey, toKey);\n\n    return `${destBucket}/${destinationKey}`;\n  }\n\n  // \u2500\u2500 Signed URLs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n  /**\n   * Create a signed URL token.\n   * We use a simple HMAC-based approach reusing the auth signing key.\n   */\n  async createSignedUrl(\n    bucketId: string,\n    objectName: string,\n    expiresIn: number,\n  ): Promise<string> {\n    await this.initialize();\n\n    // Verify object exists\n    const exists = await this.objectExists(bucketId, objectName);\n    if (!exists) throw new Error(\"Object not found\");\n\n    const payload: SignedUrlToken = {\n      bucket_id: bucketId,\n      object_name: objectName,\n      exp: Math.floor(Date.now() / 1000) + expiresIn,\n    };\n\n    // Get signing key via SECURITY DEFINER function\n    const keyResult = await this.db.query<{ get_signing_key: string }>(\n      \"SELECT auth.get_signing_key()\",\n    );\n    const signingKey = keyResult.rows[0]?.get_signing_key ?? crypto.randomUUID();\n\n    const encoder = new TextEncoder();\n    const key = await crypto.subtle.importKey(\n      \"raw\",\n      encoder.encode(signingKey),\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\"],\n    );\n\n    const payloadStr = JSON.stringify(payload);\n    const signature = await crypto.subtle.sign(\n      \"HMAC\",\n      key,\n      encoder.encode(payloadStr),\n    );\n\n    const payloadB64 = toUrlSafeBase64(btoa(payloadStr));\n    const sigB64 = toUrlSafeBase64(btoa(\n      String.fromCharCode(...new Uint8Array(signature)),\n    ));\n\n    return `${payloadB64}.${sigB64}`;\n  }\n\n  /**\n   * Verify a signed URL token and return the payload\n   */\n  async verifySignedUrl(token: string): Promise<SignedUrlToken | null> {\n    const parts = token.split(\".\");\n    if (parts.length !== 2) return null;\n\n    const [payloadB64, sigB64] = parts;\n\n    try {\n      const payloadStr = atob(fromUrlSafeBase64(payloadB64!));\n      const payload: SignedUrlToken = JSON.parse(payloadStr);\n\n      if (payload.exp < Math.floor(Date.now() / 1000)) return null;\n\n      const keyResult = await this.db.query<{ get_signing_key: string }>(\n        \"SELECT auth.get_signing_key()\",\n      );\n      if (!keyResult.rows[0]) return null;\n\n      const encoder = new TextEncoder();\n      const key = await crypto.subtle.importKey(\n        \"raw\",\n        encoder.encode(keyResult.rows[0].get_signing_key),\n        { name: \"HMAC\", hash: \"SHA-256\" },\n        false,\n        [\"verify\"],\n      );\n\n      const sigBytes = Uint8Array.from(atob(fromUrlSafeBase64(sigB64!)), (c) => c.charCodeAt(0));\n      const valid = await crypto.subtle.verify(\n        \"HMAC\",\n        key,\n        sigBytes,\n        encoder.encode(payloadStr),\n      );\n\n      return valid ? payload : null;\n    } catch {\n      return null;\n    }\n  }\n\n  // \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n  /** Simple hash for ETags */\n  private async computeETag(data: Uint8Array): Promise<string> {\n    try {\n      const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength) as ArrayBuffer;\n      const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n      const hashArray = new Uint8Array(hashBuffer);\n      return Array.from(hashArray.slice(0, 8))\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n    } catch {\n      // Fallback for environments without crypto.subtle\n      return Math.random().toString(36).slice(2, 18);\n    }\n  }\n}\n", "/**\n * Auth routes handler - processes /auth/v1/* requests\n */\n\nimport type { AuthHandler } from \"../auth/handler.ts\";\n\n/**\n * Create a JSON response\n */\nfunction jsonResponse(data: unknown, status: number = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\n/**\n * Extract bearer token from Authorization header\n */\nfunction extractBearerToken(headers: Headers): string | null {\n  const auth = headers.get(\"Authorization\");\n  if (!auth || !auth.startsWith(\"Bearer \")) {\n    return null;\n  }\n  return auth.slice(7);\n}\n\n/**\n * Parse request body as JSON\n */\nasync function parseBody(request: Request): Promise<Record<string, unknown>> {\n  try {\n    const text = await request.text();\n    if (!text) return {};\n    return JSON.parse(text);\n  } catch {\n    return {};\n  }\n}\n\n/**\n * Handle auth routes\n */\nexport async function handleAuthRoute(\n  request: Request,\n  pathname: string,\n  authHandler: AuthHandler,\n): Promise<Response> {\n  const method = request.method.toUpperCase();\n  const url = new URL(request.url);\n  const searchParams = url.searchParams;\n\n  // POST /auth/v1/signup\n  if (method === \"POST\" && pathname === \"/auth/v1/signup\") {\n    const body = await parseBody(request);\n    const email = body.email as string;\n    const password = body.password as string;\n    const options = body.options as\n      | { data?: Record<string, unknown> }\n      | undefined;\n\n    if (!email || !password) {\n      return jsonResponse(\n        {\n          error: \"email and password are required\",\n          error_description: \"Missing credentials\",\n        },\n        400,\n      );\n    }\n\n    const result = await authHandler.signUp(email, password, options);\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status,\n      );\n    }\n\n    if (!result.data.session) {\n      return jsonResponse(\n        {\n          error: \"session_creation_failed\",\n          error_description: \"Failed to create session\",\n        },\n        500,\n      );\n    }\n\n    // Return Supabase auth format (flat structure with token fields)\n    return jsonResponse({\n      access_token: result.data.session.access_token,\n      token_type: result.data.session.token_type,\n      expires_in: result.data.session.expires_in,\n      expires_at: result.data.session.expires_at,\n      refresh_token: result.data.session.refresh_token,\n      user: result.data.user,\n    });\n  }\n\n  // POST /auth/v1/token?grant_type=password (sign in)\n  if (method === \"POST\" && pathname === \"/auth/v1/token\") {\n    const grantType = searchParams.get(\"grant_type\");\n\n    if (grantType === \"password\") {\n      const body = await parseBody(request);\n      const email = body.email as string;\n      const password = body.password as string;\n\n      if (!email || !password) {\n        return jsonResponse(\n          { error: \"invalid_grant\", error_description: \"Missing credentials\" },\n          400,\n        );\n      }\n\n      const result = await authHandler.signInWithPassword(email, password);\n\n      if (result.error) {\n        return jsonResponse(\n          { error: \"invalid_grant\", error_description: result.error.message },\n          result.error.status,\n        );\n      }\n\n      // Return Supabase token format (flat structure)\n      return jsonResponse({\n        access_token: result.data.session!.access_token,\n        token_type: result.data.session!.token_type,\n        expires_in: result.data.session!.expires_in,\n        expires_at: result.data.session!.expires_at,\n        refresh_token: result.data.session!.refresh_token,\n        user: result.data.user,\n      });\n    }\n\n    if (grantType === \"refresh_token\") {\n      const body = await parseBody(request);\n      const refreshToken = body.refresh_token as string;\n\n      if (!refreshToken) {\n        return jsonResponse(\n          {\n            error: \"invalid_grant\",\n            error_description: \"Missing refresh token\",\n          },\n          400,\n        );\n      }\n\n      const result = await authHandler.refreshSession(refreshToken);\n\n      if (result.error) {\n        return jsonResponse(\n          { error: \"invalid_grant\", error_description: result.error.message },\n          result.error.status,\n        );\n      }\n\n      // Return Supabase token format (flat structure)\n      return jsonResponse({\n        access_token: result.data.session!.access_token,\n        token_type: result.data.session!.token_type,\n        expires_in: result.data.session!.expires_in,\n        expires_at: result.data.session!.expires_at,\n        refresh_token: result.data.session!.refresh_token,\n        user: result.data.user,\n      });\n    }\n\n    return jsonResponse(\n      {\n        error: \"unsupported_grant_type\",\n        error_description: \"Grant type not supported\",\n      },\n      400,\n    );\n  }\n\n  // POST /auth/v1/logout\n  if (method === \"POST\" && pathname === \"/auth/v1/logout\") {\n    const token = extractBearerToken(request.headers);\n    const result = await authHandler.signOut(token || undefined);\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status,\n      );\n    }\n\n    return jsonResponse({});\n  }\n\n  // GET /auth/v1/user\n  if (method === \"GET\" && pathname === \"/auth/v1/user\") {\n    const token = extractBearerToken(request.headers);\n\n    if (!token) {\n      return jsonResponse(\n        {\n          error: \"unauthorized\",\n          error_description: \"Missing authorization header\",\n        },\n        401,\n      );\n    }\n\n    const result = await authHandler.getUser(token);\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status,\n      );\n    }\n\n    return jsonResponse(result.data.user);\n  }\n\n  // PUT /auth/v1/user\n  if (method === \"PUT\" && pathname === \"/auth/v1/user\") {\n    const token = extractBearerToken(request.headers);\n\n    if (!token) {\n      return jsonResponse(\n        {\n          error: \"unauthorized\",\n          error_description: \"Missing authorization header\",\n        },\n        401,\n      );\n    }\n\n    const body = await parseBody(request);\n    const result = await authHandler.updateUser(token, {\n      email: body.email as string | undefined,\n      password: body.password as string | undefined,\n      data: body.data as Record<string, unknown> | undefined,\n    });\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status,\n      );\n    }\n\n    return jsonResponse(result.data.user);\n  }\n\n  // GET /auth/v1/session (get current session)\n  if (method === \"GET\" && pathname === \"/auth/v1/session\") {\n    const token = extractBearerToken(request.headers);\n\n    if (!token) {\n      return jsonResponse({ session: null });\n    }\n\n    const userResult = await authHandler.getUser(token);\n    if (userResult.error) {\n      return jsonResponse({ session: null });\n    }\n\n    const session = authHandler.getSession();\n    return jsonResponse({ session });\n  }\n\n  // Not found\n  return jsonResponse(\n    { error: \"not_found\", error_description: \"Auth endpoint not found\" },\n    404,\n  );\n}\n", "/**\n * Auth context management for RLS policies\n * Handles setting and clearing PostgreSQL session context for authenticated requests\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport { verifyAccessToken } from \"../auth/crypto.ts\";\nimport {\n  getSetAuthContextSQL,\n  CLEAR_AUTH_CONTEXT_SQL,\n} from \"../auth/schema.ts\";\n\nexport interface AuthContext {\n  userId?: string;\n  role: string;\n  email?: string;\n}\n\n/**\n * Set auth context for authenticated request\n */\nexport async function setAuthContext(\n  db: PGlite,\n  token: string | null,\n): Promise<AuthContext> {\n  if (!token) {\n    await db.exec(CLEAR_AUTH_CONTEXT_SQL);\n    return { role: \"anon\" };\n  }\n\n  const verified = await verifyAccessToken(db, token);\n  if (!verified.valid || !verified.payload) {\n    await db.exec(CLEAR_AUTH_CONTEXT_SQL);\n    return { role: \"anon\" };\n  }\n\n  const { sub: userId, role, email } = verified.payload;\n  const sql = getSetAuthContextSQL(userId, role, email || \"\");\n  await db.exec(sql);\n\n  return { userId, role, email };\n}\n\n/**\n * Clear auth context (set to anonymous)\n */\nexport async function clearAuthContext(db: PGlite): Promise<void> {\n  await db.exec(CLEAR_AUTH_CONTEXT_SQL);\n}\n", "/**\n * Error handling utilities for API routes\n */\n\nexport interface PostgresError extends Error {\n  detail?: string;\n  hint?: string;\n  code?: string;\n}\n\nexport interface ApiError {\n  message: string;\n  code: string;\n  details?: string;\n  hint?: string;\n}\n\n/**\n * Extract PostgreSQL error details\n */\nexport function extractPostgresError(err: unknown): ApiError {\n  if (!(err instanceof Error)) {\n    return {\n      message: \"Unknown error occurred\",\n      code: \"PGRST000\",\n    };\n  }\n\n  const pgError = err as PostgresError;\n  return {\n    message: err.message,\n    code: pgError.code || \"PGRST000\",\n    details: pgError.detail,\n    hint: pgError.hint,\n  };\n}\n\n/**\n * Create JSON error response\n */\nexport function errorResponse(err: unknown, status: number = 400): Response {\n  const apiError = extractPostgresError(err);\n  return new Response(JSON.stringify(apiError), {\n    status,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n", "/**\n * Data routes handler - processes /rest/v1/* requests using PostgREST parser\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport type { PostgrestParser } from \"../postgrest-parser.ts\";\nimport { setAuthContext } from \"./auth-context.ts\";\nimport { errorResponse } from \"./error-handler.ts\";\n\n/**\n * Create a JSON response\n */\nfunction jsonResponse(\n  data: unknown,\n  status: number = 200,\n  headers: Record<string, string> = {},\n): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers,\n    },\n  });\n}\n\n/**\n * Extract bearer token from Authorization header\n */\nfunction extractBearerToken(headers: Headers): string | null {\n  const auth = headers.get(\"Authorization\");\n  if (!auth || !auth.startsWith(\"Bearer \")) {\n    return null;\n  }\n  return auth.slice(7);\n}\n\n/**\n * Parse request body as JSON\n */\nasync function parseBody(\n  request: Request,\n): Promise<Record<string, unknown> | null> {\n  try {\n    const text = await request.text();\n    if (!text) return null;\n    return JSON.parse(text);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Handle data routes (PostgREST API)\n */\nexport async function handleDataRoute(\n  request: Request,\n  pathname: string,\n  db: PGlite,\n  parser: PostgrestParser,\n): Promise<Response> {\n  const method = request.method.toUpperCase();\n  const url = new URL(request.url);\n\n  // Strip the 'columns' parameter that Supabase JS client adds\n  // The parser should derive columns from the body, not from query params\n  // Build query string manually to avoid double-encoding\n  const params = url.searchParams;\n  const filteredParams: string[] = [];\n  params.forEach((value, key) => {\n    if (key !== \"columns\") {\n      // Don't use encodeURIComponent here - the parser expects unencoded values\n      filteredParams.push(`${key}=${value}`);\n    }\n  });\n  const queryString = filteredParams.join(\"&\");\n\n  // Extract table/resource from path: /rest/v1/{table}\n  const pathParts = pathname.split(\"/\").filter(Boolean);\n  // pathParts: ['rest', 'v1', 'table'] or ['rest', 'v1', 'rpc', 'function_name']\n  if (pathParts.length < 3) {\n    return jsonResponse({ message: \"Invalid path\", code: \"PGRST000\" }, 400);\n  }\n\n  const resourcePath = pathParts.slice(2).join(\"/\"); // 'table' or 'rpc/function_name'\n  const token = extractBearerToken(request.headers);\n\n  try {\n    // Set auth context for RLS\n    await setAuthContext(db, token);\n\n    let parsed: { sql: string; params: readonly unknown[] };\n    let body: Record<string, unknown> | null = null;\n\n    // Parse body for POST/PATCH/PUT\n    if ([\"POST\", \"PATCH\", \"PUT\"].includes(method)) {\n      body = await parseBody(request);\n    }\n\n    switch (method) {\n      case \"GET\":\n        parsed = parser.parseRequest(\"GET\", resourcePath, queryString);\n        break;\n      case \"POST\":\n        parsed = parser.parseRequest(\n          \"POST\",\n          resourcePath,\n          queryString,\n          body || undefined,\n        );\n        break;\n      case \"PATCH\":\n        parsed = parser.parseRequest(\n          \"PATCH\",\n          resourcePath,\n          queryString,\n          body || undefined,\n        );\n        break;\n      case \"PUT\":\n        // PUT is typically used for upsert, treat as POST with conflict handling\n        parsed = parser.parseRequest(\n          \"POST\",\n          resourcePath,\n          queryString,\n          body || undefined,\n        );\n        break;\n      case \"DELETE\":\n        parsed = parser.parseRequest(\"DELETE\", resourcePath, queryString);\n        break;\n      default:\n        return jsonResponse(\n          { message: \"Method not allowed\", code: \"PGRST105\" },\n          405,\n        );\n    }\n\n    /**\n     * Workaround: Parser quotes asterisk in RETURNING clause\n     * The postgrest_parser incorrectly generates: RETURNING \"*\"\n     * PostgreSQL expects: RETURNING *\n     * TODO: Fix in postgrest_parser upstream\n     */\n    let sql = parsed.sql.replace(/RETURNING \"\\*\"/g, \"RETURNING *\");\n\n    // Add RETURNING clause if client wants representation and parser didn't add it\n    const prefer = request.headers.get(\"Prefer\") || \"\";\n    const returnRepresentation = prefer.includes(\"return=representation\");\n    if (\n      returnRepresentation &&\n      (method === \"POST\" || method === \"PATCH\" || method === \"DELETE\") &&\n      !sql.toUpperCase().includes(\"RETURNING\")\n    ) {\n      sql = `${sql} RETURNING *`;\n    }\n\n    // Execute the actual query with parameters\n    const result = await db.query(sql, [...parsed.params]);\n\n    // Determine response format based on headers\n    const returnMinimal = prefer.includes(\"return=minimal\");\n    const countHeader =\n      prefer.includes(\"count=exact\") ||\n      prefer.includes(\"count=planned\") ||\n      prefer.includes(\"count=estimated\");\n\n    // Build response headers\n    const responseHeaders: Record<string, string> = {};\n\n    if (countHeader) {\n      responseHeaders[\"Content-Range\"] =\n        `0-${result.rows.length - 1}/${result.rows.length}`;\n    }\n\n    // Handle different operations\n    if (method === \"GET\") {\n      return jsonResponse(result.rows, 200, responseHeaders);\n    }\n\n    if (method === \"POST\") {\n      if (returnMinimal) {\n        return new Response(null, { status: 201, headers: responseHeaders });\n      }\n      return jsonResponse(result.rows, 201, responseHeaders);\n    }\n\n    if (method === \"PATCH\" || method === \"PUT\") {\n      if (returnMinimal) {\n        return new Response(null, { status: 204, headers: responseHeaders });\n      }\n      if (returnRepresentation) {\n        return jsonResponse(result.rows, 200, responseHeaders);\n      }\n      return new Response(null, { status: 204, headers: responseHeaders });\n    }\n\n    if (method === \"DELETE\") {\n      if (returnRepresentation) {\n        return jsonResponse(result.rows, 200, responseHeaders);\n      }\n      return new Response(null, { status: 204, headers: responseHeaders });\n    }\n\n    return jsonResponse(result.rows, 200, responseHeaders);\n  } catch (err) {\n    return errorResponse(err);\n  }\n}\n", "/**\n * Storage routes handler \u2014 processes /storage/v1/* requests\n *\n * Intercepts supabase-js storage client calls and handles them locally:\n *   /storage/v1/bucket/*        \u2192 bucket CRUD\n *   /storage/v1/object/*        \u2192 object upload/download/list/move/copy/remove\n *   /storage/v1/object/sign/*   \u2192 signed URL creation & download\n *   /storage/v1/object/public/* \u2192 public file download\n *   /storage/v1/object/info/*   \u2192 object metadata\n *   /storage/v1/render/*        \u2192 image transform (returns original)\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport type { StorageHandler } from \"../storage/handler.ts\";\nimport { setAuthContext } from \"./auth-context.ts\";\n\n// \u2500\u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nfunction jsonResponse(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n}\n\nfunction errorResponse(message: string, status = 400): Response {\n  return jsonResponse(\n    { statusCode: status.toString(), error: message, message },\n    status,\n  );\n}\n\nfunction extractBearerToken(headers: Headers): string | null {\n  const auth = headers.get(\"Authorization\");\n  if (!auth || !auth.startsWith(\"Bearer \")) return null;\n  return auth.slice(7);\n}\n\nasync function parseJsonBody(\n  request: Request,\n): Promise<Record<string, unknown>> {\n  try {\n    const text = await request.text();\n    if (!text) return {};\n    return JSON.parse(text);\n  } catch {\n    return {};\n  }\n}\n\n/**\n * Read the request body as a Uint8Array (for file uploads)\n * Handles multipart/form-data and raw body\n */\nasync function readFileBody(\n  request: Request,\n): Promise<{ data: Uint8Array; contentType: string }> {\n  const requestContentType = request.headers.get(\"Content-Type\") || \"\";\n\n  if (requestContentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    // supabase-js puts the file in a field called \"\" (empty string) or the first field\n    // Try common field names\n    for (const fieldName of [\"\", \"file\", \"data\"]) {\n      const value = formData.get(fieldName);\n      if (value instanceof Blob) {\n        const arrayBuffer = await value.arrayBuffer();\n        return {\n          data: new Uint8Array(arrayBuffer),\n          contentType: value.type || \"application/octet-stream\",\n        };\n      }\n    }\n    throw new Error(\"No file found in form data\");\n  }\n\n  // Raw body\n  const arrayBuffer = await request.arrayBuffer();\n  return {\n    data: new Uint8Array(arrayBuffer),\n    contentType:\n      requestContentType || \"application/octet-stream\",\n  };\n}\n\n// \u2500\u2500\u2500 Main Router \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport async function handleStorageRoute(\n  request: Request,\n  pathname: string,\n  db: PGlite,\n  storageHandler: StorageHandler,\n): Promise<Response> {\n  const method = request.method.toUpperCase();\n  const token = extractBearerToken(request.headers);\n\n  // Set auth context variables (for RLS policies that reference auth.uid()),\n  // then RESET ROLE so storage operations run as superuser \u2014 matching real\n  // Supabase where the storage server uses supabase_storage_admin.\n  const authCtx = await setAuthContext(db, token);\n  await db.exec(\"RESET ROLE\");\n\n  try {\n    // \u2500\u2500 Bucket routes: /storage/v1/bucket \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    if (pathname === \"/storage/v1/bucket\" && method === \"GET\") {\n      return await handleListBuckets(storageHandler);\n    }\n\n    if (pathname === \"/storage/v1/bucket\" && method === \"POST\") {\n      return await handleCreateBucket(request, storageHandler);\n    }\n\n    // /storage/v1/bucket/:id/empty\n    const emptyMatch = pathname.match(\n      /^\\/storage\\/v1\\/bucket\\/([^/]+)\\/empty$/,\n    );\n    if (emptyMatch && method === \"POST\") {\n      return await handleEmptyBucket(emptyMatch[1]!, storageHandler);\n    }\n\n    // /storage/v1/bucket/:id\n    const bucketIdMatch = pathname.match(/^\\/storage\\/v1\\/bucket\\/([^/]+)$/);\n    if (bucketIdMatch) {\n      const bucketId = bucketIdMatch[1]!;\n      if (method === \"GET\")\n        return await handleGetBucket(bucketId, storageHandler);\n      if (method === \"PUT\")\n        return await handleUpdateBucket(bucketId, request, storageHandler);\n      if (method === \"DELETE\")\n        return await handleDeleteBucket(bucketId, storageHandler);\n    }\n\n    // \u2500\u2500 Object routes \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    // POST /storage/v1/object/move\n    if (pathname === \"/storage/v1/object/move\" && method === \"POST\") {\n      return await handleMoveObject(request, storageHandler);\n    }\n\n    // POST /storage/v1/object/copy\n    if (pathname === \"/storage/v1/object/copy\" && method === \"POST\") {\n      return await handleCopyObject(request, storageHandler);\n    }\n\n    // POST /storage/v1/object/sign/:bucketId/:path \u2014 create signed URL\n    const signMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/sign\\/([^/]+)\\/(.+)$/,\n    );\n    if (signMatch && method === \"POST\") {\n      return await handleCreateSignedUrl(\n        signMatch[1]!,\n        signMatch[2]!,\n        request,\n        storageHandler,\n      );\n    }\n\n    // POST /storage/v1/object/sign/:bucketId \u2014 create signed URLs (batch)\n    const signBatchMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/sign\\/([^/]+)$/,\n    );\n    if (signBatchMatch && method === \"POST\") {\n      return await handleCreateSignedUrls(\n        signBatchMatch[1]!,\n        request,\n        storageHandler,\n      );\n    }\n\n    // GET /storage/v1/object/sign/:token \u2014 download via signed URL\n    // The signed URL format from supabase-js is /storage/v1/object/sign/:bucketId/:path?token=<token>\n    const signedDownloadMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/sign\\/([^/]+)\\/(.+)$/,\n    );\n    if (signedDownloadMatch && method === \"GET\") {\n      const url = new URL(request.url);\n      const signedToken = url.searchParams.get(\"token\");\n      if (signedToken) {\n        return await handleSignedDownload(signedToken, db, storageHandler);\n      }\n    }\n\n    // GET /storage/v1/object/public/:bucketId/:path \u2014 public download\n    const publicMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/public\\/([^/]+)\\/(.+)$/,\n    );\n    if (publicMatch && method === \"GET\") {\n      return await handlePublicDownload(\n        publicMatch[1]!,\n        publicMatch[2]!,\n        db,\n        storageHandler,\n      );\n    }\n\n    // GET /storage/v1/object/info/:bucketId/:path \u2014 object info\n    const infoMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/info\\/([^/]+)\\/(.+)$/,\n    );\n    if (infoMatch && method === \"GET\") {\n      return await handleObjectInfo(\n        infoMatch[1]!,\n        infoMatch[2]!,\n        storageHandler,\n      );\n    }\n\n    // POST /storage/v1/object/list/:bucketId \u2014 list objects\n    const listMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/list\\/([^/]+)$/,\n    );\n    if (listMatch && method === \"POST\") {\n      return await handleListObjects(\n        listMatch[1]!,\n        request,\n        storageHandler,\n      );\n    }\n\n    // DELETE /storage/v1/object/:bucketId \u2014 remove objects (batch)\n    const removeMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/([^/]+)$/,\n    );\n    if (removeMatch && method === \"DELETE\") {\n      return await handleRemoveObjects(\n        removeMatch[1]!,\n        request,\n        storageHandler,\n      );\n    }\n\n    // POST /storage/v1/object/:bucketId/:path \u2014 upload\n    const uploadMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/([^/]+)\\/(.+)$/,\n    );\n    if (uploadMatch && method === \"POST\") {\n      return await handleUpload(\n        uploadMatch[1]!,\n        uploadMatch[2]!,\n        request,\n        storageHandler,\n        authCtx.userId,\n        false,\n      );\n    }\n\n    // PUT /storage/v1/object/:bucketId/:path \u2014 update (upsert)\n    if (uploadMatch && method === \"PUT\") {\n      return await handleUpload(\n        uploadMatch[1]!,\n        uploadMatch[2]!,\n        request,\n        storageHandler,\n        authCtx.userId,\n        true,\n      );\n    }\n\n    // GET /storage/v1/object/:bucketId/:path \u2014 download\n    const downloadMatch = pathname.match(\n      /^\\/storage\\/v1\\/object\\/([^/]+)\\/(.+)$/,\n    );\n    if (downloadMatch && method === \"GET\") {\n      return await handleDownload(\n        downloadMatch[1]!,\n        downloadMatch[2]!,\n        storageHandler,\n      );\n    }\n\n    // HEAD /storage/v1/object/:bucketId/:path \u2014 exists check\n    if (downloadMatch && method === \"HEAD\") {\n      return await handleExists(\n        downloadMatch[1]!,\n        downloadMatch[2]!,\n        storageHandler,\n      );\n    }\n\n    // \u2500\u2500 Render routes (stub) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    // GET /storage/v1/render/image/authenticated/:bucketId/:path\n    const renderMatch = pathname.match(\n      /^\\/storage\\/v1\\/render\\/image\\/(?:authenticated|public)\\/([^/]+)\\/(.+)$/,\n    );\n    if (renderMatch && method === \"GET\") {\n      // Return original image \u2014 no transforms in local emulation\n      return await handleDownload(\n        renderMatch[1]!,\n        renderMatch[2]!,\n        storageHandler,\n      );\n    }\n\n    return errorResponse(\"Storage endpoint not found\", 404);\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Internal error\";\n    return errorResponse(message, 500);\n  }\n}\n\n// \u2500\u2500\u2500 Bucket Handlers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nasync function handleListBuckets(\n  handler: StorageHandler,\n): Promise<Response> {\n  const buckets = await handler.listBuckets();\n  return jsonResponse(buckets);\n}\n\nasync function handleGetBucket(\n  id: string,\n  handler: StorageHandler,\n): Promise<Response> {\n  const bucket = await handler.getBucket(id);\n  if (!bucket) return errorResponse(\"Bucket not found\", 404);\n  return jsonResponse(bucket);\n}\n\nasync function handleCreateBucket(\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  const name = (body.name ?? body.id) as string;\n  if (!name) return errorResponse(\"Bucket name is required\");\n\n  try {\n    const bucket = await handler.createBucket({\n      id: (body.id as string) ?? name,\n      name,\n      public: body.public as boolean | undefined,\n      file_size_limit: body.file_size_limit as number | undefined,\n      allowed_mime_types: body.allowed_mime_types as string[] | undefined,\n    });\n    return jsonResponse({ name: bucket.name }, 200);\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Failed to create bucket\";\n    if (message.includes(\"duplicate\") || message.includes(\"unique\")) {\n      return errorResponse(\"Bucket already exists\", 409);\n    }\n    return errorResponse(message, 500);\n  }\n}\n\nasync function handleUpdateBucket(\n  id: string,\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  try {\n    await handler.updateBucket(id, {\n      public: body.public as boolean | undefined,\n      file_size_limit: body.file_size_limit as number | undefined,\n      allowed_mime_types: body.allowed_mime_types as string[] | undefined,\n    });\n    return jsonResponse({ message: \"Successfully updated\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Failed to update bucket\";\n    return errorResponse(message, 404);\n  }\n}\n\nasync function handleEmptyBucket(\n  id: string,\n  handler: StorageHandler,\n): Promise<Response> {\n  try {\n    await handler.emptyBucket(id);\n    return jsonResponse({ message: \"Successfully emptied\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Failed to empty bucket\";\n    return errorResponse(message, 500);\n  }\n}\n\nasync function handleDeleteBucket(\n  id: string,\n  handler: StorageHandler,\n): Promise<Response> {\n  try {\n    await handler.deleteBucket(id);\n    return jsonResponse({ message: \"Successfully deleted\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Failed to delete bucket\";\n    if (message.includes(\"not empty\")) {\n      return errorResponse(\"Bucket not empty\", 409);\n    }\n    return errorResponse(message, 500);\n  }\n}\n\n// \u2500\u2500\u2500 Object Handlers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nasync function handleUpload(\n  bucketId: string,\n  objectPath: string,\n  request: Request,\n  handler: StorageHandler,\n  ownerId: string | undefined,\n  upsert: boolean,\n): Promise<Response> {\n  // x-upsert header can also control upsert behavior\n  const xUpsert = request.headers.get(\"x-upsert\");\n  if (xUpsert === \"true\") upsert = true;\n\n  const cacheControl = request.headers.get(\"cache-control\") ?? undefined;\n\n  try {\n    const { data, contentType } = await readFileBody(request);\n\n    const obj = await handler.uploadObject(bucketId, objectPath, data, contentType, {\n      cacheControl,\n      upsert,\n      ownerId,\n    });\n\n    return jsonResponse({\n      Id: obj.id,\n      Key: `${bucketId}/${objectPath}`,\n    });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Upload failed\";\n    if (message.includes(\"duplicate\") || message.includes(\"unique\") || message.includes(\"already exists\")) {\n      return errorResponse(\"The resource already exists\", 409);\n    }\n    if (message.includes(\"File size\") || message.includes(\"MIME type\")) {\n      return errorResponse(message, 422);\n    }\n    return errorResponse(message, 500);\n  }\n}\n\nasync function handleDownload(\n  bucketId: string,\n  objectPath: string,\n  handler: StorageHandler,\n): Promise<Response> {\n  const result = await handler.downloadObject(bucketId, objectPath);\n  if (!result) return errorResponse(\"Object not found\", 404);\n\n  return new Response(result.data.buffer.slice(result.data.byteOffset, result.data.byteOffset + result.data.byteLength) as ArrayBuffer, {\n    status: 200,\n    headers: {\n      \"Content-Type\": result.metadata.contentType,\n      \"Content-Length\": result.metadata.size.toString(),\n      \"Cache-Control\": result.metadata.cacheControl ?? \"max-age=3600\",\n      \"ETag\":\n        (result.object.metadata as Record<string, string>)?.eTag ?? \"\",\n    },\n  });\n}\n\nasync function handleExists(\n  bucketId: string,\n  objectPath: string,\n  handler: StorageHandler,\n): Promise<Response> {\n  const exists = await handler.objectExists(bucketId, objectPath);\n  if (!exists) return new Response(null, { status: 404 });\n  return new Response(null, { status: 200 });\n}\n\nasync function handleRemoveObjects(\n  bucketId: string,\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  const prefixes = body.prefixes as string[] | undefined;\n  if (!prefixes || !Array.isArray(prefixes)) {\n    return errorResponse(\"prefixes array is required\");\n  }\n\n  const removed = await handler.removeObjects(bucketId, prefixes);\n  return jsonResponse(removed);\n}\n\nasync function handleListObjects(\n  bucketId: string,\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n\n  const objects = await handler.listObjects(bucketId, {\n    prefix: body.prefix as string | undefined,\n    limit: body.limit as number | undefined,\n    offset: body.offset as number | undefined,\n    sortBy: body.sortBy as\n      | { column: string; order: string }\n      | undefined,\n    search: body.search as string | undefined,\n  });\n\n  // Transform to match Supabase Storage API response format\n  const prefix = (body.prefix as string) ?? \"\";\n  const items = objects.map((obj) => {\n    const relativeName = obj.name.startsWith(prefix)\n      ? obj.name.slice(prefix.length)\n      : obj.name;\n\n    return {\n      name: relativeName,\n      id: obj.id,\n      updated_at: obj.updated_at,\n      created_at: obj.created_at,\n      last_accessed_at: obj.last_accessed_at,\n      metadata: obj.metadata,\n    };\n  });\n\n  return jsonResponse(items);\n}\n\nasync function handleMoveObject(\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  const bucketId = body.bucketId as string;\n  const sourceKey = body.sourceKey as string;\n  const destinationKey = body.destinationKey as string;\n  const destinationBucket = body.destinationBucket as string | undefined;\n\n  if (!bucketId || !sourceKey || !destinationKey) {\n    return errorResponse(\"bucketId, sourceKey, and destinationKey are required\");\n  }\n\n  try {\n    await handler.moveObject(\n      bucketId,\n      sourceKey,\n      destinationKey,\n      destinationBucket,\n    );\n    return jsonResponse({ message: \"Successfully moved\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Move failed\";\n    return errorResponse(message, 500);\n  }\n}\n\nasync function handleCopyObject(\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  const bucketId = body.bucketId as string;\n  const sourceKey = body.sourceKey as string;\n  const destinationKey = body.destinationKey as string;\n  const destinationBucket = body.destinationBucket as string | undefined;\n\n  if (!bucketId || !sourceKey || !destinationKey) {\n    return errorResponse(\"bucketId, sourceKey, and destinationKey are required\");\n  }\n\n  try {\n    const key = await handler.copyObject(\n      bucketId,\n      sourceKey,\n      destinationKey,\n      destinationBucket,\n    );\n    return jsonResponse({ Key: key });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Copy failed\";\n    return errorResponse(message, 500);\n  }\n}\n\nasync function handleCreateSignedUrl(\n  bucketId: string,\n  objectPath: string,\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  const expiresIn = (body.expiresIn as number) ?? 3600;\n\n  try {\n    const token = await handler.createSignedUrl(\n      bucketId,\n      objectPath,\n      expiresIn,\n    );\n    // Return the same format that supabase-js expects\n    const signedUrl = `/object/sign/${bucketId}/${objectPath}?token=${token}`;\n    return jsonResponse({ signedURL: signedUrl });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Failed to create signed URL\";\n    return errorResponse(message, 500);\n  }\n}\n\nasync function handleCreateSignedUrls(\n  bucketId: string,\n  request: Request,\n  handler: StorageHandler,\n): Promise<Response> {\n  const body = await parseJsonBody(request);\n  const expiresIn = (body.expiresIn as number) ?? 3600;\n  const paths = body.paths as string[] | undefined;\n\n  if (!paths || !Array.isArray(paths)) {\n    return errorResponse(\"paths array is required\");\n  }\n\n  const results = await Promise.all(\n    paths.map(async (path) => {\n      try {\n        const token = await handler.createSignedUrl(\n          bucketId,\n          path,\n          expiresIn,\n        );\n        const signedUrl = `/object/sign/${bucketId}/${path}?token=${token}`;\n        return { signedURL: signedUrl, path, error: null };\n      } catch (err) {\n        const message = err instanceof Error ? err.message : \"Failed\";\n        return { signedURL: null, path, error: message };\n      }\n    }),\n  );\n\n  return jsonResponse(results);\n}\n\nasync function handleSignedDownload(\n  token: string,\n  db: PGlite,\n  handler: StorageHandler,\n): Promise<Response> {\n  // For signed downloads, we need to bypass RLS (use service role)\n  await db.exec(\"RESET ROLE\");\n\n  const payload = await handler.verifySignedUrl(token);\n  if (!payload) return errorResponse(\"Invalid or expired signed URL\", 401);\n\n  const result = await handler.downloadObject(\n    payload.bucket_id,\n    payload.object_name,\n  );\n  if (!result) return errorResponse(\"Object not found\", 404);\n\n  return new Response(result.data.buffer.slice(result.data.byteOffset, result.data.byteOffset + result.data.byteLength) as ArrayBuffer, {\n    status: 200,\n    headers: {\n      \"Content-Type\": result.metadata.contentType,\n      \"Content-Length\": result.metadata.size.toString(),\n      \"Cache-Control\": result.metadata.cacheControl ?? \"max-age=3600\",\n    },\n  });\n}\n\nasync function handlePublicDownload(\n  bucketId: string,\n  objectPath: string,\n  db: PGlite,\n  handler: StorageHandler,\n): Promise<Response> {\n  // Bypass RLS for public bucket access \u2014 verify bucket is public first\n  await db.exec(\"RESET ROLE\");\n\n  const bucket = await handler.getBucket(bucketId);\n  if (!bucket) return errorResponse(\"Bucket not found\", 404);\n  if (!bucket.public) return errorResponse(\"Bucket is not public\", 400);\n\n  const result = await handler.downloadObject(bucketId, objectPath);\n  if (!result) return errorResponse(\"Object not found\", 404);\n\n  return new Response(result.data.buffer.slice(result.data.byteOffset, result.data.byteOffset + result.data.byteLength) as ArrayBuffer, {\n    status: 200,\n    headers: {\n      \"Content-Type\": result.metadata.contentType,\n      \"Content-Length\": result.metadata.size.toString(),\n      \"Cache-Control\": result.metadata.cacheControl ?? \"max-age=3600\",\n    },\n  });\n}\n\nasync function handleObjectInfo(\n  bucketId: string,\n  objectPath: string,\n  handler: StorageHandler,\n): Promise<Response> {\n  const obj = await handler.getObjectInfo(bucketId, objectPath);\n  if (!obj) return errorResponse(\"Object not found\", 404);\n\n  // Return camelized format matching supabase-js expectations\n  return jsonResponse({\n    id: obj.id,\n    name: obj.name,\n    bucketId: obj.bucket_id,\n    owner: obj.owner_id,\n    createdAt: obj.created_at,\n    updatedAt: obj.updated_at,\n    lastAccessedAt: obj.last_accessed_at,\n    metadata: obj.metadata,\n    userMetadata: obj.user_metadata,\n    version: obj.version,\n  });\n}\n", "/**\n * Scoped Fetch Adapter\n *\n * Creates a custom fetch function that intercepts Supabase API calls:\n * - /auth/v1/*     -> Local auth handler\n * - /rest/v1/*     -> Local PostgREST parser + PGlite\n * - /storage/v1/*  -> Local storage handler (blobs + metadata)\n * - Everything else -> Passthrough to original fetch\n *\n * This allows using the standard @supabase/supabase-js client with local emulation\n * while still being able to interact with other APIs and Supabase products\n * (Realtime, Edge Functions, etc.)\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport type { PostgrestParser } from \"../postgrest-parser.ts\";\nimport type { AuthHandler } from \"../auth/handler.ts\";\nimport type { StorageHandler } from \"../storage/handler.ts\";\nimport { handleAuthRoute } from \"./auth-routes.ts\";\nimport { handleDataRoute } from \"./data-routes.ts\";\nimport { handleStorageRoute } from \"./storage-routes.ts\";\n\nexport interface FetchAdapterConfig {\n  /** The PGlite database instance */\n  db: PGlite;\n  /** The PostgREST parser instance */\n  parser: PostgrestParser;\n  /** The auth handler instance */\n  authHandler: AuthHandler;\n  /** The storage handler instance (optional \u2014 enables /storage/v1/* interception) */\n  storageHandler?: StorageHandler;\n  /** The Supabase URL to intercept (used to match requests) */\n  supabaseUrl: string;\n  /**\n   * Original fetch function to use for passthrough requests\n   * Defaults to globalThis.fetch\n   */\n  originalFetch?: typeof fetch;\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean;\n}\n\n/**\n * Route information extracted from a request\n */\ninterface RouteInfo {\n  /** Whether this request should be intercepted */\n  intercept: boolean;\n  /** The route type (auth, data, storage, or passthrough) */\n  type: \"auth\" | \"data\" | \"storage\" | \"passthrough\";\n  /** The pathname for intercepted routes */\n  pathname?: string;\n}\n\n/**\n * Determine if and how a request should be routed\n */\nfunction getRouteInfo(\n  request: Request,\n  supabaseUrl: string,\n  hasStorage: boolean,\n): RouteInfo {\n  const url = new URL(request.url);\n  const supabaseHost = new URL(supabaseUrl).host;\n\n  // Only intercept requests to the configured Supabase URL\n  if (url.host !== supabaseHost) {\n    return { intercept: false, type: \"passthrough\" };\n  }\n\n  const pathname = url.pathname;\n\n  // Auth routes: /auth/v1/*\n  if (pathname.startsWith(\"/auth/v1/\")) {\n    return { intercept: true, type: \"auth\", pathname };\n  }\n\n  // Data routes: /rest/v1/*\n  if (pathname.startsWith(\"/rest/v1/\")) {\n    return { intercept: true, type: \"data\", pathname };\n  }\n\n  // Storage routes: /storage/v1/* (only if storage handler is configured)\n  if (hasStorage && pathname.startsWith(\"/storage/v1/\")) {\n    return { intercept: true, type: \"storage\", pathname };\n  }\n\n  // All other routes pass through (realtime, edge functions, etc.)\n  return { intercept: false, type: \"passthrough\" };\n}\n\n/**\n * Create a scoped fetch adapter that intercepts Supabase requests\n *\n * @example\n * ```typescript\n * import { createClient } from '@supabase/supabase-js'\n * import { createLocalFetch } from 'nano-supabase'\n *\n * const db = new PGlite()\n * const { fetch: localFetch, authHandler } = await createLocalFetch({\n *   db,\n *   parser,\n *   authHandler,\n *   supabaseUrl: 'http://localhost:54321',\n * })\n *\n * const supabase = createClient('http://localhost:54321', 'your-anon-key', {\n *   global: { fetch: localFetch }\n * })\n *\n * // Now auth, data, and storage calls are handled locally\n * await supabase.auth.signUp({ email: 'user@example.com', password: 'password' })\n * await supabase.from('users').select('*')\n * await supabase.storage.from('avatars').upload('avatar.png', file)\n *\n * // Other calls (realtime, edge functions) pass through to the network\n * ```\n */\nexport function createLocalFetch(config: FetchAdapterConfig): typeof fetch {\n  const {\n    db,\n    parser,\n    authHandler,\n    storageHandler,\n    supabaseUrl,\n    originalFetch = globalThis.fetch.bind(globalThis),\n    debug = false,\n  } = config;\n\n  const log = debug\n    ? (...args: unknown[]) => console.log(\"[nano-supabase]\", ...args)\n    : () => {};\n\n  return async function localFetch(\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> {\n    // Normalize input to Request object\n    const request = input instanceof Request ? input : new Request(input, init);\n\n    const routeInfo = getRouteInfo(request, supabaseUrl, !!storageHandler);\n\n    if (!routeInfo.intercept) {\n      log(\"Passthrough:\", request.method, request.url);\n      // Pass through to original fetch\n      return originalFetch(input, init);\n    }\n\n    // Log all headers for debugging\n    const authHeader = request.headers.get(\"Authorization\");\n    console.log(\"[FETCH_ADAPTER] Intercepting:\", {\n      type: routeInfo.type,\n      method: request.method,\n      pathname: routeInfo.pathname,\n      hasAuth: !!authHeader,\n      authPreview: authHeader ? `${authHeader.slice(0, 30)}...` : \"none\",\n    });\n    log(\"Intercepting:\", routeInfo.type, request.method, routeInfo.pathname);\n    log(\n      \"Authorization header:\",\n      authHeader ? `${authHeader.slice(0, 20)}...` : \"none\",\n    );\n\n    try {\n      let response: Response;\n\n      if (routeInfo.type === \"auth\" && routeInfo.pathname) {\n        response = await handleAuthRoute(\n          request,\n          routeInfo.pathname,\n          authHandler,\n        );\n      } else if (routeInfo.type === \"data\" && routeInfo.pathname) {\n        response = await handleDataRoute(\n          request,\n          routeInfo.pathname,\n          db,\n          parser,\n        );\n      } else if (\n        routeInfo.type === \"storage\" &&\n        routeInfo.pathname &&\n        storageHandler\n      ) {\n        response = await handleStorageRoute(\n          request,\n          routeInfo.pathname,\n          db,\n          storageHandler,\n        );\n      } else {\n        // Should not reach here, but pass through just in case\n        return originalFetch(input, init);\n      }\n\n      // Log response status\n      log(\"Response status:\", response.status);\n\n      return response;\n    } catch (err) {\n      log(\"Error handling request:\", err);\n\n      // Return error response\n      const message = err instanceof Error ? err.message : \"Internal error\";\n      return new Response(\n        JSON.stringify({ error: \"internal_error\", error_description: message }),\n        {\n          status: 500,\n          headers: { \"Content-Type\": \"application/json\" },\n        },\n      );\n    }\n  };\n}\n\nexport { handleAuthRoute } from \"./auth-routes.ts\";\nexport { handleDataRoute } from \"./data-routes.ts\";\nexport { handleStorageRoute } from \"./storage-routes.ts\";\n", "/**\n * Local Supabase Client Factory\n *\n * Creates a fully local Supabase client that works with @supabase/supabase-js\n * All auth, data, and storage operations are handled in-browser/in-process using PGlite\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport { PostgrestParser } from \"./postgrest-parser.ts\";\nimport { AuthHandler } from \"./auth/handler.ts\";\nimport { StorageHandler } from \"./storage/handler.ts\";\nimport type { StorageBackend } from \"./storage/backend.ts\";\nimport { createLocalFetch } from \"./fetch-adapter/index.ts\";\n\n/**\n * Generic type for the Supabase client\n * This allows users to pass their own SupabaseClient type\n */\ntype SupabaseJsClient = unknown;\n\n/**\n * Configuration for creating a local Supabase client\n */\nexport interface LocalSupabaseClientConfig {\n  /**\n   * The PGlite database instance\n   */\n  db: PGlite;\n  /**\n   * URL to use for the local Supabase instance\n   * This should be a fake URL that won't conflict with real requests\n   * Defaults to 'http://localhost:54321'\n   */\n  supabaseUrl?: string;\n  /**\n   * Anon key to use (can be any string for local usage)\n   * Defaults to 'local-anon-key'\n   */\n  supabaseAnonKey?: string;\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean;\n  /**\n   * Original fetch function to use for passthrough requests\n   * Defaults to globalThis.fetch\n   */\n  originalFetch?: typeof fetch;\n  /**\n   * Custom storage blob backend.\n   * Defaults to in-memory storage (MemoryStorageBackend).\n   * Set to `false` to disable storage emulation entirely.\n   */\n  storageBackend?: StorageBackend | false;\n}\n\n/**\n * Result from creating a local Supabase client\n */\nexport interface LocalSupabaseClientResult<T = SupabaseJsClient> {\n  /**\n   * The Supabase client configured to use local emulation\n   */\n  client: T;\n  /**\n   * The auth handler for direct access to auth operations\n   */\n  authHandler: AuthHandler;\n  /**\n   * The PostgREST parser for direct SQL parsing\n   */\n  parser: PostgrestParser;\n  /**\n   * The storage handler for direct access to storage operations (undefined if disabled)\n   */\n  storageHandler?: StorageHandler;\n  /**\n   * The custom fetch function (useful for custom integrations)\n   */\n  localFetch: typeof fetch;\n}\n\n/**\n * Create a local Supabase client with full auth, data, and storage emulation\n *\n * This function initializes PGlite with the auth and storage schemas and creates a\n * custom fetch adapter that intercepts Supabase API calls:\n * - /auth/v1/* endpoints are handled by the local auth handler\n * - /rest/v1/* endpoints are parsed and executed against PGlite\n * - /storage/v1/* endpoints are handled by the local storage handler\n * - All other requests pass through to the original fetch\n *\n * @example\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite'\n * import { createClient } from '@supabase/supabase-js'\n * import { createLocalSupabaseClient } from 'nano-supabase'\n *\n * const db = new PGlite()\n *\n * // Create the local client \u2014 auth, data, and storage all work locally\n * const { client: supabase } = await createLocalSupabaseClient({\n *   db,\n *   createClient,\n * })\n *\n * // Use it like a normal Supabase client\n * await supabase.auth.signUp({ email: 'user@example.com', password: 'password' })\n * const { data } = await supabase.from('users').select('*')\n * await supabase.storage.from('avatars').upload('avatar.png', file)\n * ```\n */\nexport async function createLocalSupabaseClient<T = SupabaseJsClient>(\n  config: LocalSupabaseClientConfig,\n  createClient: (\n    url: string,\n    key: string,\n    options?: { global?: { fetch?: typeof fetch } },\n  ) => T,\n): Promise<LocalSupabaseClientResult<T>> {\n  const {\n    db,\n    supabaseUrl = \"http://localhost:54321\",\n    supabaseAnonKey = \"local-anon-key\",\n    debug = false,\n    originalFetch,\n    storageBackend,\n  } = config;\n\n  // Initialize PostgREST parser\n  await PostgrestParser.init();\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql);\n    return { rows: result.rows };\n  });\n\n  const parser = new PostgrestParser();\n\n  // Initialize auth handler (creates auth schema)\n  const authHandler = new AuthHandler(db);\n  await authHandler.initialize();\n\n  // Initialize storage handler (creates storage schema) unless disabled\n  let storageHandler: StorageHandler | undefined;\n  if (storageBackend !== false) {\n    storageHandler = new StorageHandler(\n      db,\n      storageBackend || undefined,\n    );\n    await storageHandler.initialize();\n  }\n\n  // Create the scoped fetch adapter\n  const localFetch = createLocalFetch({\n    db,\n    parser,\n    authHandler,\n    storageHandler,\n    supabaseUrl,\n    originalFetch,\n    debug,\n  });\n\n  // Create the Supabase client with our custom fetch\n  const client = createClient(supabaseUrl, supabaseAnonKey, {\n    global: { fetch: localFetch },\n  });\n\n  return {\n    client,\n    authHandler,\n    parser,\n    storageHandler,\n    localFetch,\n  };\n}\n\n/**\n * Initialize auth schema in an existing PGlite database\n *\n * Use this if you want to set up auth without creating a full Supabase client\n *\n * @example\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite'\n * import { initializeAuth } from 'nano-supabase'\n *\n * const db = new PGlite()\n * const authHandler = await initializeAuth(db)\n *\n * // Use auth directly\n * const result = await authHandler.signUp('user@example.com', 'password')\n * ```\n */\nexport async function initializeAuth(db: PGlite): Promise<AuthHandler> {\n  const authHandler = new AuthHandler(db);\n  await authHandler.initialize();\n  return authHandler;\n}\n\n/**\n * Create only the fetch adapter without a Supabase client\n *\n * Use this for custom integrations where you want to control client creation\n *\n * @example\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite'\n * import { createClient } from '@supabase/supabase-js'\n * import { createFetchAdapter } from 'nano-supabase'\n *\n * const db = new PGlite()\n * const { localFetch, authHandler, parser, storageHandler } = await createFetchAdapter({ db })\n *\n * // Create client yourself\n * const supabase = createClient('http://localhost:54321', 'key', {\n *   global: { fetch: localFetch }\n * })\n * ```\n */\nexport async function createFetchAdapter(config: {\n  db: PGlite;\n  supabaseUrl?: string;\n  debug?: boolean;\n  originalFetch?: typeof fetch;\n  storageBackend?: StorageBackend | false;\n}): Promise<{\n  localFetch: typeof fetch;\n  authHandler: AuthHandler;\n  parser: PostgrestParser;\n  storageHandler?: StorageHandler;\n}> {\n  const {\n    db,\n    supabaseUrl = \"http://localhost:54321\",\n    debug = false,\n    originalFetch,\n    storageBackend,\n  } = config;\n\n  // Initialize PostgREST parser\n  await PostgrestParser.init();\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql);\n    return { rows: result.rows };\n  });\n\n  const parser = new PostgrestParser();\n\n  // Initialize auth handler\n  const authHandler = new AuthHandler(db);\n  await authHandler.initialize();\n\n  // Initialize storage handler unless disabled\n  let storageHandler: StorageHandler | undefined;\n  if (storageBackend !== false) {\n    storageHandler = new StorageHandler(\n      db,\n      storageBackend || undefined,\n    );\n    await storageHandler.initialize();\n  }\n\n  // Create the scoped fetch adapter\n  const localFetch = createLocalFetch({\n    db,\n    parser,\n    authHandler,\n    storageHandler,\n    supabaseUrl,\n    originalFetch,\n    debug,\n  });\n\n  return {\n    localFetch,\n    authHandler,\n    parser,\n    storageHandler,\n  };\n}\n", "/**\n * Supabase-compatible client for PGlite\n * Intercepts PostgREST-style API calls and converts them to SQL\n */\n\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport { PostgrestParser } from \"./postgrest-parser.ts\";\n\n/**\n * Query builder interface compatible with Supabase-js\n */\nexport interface QueryBuilder<T = unknown> {\n  select(columns?: string): QueryBuilder<T>;\n  insert(\n    data: Record<string, unknown> | Record<string, unknown>[],\n  ): QueryBuilder<T>;\n  update(data: Record<string, unknown>): QueryBuilder<T>;\n  delete(): QueryBuilder<T>;\n  eq(column: string, value: unknown): QueryBuilder<T>;\n  neq(column: string, value: unknown): QueryBuilder<T>;\n  gt(column: string, value: unknown): QueryBuilder<T>;\n  gte(column: string, value: unknown): QueryBuilder<T>;\n  lt(column: string, value: unknown): QueryBuilder<T>;\n  lte(column: string, value: unknown): QueryBuilder<T>;\n  like(column: string, pattern: string): QueryBuilder<T>;\n  ilike(column: string, pattern: string): QueryBuilder<T>;\n  in(column: string, values: unknown[]): QueryBuilder<T>;\n  is(column: string, value: null | boolean): QueryBuilder<T>;\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean },\n  ): QueryBuilder<T>;\n  limit(count: number): QueryBuilder<T>;\n  range(from: number, to: number): QueryBuilder<T>;\n  single(): QueryBuilder<T>;\n  maybeSingle(): QueryBuilder<T>;\n  then<TResult>(\n    onfulfilled?:\n      | ((value: { data: T | null; error: Error | null }) => TResult)\n      | null,\n  ): Promise<TResult>;\n}\n\n/**\n * Supabase-compatible database client\n */\nexport class SupabaseClient {\n  private readonly db: PGlite;\n  private readonly parser: PostgrestParser;\n\n  constructor(db: PGlite, parser: PostgrestParser) {\n    this.db = db;\n    this.parser = parser;\n  }\n\n  /**\n   * Access a table for querying\n   */\n  from<T = unknown>(table: string): QueryBuilder<T> {\n    return new PostgrestQueryBuilder<T>(this.db, this.parser, table);\n  }\n\n  /**\n   * Call a stored procedure\n   */\n  async rpc<T = unknown>(\n    functionName: string,\n    params?: Record<string, unknown>,\n  ): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const parsed = this.parser.parseRpc(functionName, params);\n      const result = await this.db.query(parsed.sql, [...parsed.params]);\n      return { data: result.rows as T, error: null };\n    } catch (error) {\n      return { data: null, error: error as Error };\n    }\n  }\n}\n\n/**\n * Query builder implementation\n */\nclass PostgrestQueryBuilder<T> implements QueryBuilder<T> {\n  private readonly db: PGlite;\n  private readonly parser: PostgrestParser;\n  private readonly table: string;\n  private selectColumns?: string;\n  private filters: string[] = [];\n  private orderBy?: string;\n  private limitCount?: number;\n  private offsetCount?: number;\n  private insertData?: Record<string, unknown> | Record<string, unknown>[];\n  private updateData?: Record<string, unknown>;\n  private isDelete = false;\n  private expectSingle = false;\n  private expectMaybeSingle = false;\n\n  constructor(db: PGlite, parser: PostgrestParser, table: string) {\n    this.db = db;\n    this.parser = parser;\n    this.table = table;\n  }\n\n  select(columns = \"*\"): QueryBuilder<T> {\n    this.selectColumns = columns;\n    return this;\n  }\n\n  insert(\n    data: Record<string, unknown> | Record<string, unknown>[],\n  ): QueryBuilder<T> {\n    this.insertData = data;\n    return this;\n  }\n\n  update(data: Record<string, unknown>): QueryBuilder<T> {\n    this.updateData = data;\n    return this;\n  }\n\n  delete(): QueryBuilder<T> {\n    this.isDelete = true;\n    return this;\n  }\n\n  eq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=eq.${String(value)}`);\n    return this;\n  }\n\n  neq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=neq.${String(value)}`);\n    return this;\n  }\n\n  gt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gt.${String(value)}`);\n    return this;\n  }\n\n  gte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gte.${String(value)}`);\n    return this;\n  }\n\n  lt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lt.${String(value)}`);\n    return this;\n  }\n\n  lte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lte.${String(value)}`);\n    return this;\n  }\n\n  like(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=like.${pattern}`);\n    return this;\n  }\n\n  ilike(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=ilike.${pattern}`);\n    return this;\n  }\n\n  in(column: string, values: unknown[]): QueryBuilder<T> {\n    const joined = values.map(String).join(\",\");\n    this.filters.push(`${column}=in.(${joined})`);\n    return this;\n  }\n\n  is(column: string, value: null | boolean): QueryBuilder<T> {\n    const val = value === null ? \"null\" : value ? \"true\" : \"false\";\n    this.filters.push(`${column}=is.${val}`);\n    return this;\n  }\n\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean },\n  ): QueryBuilder<T> {\n    const direction = options?.ascending === false ? \"desc\" : \"asc\";\n    const nulls = options?.nullsFirst ? \"nullsfirst\" : \"nullslast\";\n    this.orderBy = `${column}.${direction}.${nulls}`;\n    return this;\n  }\n\n  limit(count: number): QueryBuilder<T> {\n    this.limitCount = count;\n    return this;\n  }\n\n  range(from: number, to: number): QueryBuilder<T> {\n    this.offsetCount = from;\n    this.limitCount = to - from + 1;\n    return this;\n  }\n\n  single(): QueryBuilder<T> {\n    this.expectSingle = true;\n    this.limitCount = 1;\n    return this;\n  }\n\n  maybeSingle(): QueryBuilder<T> {\n    this.expectMaybeSingle = true;\n    this.limitCount = 1;\n    return this;\n  }\n\n  async then<TResult>(\n    onfulfilled?:\n      | ((value: { data: T | null; error: Error | null }) => TResult)\n      | null,\n  ): Promise<TResult> {\n    const result = await this.execute();\n    return onfulfilled ? onfulfilled(result) : (result as unknown as TResult);\n  }\n\n  private async execute(): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const queryString = this.buildQueryString();\n\n      let parsed;\n      if (this.insertData !== undefined) {\n        const data: Record<string, unknown> = Array.isArray(this.insertData)\n          ? (this.insertData[0] ?? {})\n          : this.insertData;\n        parsed = this.parser.parseInsert(this.table, data, queryString);\n      } else if (this.updateData !== undefined) {\n        parsed = this.parser.parseUpdate(\n          this.table,\n          this.updateData,\n          queryString,\n        );\n      } else if (this.isDelete) {\n        parsed = this.parser.parseDelete(this.table, queryString);\n      } else {\n        parsed = this.parser.parseSelect(this.table, queryString);\n      }\n\n      const result = await this.db.query(parsed.sql, [...parsed.params]);\n\n      if (this.expectSingle && result.rows.length === 0) {\n        throw new Error(\"No rows returned\");\n      }\n\n      if (this.expectSingle && result.rows.length > 1) {\n        throw new Error(\"Multiple rows returned\");\n      }\n\n      const data =\n        this.expectSingle || this.expectMaybeSingle\n          ? ((result.rows[0] as T) ?? null)\n          : (result.rows as T);\n\n      return { data, error: null };\n    } catch (error) {\n      return { data: null, error: error as Error };\n    }\n  }\n\n  private buildQueryString(): string {\n    const parts: string[] = [];\n\n    if (this.selectColumns) {\n      parts.push(`select=${this.selectColumns}`);\n    }\n\n    parts.push(...this.filters);\n\n    if (this.orderBy) {\n      parts.push(`order=${this.orderBy}`);\n    }\n\n    if (this.limitCount !== undefined) {\n      parts.push(`limit=${this.limitCount}`);\n    }\n\n    if (this.offsetCount !== undefined) {\n      parts.push(`offset=${this.offsetCount}`);\n    }\n\n    return parts.join(\"&\");\n  }\n}\n\n/**\n * Create a Supabase-compatible client with schema introspection\n */\nexport async function createSupabaseClient(\n  db: PGlite,\n): Promise<SupabaseClient> {\n  await PostgrestParser.init();\n\n  // Initialize schema introspection from the database\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql);\n    return { rows: result.rows };\n  });\n\n  const parser = new PostgrestParser();\n  return new SupabaseClient(db, parser);\n}\n", "import type { QueuedQuery, QueryPriority } from \"./types.ts\";\n\n/**\n * Priority-based queue for managing query execution order\n * Uses separate queues for each priority level\n */\nexport class PriorityQueue {\n  private readonly queues: Map<QueryPriority, QueuedQuery[]>;\n  private readonly maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n    this.queues = new Map([\n      [0, []], // QueryPriority.CRITICAL\n      [1, []], // QueryPriority.HIGH\n      [2, []], // QueryPriority.MEDIUM\n      [3, []], // QueryPriority.LOW\n    ]);\n  }\n\n  /**\n   * Add a query to the appropriate priority queue\n   * @throws {Error} if queue is full\n   */\n  enqueue(query: QueuedQuery): void {\n    const queue = this.queues.get(query.priority);\n    if (!queue) {\n      throw new Error(`Invalid priority: ${query.priority}`);\n    }\n\n    if (this.size() >= this.maxSize) {\n      throw new Error(\"Queue is full\");\n    }\n\n    queue.push(query);\n  }\n\n  /**\n   * Remove and return the highest priority query\n   * Returns null if queue is empty\n   */\n  dequeue(): QueuedQuery | null {\n    // Check queues in priority order (CRITICAL = 0 to LOW = 3)\n    for (const priority of [0, 1, 2, 3] as const) {\n      const queue = this.queues.get(priority);\n      if (queue && queue.length > 0) {\n        return queue.shift() ?? null;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get total number of queued queries across all priorities\n   */\n  size(): number {\n    return Array.from(this.queues.values()).reduce(\n      (sum, q) => sum + q.length,\n      0,\n    );\n  }\n\n  /**\n   * Check if queue is empty\n   */\n  isEmpty(): boolean {\n    return this.size() === 0;\n  }\n\n  /**\n   * Clear all queued queries\n   */\n  clear(): void {\n    for (const queue of this.queues.values()) {\n      queue.length = 0;\n    }\n  }\n}\n", "import type { PGlite } from \"@electric-sql/pglite\";\n\nimport { PriorityQueue } from \"./queue.ts\";\nimport type {\n  PoolerConfig,\n  QueuedQuery,\n  QueryPriority,\n  QueryResult,\n} from \"./types.ts\";\n\n/**\n * Connection pooler that manages N-to-1 query execution against PGlite\n * Uses a priority queue to order query execution\n */\nexport class PGlitePooler {\n  private readonly db: PGlite;\n  private readonly queue: PriorityQueue;\n  private running: boolean = false;\n  private readonly config: PoolerConfig;\n  private sleepTimeoutId: number | null = null;\n\n  constructor(db: PGlite, config: Partial<PoolerConfig> = {}) {\n    this.db = db;\n    this.queue = new PriorityQueue(config.maxQueueSize ?? 1000);\n    this.config = {\n      maxQueueSize: config.maxQueueSize ?? 1000,\n      defaultTimeout: config.defaultTimeout ?? 5000,\n    };\n  }\n\n  /**\n   * Start the queue processor\n   * Begins draining queries from the queue\n   */\n  async start(): Promise<void> {\n    if (this.running) {\n      throw new Error(\"Pooler already started\");\n    }\n    this.running = true;\n\n    // Start processing in background\n    // Use setTimeout(0) for cross-runtime compatibility (works in Node.js, Deno, Browser)\n    setTimeout(() => {\n      this.processQueue().catch((err) => {\n        console.error(\"Queue processor error:\", err);\n        this.running = false;\n      });\n    }, 0);\n\n    // Give the processor a chance to start\n    await new Promise((resolve) => setTimeout(resolve, 0));\n  }\n\n  /**\n   * Stop the queue processor\n   * Waits for current query to complete\n   */\n  async stop(): Promise<void> {\n    this.running = false;\n\n    // Cancel any pending sleep timer\n    if (this.sleepTimeoutId !== null) {\n      clearTimeout(this.sleepTimeoutId as unknown as number);\n      this.sleepTimeoutId = null;\n    }\n\n    // Give time for the background loop to exit\n    await new Promise((r) => setTimeout(r, 20));\n  }\n\n  /**\n   * Submit a query to the pool\n   * Returns a promise that resolves when the query completes\n   */\n  async query(\n    sql: string,\n    params?: readonly unknown[],\n    priority: QueryPriority = 2, // MEDIUM\n  ): Promise<QueryResult> {\n    return new Promise((resolve, reject) => {\n      const query: QueuedQuery = {\n        id: crypto.randomUUID(),\n        sql,\n        params: params ?? [],\n        priority,\n        enqueuedAt: Date.now(),\n        resolve,\n        reject,\n        timeoutMs: this.config.defaultTimeout,\n      };\n\n      try {\n        this.queue.enqueue(query);\n      } catch (error) {\n        reject(error instanceof Error ? error : new Error(String(error)));\n      }\n    });\n  }\n\n  /**\n   * Background queue processor\n   * Continuously dequeues and executes queries\n   */\n  private async processQueue(): Promise<void> {\n    while (this.running) {\n      const query = this.queue.dequeue();\n\n      if (!query) {\n        // No queries, sleep briefly then check if still running\n        await new Promise((r) => {\n          const id = setTimeout(() => {\n            r(null);\n          }, 10);\n          // Store timeout ID so we can cancel it in stop()\n          this.sleepTimeoutId = id as unknown as number;\n        });\n        this.sleepTimeoutId = null;\n        continue;\n      }\n\n      // Execute query with timeout\n      try {\n        const result = await this.executeWithTimeout(query);\n        query.resolve(result);\n      } catch (error) {\n        query.reject(error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n  }\n\n  /**\n   * Execute a query with timeout protection\n   * Note: PGlite.query() already handles exclusive access internally via mutex\n   */\n  private async executeWithTimeout(query: QueuedQuery): Promise<QueryResult> {\n    const timeoutMs = query.timeoutMs ?? this.config.defaultTimeout;\n\n    let timeoutId: number | null = null;\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error(\"Query timeout\"));\n      }, timeoutMs) as unknown as number;\n    });\n\n    // PGlite.query() already uses a mutex internally, no need for runExclusive\n    const queryPromise = this.db\n      .query(query.sql, query.params as unknown[])\n      .finally(() => {\n        // Cancel timeout if query completes\n        if (timeoutId) clearTimeout(timeoutId as unknown as number);\n      });\n\n    return Promise.race([queryPromise, timeoutPromise]) as Promise<QueryResult>;\n  }\n}\n", "/**\n * Priority levels for query execution\n * Lower number = higher priority\n */\nexport enum QueryPriority {\n  CRITICAL = 0,\n  HIGH = 1,\n  MEDIUM = 2,\n  LOW = 3,\n}\n\n/**\n * Result from PGlite query execution\n */\nexport interface QueryResult {\n  readonly rows: readonly Record<string, unknown>[];\n  readonly fields?: readonly { name: string; dataTypeID: number }[];\n  readonly affectedRows?: number;\n}\n\n/**\n * Query queued for execution\n */\nexport interface QueuedQuery {\n  readonly id: string;\n  readonly sql: string;\n  readonly params?: readonly unknown[];\n  priority: QueryPriority; // Mutable for aging mechanism\n  readonly enqueuedAt: number;\n  readonly resolve: (result: QueryResult) => void;\n  readonly reject: (error: Error) => void;\n  readonly timeoutMs?: number;\n}\n\n/**\n * Configuration for the connection pooler\n */\nexport interface PoolerConfig {\n  readonly maxQueueSize: number;\n  readonly defaultTimeout: number;\n}\n\n/**\n * Queue metrics for monitoring\n */\nexport interface QueueMetrics {\n  readonly totalEnqueued: number;\n  readonly totalDequeued: number;\n  readonly currentSize: number;\n  readonly avgWaitTimeMs: number;\n  readonly sizeByPriority: Readonly<Record<QueryPriority, number>>;\n}\n"],
  "mappings": "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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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",
  "names": ["WasmQueryResult", "_WasmQueryResult", "ptr", "obj", "WasmQueryResultFinalization", "wasm", "ret", "takeObject", "deferred1_0", "deferred1_1", "retptr", "r0", "getDataViewMemory0", "r1", "getStringFromWasm0", "buildFilterClause", "filters_json", "addHeapObject", "r2", "initSchemaFromDb", "query_executor", "parseDelete", "table", "query_string", "headers", "retptr", "wasm", "ptr0", "passStringToWasm0", "len0", "WASM_VECTOR_LEN", "ptr1", "len1", "ptr2", "isLikeNone", "len2", "r0", "getDataViewMemory0", "r1", "r2", "takeObject", "WasmQueryResult", "parseInsert", "body", "ptr3", "len3", "parseOnly", "parseRequest", "method", "path", "query_string", "body", "headers", "retptr", "wasm", "ptr0", "passStringToWasm0", "len0", "WASM_VECTOR_LEN", "ptr1", "len1", "ptr2", "len2", "ptr3", "isLikeNone", "len3", "ptr4", "len4", "r0", "getDataViewMemory0", "r1", "r2", "takeObject", "WasmQueryResult", "parseRpc", "function_name", "parseUpdate", "table", "__wbg_get_imports", "arg0", "arg1", "ret", "getStringFromWasm0", "addHeapObject", "getObject", "v", "debugString", "val", "obj", "handleError", "arg2", "deferred0_0", "deferred0_1", "result", "state0", "cb0", "a", "__wasm_bindgen_func_elem_443", "getArrayU8FromWasm0", "makeMutClosure", "__wasm_bindgen_func_elem_364", "arg3", "WasmQueryResultFinalization", "ptr", "heap_next", "heap", "idx", "CLOSURE_DTORS", "state", "type", "description", "name", "length", "debug", "i", "builtInMatches", "className", "dropObject", "len", "getUint8ArrayMemory0", "cachedDataViewMemory0", "decodeText", "cachedUint8ArrayMemory0", "f", "args", "e", "x", "dtor", "real", "arg", "malloc", "realloc", "buf", "cachedTextEncoder", "mem", "offset", "code", "view", "cachedTextDecoder", "MAX_SAFARI_DECODE_BYTES", "numBytesDecoded", "wasmModule", "__wbg_finalize_init", "instance", "module", "__wbg_load", "imports", "expectedResponseType", "bytes", "__wbg_init", "module_or_path", "wasm", "imports", "__wbg_get_imports", "instance", "module", "__wbg_load", "__wbg_finalize_init", "toQueryResult", "wasmResult", "headersToJson", "headers", "preferToHeader", "prefer", "parts", "buildQueryString", "filters", "options", "key", "value", "select", "order", "onConflict", "returning", "PostgRESTParser", "method", "path", "queryString", "body", "bodyJson", "headersJson", "result", "parseRequest", "table", "data", "preferHeader", "parseInsert", "conflictColumns", "col", "parseUpdate", "parseDelete", "functionName", "args", "parseRpc", "parseOnly", "buildFilterClause", "createClient", "PostgrestParser", "_PostgrestParser", "createClient", "__wbg_init", "queryExecutor", "initSchemaFromDb", "table", "queryString", "data", "functionName", "args", "path", "method", "body", "result", "AUTH_SCHEMA_SQL", "escapeSqlString", "value", "getSetAuthContextSQL", "userId", "role", "email", "claims", "escapedUserId", "escapedRole", "escapedEmail", "escapedClaims", "CLEAR_AUTH_CONTEXT_SQL", "base64UrlEncode", "data", "base64UrlDecode", "str", "base64", "binary", "bytes", "i", "encoder", "decoder", "signJWT", "payload", "secret", "header", "headerB64", "payloadB64", "key", "signature", "signatureB64", "verifyJWT", "token", "parts", "payloadJson", "now", "err", "decodeJWT", "DEFAULT_ACCESS_TOKEN_EXPIRY", "cachedSecret", "getJWTSecret", "db", "result", "bytes", "secret", "b", "createAccessToken", "user", "sessionId", "expiresIn", "now", "payload", "signJWT", "verifyAccessToken", "token", "verifyJWT", "generateTokenPair", "refreshToken", "accessToken", "extractUserIdFromToken", "decodeJWT", "extractSessionIdFromToken", "ACCESS_TOKEN_EXPIRY", "toPublicUser", "storedUser", "authError", "message", "status", "code", "AuthHandler", "db", "AUTH_SCHEMA_SQL", "event", "session", "callback", "err", "id", "email", "password", "options", "userMetadata", "result", "user", "refreshToken", "createAccessToken", "tokenResult", "new_token", "user_id", "session_id", "accessToken", "sessionId", "extractSessionIdFromToken", "verified", "verifyAccessToken", "attributes", "userId", "updates", "params", "paramIndex", "newAccessToken", "MemoryStorageBackend", "key", "data", "metadata", "prefix", "count", "fromKey", "toKey", "entry", "STORAGE_SCHEMA_SQL", "toUrlSafeBase64", "b64", "fromUrlSafeBase64", "b64url", "s", "StorageHandler", "db", "backend", "MemoryStorageBackend", "STORAGE_SCHEMA_SQL", "id", "options", "bucket", "sets", "params", "idx", "objects", "bucketId", "objectName", "data", "contentType", "mime", "metadata", "upsert", "result", "obj", "blobKey", "blob", "paths", "placeholders", "_", "i", "prefix", "limit", "offset", "sortColumn", "sortOrder", "safeColumn", "searchPattern", "sourceKey", "destinationKey", "destinationBucket", "destBucket", "fromKey", "toKey", "srcObj", "expiresIn", "payload", "signingKey", "encoder", "key", "payloadStr", "signature", "payloadB64", "sigB64", "token", "parts", "keyResult", "sigBytes", "c", "buffer", "hashBuffer", "hashArray", "b", "jsonResponse", "data", "status", "extractBearerToken", "headers", "auth", "parseBody", "request", "text", "handleAuthRoute", "pathname", "authHandler", "method", "searchParams", "body", "email", "password", "options", "result", "grantType", "refreshToken", "token", "session", "setAuthContext", "db", "token", "CLEAR_AUTH_CONTEXT_SQL", "verified", "verifyAccessToken", "userId", "role", "email", "sql", "getSetAuthContextSQL", "clearAuthContext", "extractPostgresError", "err", "pgError", "errorResponse", "status", "apiError", "jsonResponse", "data", "status", "headers", "extractBearerToken", "auth", "parseBody", "request", "text", "handleDataRoute", "pathname", "db", "parser", "method", "params", "filteredParams", "value", "key", "queryString", "pathParts", "resourcePath", "token", "setAuthContext", "parsed", "body", "sql", "prefer", "returnRepresentation", "result", "returnMinimal", "countHeader", "responseHeaders", "err", "errorResponse", "jsonResponse", "data", "status", "errorResponse", "message", "extractBearerToken", "headers", "auth", "parseJsonBody", "request", "text", "readFileBody", "requestContentType", "formData", "fieldName", "value", "arrayBuffer", "handleStorageRoute", "pathname", "db", "storageHandler", "method", "token", "authCtx", "setAuthContext", "handleListBuckets", "handleCreateBucket", "emptyMatch", "handleEmptyBucket", "bucketIdMatch", "bucketId", "handleGetBucket", "handleUpdateBucket", "handleDeleteBucket", "handleMoveObject", "handleCopyObject", "signMatch", "handleCreateSignedUrl", "signBatchMatch", "handleCreateSignedUrls", "signedToken", "handleSignedDownload", "publicMatch", "handlePublicDownload", "infoMatch", "handleObjectInfo", "listMatch", "handleListObjects", "removeMatch", "handleRemoveObjects", "uploadMatch", "handleUpload", "downloadMatch", "handleDownload", "handleExists", "renderMatch", "err", "handler", "buckets", "id", "bucket", "body", "name", "objectPath", "ownerId", "upsert", "cacheControl", "contentType", "obj", "result", "prefixes", "removed", "objects", "prefix", "items", "sourceKey", "destinationKey", "destinationBucket", "key", "expiresIn", "signedUrl", "paths", "results", "path", "payload", "getRouteInfo", "request", "supabaseUrl", "hasStorage", "url", "supabaseHost", "pathname", "createLocalFetch", "config", "db", "parser", "authHandler", "storageHandler", "originalFetch", "debug", "log", "args", "input", "init", "routeInfo", "authHeader", "response", "handleAuthRoute", "handleDataRoute", "handleStorageRoute", "err", "message", "createLocalSupabaseClient", "config", "createClient", "db", "supabaseUrl", "supabaseAnonKey", "debug", "originalFetch", "storageBackend", "PostgrestParser", "sql", "parser", "authHandler", "AuthHandler", "storageHandler", "StorageHandler", "localFetch", "createLocalFetch", "initializeAuth", "createFetchAdapter", "SupabaseClient", "db", "parser", "table", "PostgrestQueryBuilder", "functionName", "params", "parsed", "error", "columns", "data", "column", "value", "pattern", "values", "joined", "val", "options", "direction", "nulls", "count", "from", "to", "onfulfilled", "result", "queryString", "parts", "createSupabaseClient", "PostgrestParser", "sql", "PriorityQueue", "maxSize", "query", "queue", "priority", "sum", "q", "PGlitePooler", "db", "config", "PriorityQueue", "err", "resolve", "r", "sql", "params", "priority", "reject", "query", "error", "id", "result", "timeoutMs", "timeoutId", "timeoutPromise", "_", "queryPromise", "QueryPriority"]
}
