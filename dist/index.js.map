{
  "version": 3,
  "sources": ["../src/socket/adapters/node.ts", "../src/postgrest-parser.ts", "../src/supabase-client.ts", "../src/pooler.ts", "../src/queue.ts", "../src/socket/runtime.ts", "../src/socket/index.ts", "../src/types.ts", "../src/server.ts"],
  "sourcesContent": ["/**\n * Node.js socket adapter\n * Wraps Node.js net module to match WinterCG Socket interface\n */\n\nimport { type Socket as NetSocket, createServer as createNetServer } from 'node:net'\n\nimport type {\n  ServerOptions,\n  SocketAddress,\n  SocketInfo,\n  SocketOptions,\n  UniversalSocket,\n} from '../types.js'\n\n/**\n * Node.js socket adapter implementing WinterCG Socket interface\n */\nexport class NodeSocket implements UniversalSocket {\n  readonly readable: ReadableStream<Uint8Array>\n  readonly writable: WritableStream<Uint8Array>\n  readonly opened: Promise<SocketInfo>\n  readonly closed: Promise<void>\n\n  private socket: NetSocket\n  private openedResolve!: (info: SocketInfo) => void\n  private openedReject!: (error: Error) => void\n  private closedResolve!: () => void\n\n  constructor(socket: NetSocket) {\n    this.socket = socket\n\n    // Create opened promise\n    this.opened = new Promise((resolve, reject) => {\n      this.openedResolve = resolve\n      this.openedReject = reject\n    })\n\n    // Create closed promise\n    this.closed = new Promise((resolve) => {\n      this.closedResolve = resolve\n    })\n\n    // Convert Node.js socket to ReadableStream\n    this.readable = new ReadableStream({\n      start: (controller) => {\n        socket.on('data', (chunk: Buffer) => {\n          controller.enqueue(new Uint8Array(chunk))\n        })\n\n        socket.on('end', () => {\n          controller.close()\n        })\n\n        socket.on('error', (error) => {\n          controller.error(error)\n          this.openedReject(error)\n        })\n      },\n\n      cancel: () => {\n        socket.destroy()\n      },\n    })\n\n    // Convert Node.js socket to WritableStream\n    this.writable = new WritableStream({\n      write: (chunk: Uint8Array) => {\n        return new Promise((resolve, reject) => {\n          const canContinue = socket.write(chunk, (error) => {\n            if (error) reject(error)\n            else resolve()\n          })\n\n          // Handle backpressure\n          if (!canContinue) {\n            socket.once('drain', resolve)\n          }\n        })\n      },\n\n      close: () => {\n        return new Promise((resolve) => {\n          socket.end(() => resolve())\n        })\n      },\n\n      abort: (reason) => {\n        socket.destroy(reason instanceof Error ? reason : new Error(String(reason)))\n      },\n    })\n\n    // Handle socket events\n    // For server sockets, the connection is already established\n    // For client sockets, wait for 'connect' event\n    const resolveOpened = () => {\n      const localAddr = socket.address()\n      const remoteAddr = socket.remoteAddress\n      const remotePort = socket.remotePort\n\n      if (\n        typeof localAddr === 'object' &&\n        localAddr &&\n        'address' in localAddr &&\n        'port' in localAddr &&\n        remoteAddr &&\n        typeof remotePort === 'number'\n      ) {\n        this.openedResolve({\n          localAddress: {\n            hostname: localAddr.address as string,\n            port: localAddr.port as number,\n          },\n          remoteAddress: {\n            hostname: remoteAddr,\n            port: remotePort,\n          },\n        })\n      }\n    }\n\n    // If socket is already connected (server-side), resolve immediately\n    if (socket.remoteAddress && socket.remotePort) {\n      // Use setImmediate to ensure promise is created first\n      setImmediate(resolveOpened)\n    } else {\n      // Client-side: wait for connect event\n      socket.on('connect', resolveOpened)\n    }\n\n    socket.on('close', () => {\n      this.closedResolve()\n    })\n  }\n\n  async close(): Promise<void> {\n    this.socket.destroy()\n    return this.closed\n  }\n}\n\n/**\n * Create a client socket connection (Node.js)\n */\nexport async function connect(\n  address: SocketAddress,\n  _options?: SocketOptions\n): Promise<UniversalSocket> {\n  const { createConnection } = await import('node:net')\n\n  const socket = createConnection({\n    host: address.hostname,\n    port: address.port,\n  })\n\n  return new NodeSocket(socket)\n}\n\n/**\n * Create a TCP server (Node.js)\n */\nexport async function listen(options: ServerOptions): Promise<void> {\n  const server = createNetServer((socket) => {\n    const universalSocket = new NodeSocket(socket)\n    void options.handler.onConnection(universalSocket)\n  })\n\n  server.on('error', (error) => {\n    options.handler.onError?.(error)\n  })\n\n  return new Promise((resolve) => {\n    server.listen(options.port, options.hostname ?? '0.0.0.0', () => {\n      resolve()\n    })\n  })\n}\n", "/**\n * PostgREST Query Parser Wrapper\n * Uses native_postgrest_parser WASM to convert PostgREST queries to SQL\n */\n\nimport init, { initSchemaFromDb } from 'native_postgrest_parser/pkg/postgrest_parser.js'\nimport { createClient } from 'native_postgrest_parser/pkg/client.js'\nimport type { QueryResult as ParserQueryResult } from 'native_postgrest_parser/pkg/types.js'\n\n/**\n * Query executor function type for schema introspection\n */\nexport type QueryExecutor = (sql: string) => Promise<{ rows: unknown[] }>\n\n/**\n * Parsed SQL query with parameters\n */\nexport interface ParsedQuery {\n  readonly sql: string\n  readonly params: readonly unknown[]\n  readonly tables: readonly string[]\n}\n\n/**\n * PostgREST parser for converting REST queries to SQL\n */\nexport class PostgrestParser {\n  private readonly client: ReturnType<typeof createClient>\n  private static initPromise: Promise<unknown> | null = null\n\n  constructor() {\n    this.client = createClient()\n  }\n\n  /**\n   * Initialize the WASM module (must be called before first use)\n   * Safe to call multiple times - initialization happens only once\n   *\n   * Note: This uses the web target build which works in webcontainers and edge workers.\n   * For Node.js, the native_postgrest_parser package needs to be built with --target nodejs.\n   */\n  static async init(): Promise<void> {\n    if (!PostgrestParser.initPromise) {\n      PostgrestParser.initPromise = init()\n    }\n    await PostgrestParser.initPromise\n  }\n\n  /**\n   * Initialize schema introspection from a database connection\n   * This enables the parser to validate queries against the actual database schema\n   *\n   * @param queryExecutor - Function that executes SQL queries and returns rows\n   *\n   * @example\n   * ```typescript\n   * import { PGlite } from '@electric-sql/pglite'\n   * import { PostgrestParser } from './postgrest-parser'\n   *\n   * const db = new PGlite()\n   * await PostgrestParser.init()\n   *\n   * // Initialize schema introspection\n   * await PostgrestParser.initSchema(async (sql) => {\n   *   const result = await db.query(sql)\n   *   return { rows: result.rows }\n   * })\n   * ```\n   */\n  static async initSchema(queryExecutor: QueryExecutor): Promise<void> {\n    await PostgrestParser.init()\n    await initSchemaFromDb(queryExecutor)\n  }\n\n  /**\n   * Parse a SELECT query from PostgREST format\n   *\n   * @example\n   * parseSelect('users', 'id=eq.1&select=id,name')\n   * // => { sql: 'SELECT \"id\", \"name\" FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseSelect(table: string, queryString: string = ''): ParsedQuery {\n    return this.parseRequest('GET', table, queryString)\n  }\n\n  /**\n   * Parse an INSERT query from PostgREST format\n   *\n   * @example\n   * parseInsert('users', { name: 'Alice', email: 'alice@example.com' })\n   * // => { sql: 'INSERT INTO \"users\" (\"name\", \"email\") VALUES ($1, $2)', params: ['Alice', 'alice@example.com'] }\n   */\n  parseInsert(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string = ''\n  ): ParsedQuery {\n    return this.parseRequest('POST', table, queryString, data)\n  }\n\n  /**\n   * Parse an UPDATE query from PostgREST format\n   *\n   * @example\n   * parseUpdate('users', { name: 'Alice' }, 'id=eq.1')\n   * // => { sql: 'UPDATE \"users\" SET \"name\" = $1 WHERE \"id\" = $2', params: ['Alice', 1] }\n   */\n  parseUpdate(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string\n  ): ParsedQuery {\n    return this.parseRequest('PATCH', table, queryString, data)\n  }\n\n  /**\n   * Parse a DELETE query from PostgREST format\n   *\n   * @example\n   * parseDelete('users', 'id=eq.1')\n   * // => { sql: 'DELETE FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseDelete(table: string, queryString: string): ParsedQuery {\n    return this.parseRequest('DELETE', table, queryString)\n  }\n\n  /**\n   * Parse an RPC (function call) from PostgREST format\n   *\n   * @example\n   * parseRpc('calculate_total', { order_id: 123 })\n   * // => { sql: 'SELECT * FROM \"calculate_total\"($1)', params: [123] }\n   */\n  parseRpc(\n    functionName: string,\n    args?: Record<string, unknown>,\n    queryString: string = ''\n  ): ParsedQuery {\n    const path = `rpc/${functionName}`\n    return this.parseRequest('POST', path, queryString, args)\n  }\n\n  /**\n   * Parse a generic HTTP request to SQL\n   *\n   * @param method - HTTP method (GET, POST, PATCH, DELETE)\n   * @param path - Path without leading slash (e.g., 'users' or 'rpc/function_name')\n   * @param queryString - URL query parameters\n   * @param body - Request body (for POST/PATCH)\n   */\n  parseRequest(\n    method: 'GET' | 'POST' | 'PATCH' | 'DELETE',\n    path: string,\n    queryString: string = '',\n    body?: Record<string, unknown>\n  ): ParsedQuery {\n    const result = this.client.parseRequest(method, path, queryString, body ?? null, null)\n    return this.convertResult(result)\n  }\n\n  /**\n   * Convert WASM result to our ParsedQuery format\n   */\n  private convertResult(result: ParserQueryResult): ParsedQuery {\n    return {\n      sql: result.query,\n      params: Array.isArray(result.params) ? result.params : [],\n      tables: Array.isArray(result.tables) ? result.tables : [],\n    }\n  }\n}\n", "/**\n * Supabase-compatible client for PGlite\n * Intercepts PostgREST-style API calls and converts them to SQL\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport { PostgrestParser } from './postgrest-parser.js'\n\n/**\n * Query builder interface compatible with Supabase-js\n */\nexport interface QueryBuilder<T = unknown> {\n  select(columns?: string): QueryBuilder<T>\n  insert(data: Record<string, unknown> | Record<string, unknown>[]): QueryBuilder<T>\n  update(data: Record<string, unknown>): QueryBuilder<T>\n  delete(): QueryBuilder<T>\n  eq(column: string, value: unknown): QueryBuilder<T>\n  neq(column: string, value: unknown): QueryBuilder<T>\n  gt(column: string, value: unknown): QueryBuilder<T>\n  gte(column: string, value: unknown): QueryBuilder<T>\n  lt(column: string, value: unknown): QueryBuilder<T>\n  lte(column: string, value: unknown): QueryBuilder<T>\n  like(column: string, pattern: string): QueryBuilder<T>\n  ilike(column: string, pattern: string): QueryBuilder<T>\n  in(column: string, values: unknown[]): QueryBuilder<T>\n  is(column: string, value: null | boolean): QueryBuilder<T>\n  order(column: string, options?: { ascending?: boolean; nullsFirst?: boolean }): QueryBuilder<T>\n  limit(count: number): QueryBuilder<T>\n  range(from: number, to: number): QueryBuilder<T>\n  single(): QueryBuilder<T>\n  maybeSingle(): QueryBuilder<T>\n  then<TResult>(\n    onfulfilled?: ((value: { data: T | null; error: Error | null }) => TResult) | null\n  ): Promise<TResult>\n}\n\n/**\n * Supabase-compatible database client\n */\nexport class SupabaseClient {\n  private readonly db: PGlite\n  private readonly parser: PostgrestParser\n\n  constructor(db: PGlite, parser: PostgrestParser) {\n    this.db = db\n    this.parser = parser\n  }\n\n  /**\n   * Access a table for querying\n   */\n  from<T = unknown>(table: string): QueryBuilder<T> {\n    return new PostgrestQueryBuilder<T>(this.db, this.parser, table)\n  }\n\n  /**\n   * Call a stored procedure\n   */\n  async rpc<T = unknown>(\n    functionName: string,\n    params?: Record<string, unknown>\n  ): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const parsed = this.parser.parseRpc(functionName, params)\n      const result = await this.db.query(parsed.sql, [...parsed.params])\n      return { data: result.rows as T, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n}\n\n/**\n * Query builder implementation\n */\nclass PostgrestQueryBuilder<T> implements QueryBuilder<T> {\n  private readonly db: PGlite\n  private readonly parser: PostgrestParser\n  private readonly table: string\n  private selectColumns?: string\n  private filters: string[] = []\n  private orderBy?: string\n  private limitCount?: number\n  private offsetCount?: number\n  private insertData?: Record<string, unknown> | Record<string, unknown>[]\n  private updateData?: Record<string, unknown>\n  private isDelete = false\n  private expectSingle = false\n  private expectMaybeSingle = false\n\n  constructor(db: PGlite, parser: PostgrestParser, table: string) {\n    this.db = db\n    this.parser = parser\n    this.table = table\n  }\n\n  select(columns = '*'): QueryBuilder<T> {\n    this.selectColumns = columns\n    return this\n  }\n\n  insert(data: Record<string, unknown> | Record<string, unknown>[]): QueryBuilder<T> {\n    this.insertData = data\n    return this\n  }\n\n  update(data: Record<string, unknown>): QueryBuilder<T> {\n    this.updateData = data\n    return this\n  }\n\n  delete(): QueryBuilder<T> {\n    this.isDelete = true\n    return this\n  }\n\n  eq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=eq.${String(value)}`)\n    return this\n  }\n\n  neq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=neq.${String(value)}`)\n    return this\n  }\n\n  gt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gt.${String(value)}`)\n    return this\n  }\n\n  gte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gte.${String(value)}`)\n    return this\n  }\n\n  lt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lt.${String(value)}`)\n    return this\n  }\n\n  lte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lte.${String(value)}`)\n    return this\n  }\n\n  like(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=like.${pattern}`)\n    return this\n  }\n\n  ilike(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=ilike.${pattern}`)\n    return this\n  }\n\n  in(column: string, values: unknown[]): QueryBuilder<T> {\n    const joined = values.map(String).join(',')\n    this.filters.push(`${column}=in.(${joined})`)\n    return this\n  }\n\n  is(column: string, value: null | boolean): QueryBuilder<T> {\n    const val = value === null ? 'null' : value ? 'true' : 'false'\n    this.filters.push(`${column}=is.${val}`)\n    return this\n  }\n\n  order(column: string, options?: { ascending?: boolean; nullsFirst?: boolean }): QueryBuilder<T> {\n    const direction = options?.ascending === false ? 'desc' : 'asc'\n    const nulls = options?.nullsFirst ? 'nullsfirst' : 'nullslast'\n    this.orderBy = `${column}.${direction}.${nulls}`\n    return this\n  }\n\n  limit(count: number): QueryBuilder<T> {\n    this.limitCount = count\n    return this\n  }\n\n  range(from: number, to: number): QueryBuilder<T> {\n    this.offsetCount = from\n    this.limitCount = to - from + 1\n    return this\n  }\n\n  single(): QueryBuilder<T> {\n    this.expectSingle = true\n    this.limitCount = 1\n    return this\n  }\n\n  maybeSingle(): QueryBuilder<T> {\n    this.expectMaybeSingle = true\n    this.limitCount = 1\n    return this\n  }\n\n  async then<TResult>(\n    onfulfilled?: ((value: { data: T | null; error: Error | null }) => TResult) | null\n  ): Promise<TResult> {\n    const result = await this.execute()\n    return onfulfilled ? onfulfilled(result) : (result as unknown as TResult)\n  }\n\n  private async execute(): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const queryString = this.buildQueryString()\n\n      let parsed\n      if (this.insertData !== undefined) {\n        const data: Record<string, unknown> = Array.isArray(this.insertData)\n          ? (this.insertData[0] ?? {})\n          : this.insertData\n        parsed = this.parser.parseInsert(this.table, data, queryString)\n      } else if (this.updateData !== undefined) {\n        parsed = this.parser.parseUpdate(this.table, this.updateData, queryString)\n      } else if (this.isDelete) {\n        parsed = this.parser.parseDelete(this.table, queryString)\n      } else {\n        parsed = this.parser.parseSelect(this.table, queryString)\n      }\n\n      const result = await this.db.query(parsed.sql, [...parsed.params])\n\n      if (this.expectSingle && result.rows.length === 0) {\n        throw new Error('No rows returned')\n      }\n\n      if (this.expectSingle && result.rows.length > 1) {\n        throw new Error('Multiple rows returned')\n      }\n\n      const data = this.expectSingle || this.expectMaybeSingle\n        ? (result.rows[0] as T) ?? null\n        : (result.rows as T)\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  private buildQueryString(): string {\n    const parts: string[] = []\n\n    if (this.selectColumns) {\n      parts.push(`select=${this.selectColumns}`)\n    }\n\n    parts.push(...this.filters)\n\n    if (this.orderBy) {\n      parts.push(`order=${this.orderBy}`)\n    }\n\n    if (this.limitCount !== undefined) {\n      parts.push(`limit=${this.limitCount}`)\n    }\n\n    if (this.offsetCount !== undefined) {\n      parts.push(`offset=${this.offsetCount}`)\n    }\n\n    return parts.join('&')\n  }\n}\n\n/**\n * Create a Supabase-compatible client with schema introspection\n */\nexport async function createSupabaseClient(db: PGlite): Promise<SupabaseClient> {\n  await PostgrestParser.init()\n\n  // Initialize schema introspection from the database\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql)\n    return { rows: result.rows }\n  })\n\n  const parser = new PostgrestParser()\n  return new SupabaseClient(db, parser)\n}\n", "import { randomUUID } from 'node:crypto'\n\nimport type { PGlite } from '@electric-sql/pglite'\n\nimport { PriorityQueue } from './queue.js'\nimport type { PoolerConfig, QueuedQuery, QueryPriority, QueryResult } from './types.js'\n\n/**\n * Connection pooler that manages N-to-1 query execution against PGlite\n * Uses a priority queue to order query execution\n */\nexport class PGlitePooler {\n  private readonly db: PGlite\n  private readonly queue: PriorityQueue\n  private running: boolean = false\n  private readonly config: PoolerConfig\n\n  constructor(db: PGlite, config: Partial<PoolerConfig> = {}) {\n    this.db = db\n    this.queue = new PriorityQueue(config.maxQueueSize ?? 1000)\n    this.config = {\n      maxQueueSize: config.maxQueueSize ?? 1000,\n      defaultTimeout: config.defaultTimeout ?? 5000\n    }\n  }\n\n  /**\n   * Start the queue processor\n   * Begins draining queries from the queue\n   */\n  async start(): Promise<void> {\n    if (this.running) {\n      throw new Error('Pooler already started')\n    }\n    this.running = true\n\n    // Start processing in background\n    // Use setImmediate to ensure it starts in next tick\n    setImmediate(() => {\n      this.processQueue().catch(err => {\n        console.error('Queue processor error:', err)\n        this.running = false\n      })\n    })\n\n    // Give the processor a chance to start\n    await new Promise(resolve => setImmediate(resolve))\n  }\n\n  /**\n   * Stop the queue processor\n   * Waits for current query to complete\n   */\n  async stop(): Promise<void> {\n    this.running = false\n  }\n\n  /**\n   * Submit a query to the pool\n   * Returns a promise that resolves when the query completes\n   */\n  async query(\n    sql: string,\n    params?: readonly unknown[],\n    priority: QueryPriority = 2 // MEDIUM\n  ): Promise<QueryResult> {\n    return new Promise((resolve, reject) => {\n      const query: QueuedQuery = {\n        id: randomUUID(),\n        sql,\n        params,\n        priority,\n        enqueuedAt: Date.now(),\n        resolve,\n        reject,\n        timeoutMs: this.config.defaultTimeout\n      }\n\n      try {\n        this.queue.enqueue(query)\n      } catch (error) {\n        reject(error instanceof Error ? error : new Error(String(error)))\n      }\n    })\n  }\n\n  /**\n   * Background queue processor\n   * Continuously dequeues and executes queries\n   */\n  private async processQueue(): Promise<void> {\n    while (this.running) {\n      const query = this.queue.dequeue()\n\n      if (!query) {\n        // No queries, sleep briefly\n        await new Promise(r => setTimeout(r, 10))\n        continue\n      }\n\n      // Execute query with timeout\n      try {\n        const result = await this.executeWithTimeout(query)\n        query.resolve(result)\n      } catch (error) {\n        query.reject(error instanceof Error ? error : new Error(String(error)))\n      }\n    }\n  }\n\n  /**\n   * Execute a query with timeout protection\n   * Note: PGlite.query() already handles exclusive access internally via mutex\n   */\n  private async executeWithTimeout(query: QueuedQuery): Promise<QueryResult> {\n    const timeoutMs = query.timeoutMs ?? this.config.defaultTimeout\n\n    let timeoutId: NodeJS.Timeout | null = null\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error('Query timeout'))\n      }, timeoutMs)\n    })\n\n    // PGlite.query() already uses a mutex internally, no need for runExclusive\n    const queryPromise = this.db.query(query.sql, query.params as unknown[])\n      .finally(() => {\n        // Cancel timeout if query completes\n        if (timeoutId) clearTimeout(timeoutId)\n      })\n\n    return Promise.race([queryPromise, timeoutPromise]) as Promise<QueryResult>\n  }\n}\n", "import type { QueuedQuery } from './types.js'\nimport type { QueryPriority } from './types.js'\n\n/**\n * Priority-based queue for managing query execution order\n * Uses separate queues for each priority level\n */\nexport class PriorityQueue {\n  private readonly queues: Map<QueryPriority, QueuedQuery[]>\n  private readonly maxSize: number\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize\n    this.queues = new Map([\n      [0, []], // QueryPriority.CRITICAL\n      [1, []], // QueryPriority.HIGH\n      [2, []], // QueryPriority.MEDIUM\n      [3, []], // QueryPriority.LOW\n    ])\n  }\n\n  /**\n   * Add a query to the appropriate priority queue\n   * @throws {Error} if queue is full\n   */\n  enqueue(query: QueuedQuery): void {\n    const queue = this.queues.get(query.priority)\n    if (!queue) {\n      throw new Error(`Invalid priority: ${query.priority}`)\n    }\n\n    if (this.size() >= this.maxSize) {\n      throw new Error('Queue is full')\n    }\n\n    queue.push(query)\n  }\n\n  /**\n   * Remove and return the highest priority query\n   * Returns null if queue is empty\n   */\n  dequeue(): QueuedQuery | null {\n    // Check queues in priority order (CRITICAL = 0 to LOW = 3)\n    for (const priority of [0, 1, 2, 3] as const) {\n      const queue = this.queues.get(priority)\n      if (queue && queue.length > 0) {\n        return queue.shift() ?? null\n      }\n    }\n    return null\n  }\n\n  /**\n   * Get total number of queued queries across all priorities\n   */\n  size(): number {\n    return Array.from(this.queues.values())\n      .reduce((sum, q) => sum + q.length, 0)\n  }\n\n  /**\n   * Check if queue is empty\n   */\n  isEmpty(): boolean {\n    return this.size() === 0\n  }\n\n  /**\n   * Clear all queued queries\n   */\n  clear(): void {\n    for (const queue of this.queues.values()) {\n      queue.length = 0\n    }\n  }\n}\n", "/**\n * Runtime detection utilities\n * Detects which JavaScript runtime environment we're in\n */\n\n// Declare global types for runtime detection\ndeclare const Deno: { version?: { deno?: string } } | undefined\ndeclare const Bun: { version?: string } | undefined\n\nexport type Runtime = 'node' | 'deno' | 'bun' | 'workerd' | 'unknown'\n\n/**\n * Detect the current runtime environment\n */\nexport function detectRuntime(): Runtime {\n  // Check for Deno\n  if (typeof Deno !== 'undefined' && Deno?.version?.deno) {\n    return 'deno'\n  }\n\n  // Check for Bun\n  if (typeof Bun !== 'undefined' && Bun?.version) {\n    return 'bun'\n  }\n\n  // Check for Cloudflare Workers (workerd)\n  if (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') {\n    return 'workerd'\n  }\n\n  // Check for Node.js\n  if (typeof process !== 'undefined' && process.versions?.node) {\n    return 'node'\n  }\n\n  return 'unknown'\n}\n\n/**\n * Current detected runtime\n */\nexport const RUNTIME = detectRuntime()\n\n/**\n * Runtime checks\n */\nexport const isNode = RUNTIME === 'node'\nexport const isDeno = RUNTIME === 'deno'\nexport const isBun = RUNTIME === 'bun'\nexport const isWorkerd = RUNTIME === 'workerd'\n", "/**\n * Universal socket API\n * Automatically selects the appropriate runtime adapter\n */\n\nimport { RUNTIME } from './runtime.js'\nimport type { ServerOptions, SocketAddress, SocketOptions, UniversalSocket } from './types.js'\n\n/**\n * Create a socket connection\n * Automatically uses the correct adapter for the current runtime\n */\nexport async function connect(\n  address: SocketAddress,\n  options?: SocketOptions\n): Promise<UniversalSocket> {\n  switch (RUNTIME) {\n    case 'node': {\n      const { connect: nodeConnect } = await import('./adapters/node.js')\n      return nodeConnect(address, options)\n    }\n\n    case 'deno': {\n      // TODO: Implement Deno adapter\n      throw new Error('Deno adapter not yet implemented')\n    }\n\n    case 'bun': {\n      // TODO: Implement Bun adapter\n      throw new Error('Bun adapter not yet implemented')\n    }\n\n    case 'workerd': {\n      // TODO: Implement Cloudflare Workers adapter\n      throw new Error('Cloudflare Workers adapter not yet implemented')\n    }\n\n    default:\n      throw new Error(`Unsupported runtime: ${RUNTIME}`)\n  }\n}\n\n/**\n * Create a TCP server\n * Automatically uses the correct adapter for the current runtime\n */\nexport async function listen(options: ServerOptions): Promise<void> {\n  switch (RUNTIME) {\n    case 'node': {\n      const { listen: nodeListen } = await import('./adapters/node.js')\n      return nodeListen(options)\n    }\n\n    case 'deno': {\n      // TODO: Implement Deno adapter\n      throw new Error('Deno adapter not yet implemented')\n    }\n\n    case 'bun': {\n      // TODO: Implement Bun adapter\n      throw new Error('Bun adapter not yet implemented')\n    }\n\n    case 'workerd': {\n      // Cloudflare Workers doesn't support inbound TCP connections\n      throw new Error('Cloudflare Workers does not support TCP servers (outbound only)')\n    }\n\n    default:\n      throw new Error(`Unsupported runtime: ${RUNTIME}`)\n  }\n}\n\n// Re-export types\nexport type { ServerOptions, SocketAddress, SocketOptions, UniversalSocket } from './types.js'\nexport { RUNTIME, detectRuntime, isBun, isDeno, isNode, isWorkerd } from './runtime.js'\n", "/**\n * Priority levels for query execution\n * Lower number = higher priority\n */\nexport enum QueryPriority {\n  CRITICAL = 0,\n  HIGH = 1,\n  MEDIUM = 2,\n  LOW = 3,\n}\n\n/**\n * Result from PGlite query execution\n */\nexport interface QueryResult {\n  readonly rows: readonly Record<string, unknown>[]\n  readonly fields?: readonly { name: string; dataTypeID: number }[]\n  readonly affectedRows?: number\n}\n\n/**\n * Query queued for execution\n */\nexport interface QueuedQuery {\n  readonly id: string\n  readonly sql: string\n  readonly params?: readonly unknown[]\n  priority: QueryPriority // Mutable for aging mechanism\n  readonly enqueuedAt: number\n  readonly resolve: (result: QueryResult) => void\n  readonly reject: (error: Error) => void\n  readonly timeoutMs?: number\n}\n\n/**\n * Configuration for the connection pooler\n */\nexport interface PoolerConfig {\n  readonly maxQueueSize: number\n  readonly defaultTimeout: number\n}\n\n/**\n * Queue metrics for monitoring\n */\nexport interface QueueMetrics {\n  readonly totalEnqueued: number\n  readonly totalDequeued: number\n  readonly currentSize: number\n  readonly avgWaitTimeMs: number\n  readonly sizeByPriority: Readonly<Record<QueryPriority, number>>\n}\n", "/**\n * TCP Server for PGlite\n * Accepts TCP connections and routes SQL queries through the pooler\n */\n\nimport type { PGlitePooler } from './pooler.js'\nimport { listen } from './socket/index.js'\nimport type { UniversalSocket } from './socket/index.js'\nimport { QueryPriority } from './types.js'\n\n/**\n * Server configuration\n */\nexport interface ServerConfig {\n  readonly hostname?: string\n  readonly port: number\n  readonly pooler: PGlitePooler\n}\n\n/**\n * Simple TCP server for PGlite queries\n * Protocol: Newline-delimited SQL queries\n * Response: JSON with status and results\n */\nexport class PGliteServer {\n  private readonly config: ServerConfig\n  private readonly clients = new Set<string>()\n\n  constructor(config: ServerConfig) {\n    this.config = config\n  }\n\n  /**\n   * Start the TCP server\n   */\n  async start(): Promise<void> {\n    await this.config.pooler.start()\n\n    await listen({\n      hostname: this.config.hostname ?? '0.0.0.0',\n      port: this.config.port,\n      handler: {\n        onConnection: (socket) => this.handleConnection(socket),\n        onError: (error) => console.error('[Server] Error:', error),\n      },\n    })\n\n    console.log(`[Server] Listening on ${this.config.hostname ?? '0.0.0.0'}:${this.config.port}`)\n  }\n\n  /**\n   * Stop the server\n   */\n  async stop(): Promise<void> {\n    await this.config.pooler.stop()\n    console.log('[Server] Stopped')\n  }\n\n  /**\n   * Handle incoming connection\n   */\n  private async handleConnection(socket: UniversalSocket): Promise<void> {\n    const info = await socket.opened\n    const clientId = `${info.remoteAddress.hostname}:${info.remoteAddress.port}`\n\n    this.clients.add(clientId)\n    console.log(`[Server] Client connected: ${clientId}`)\n\n    try {\n      await this.processQueries(socket, clientId)\n    } catch (error) {\n      console.error(`[Server] Error handling client ${clientId}:`, error)\n    } finally {\n      this.clients.delete(clientId)\n      console.log(`[Server] Client disconnected: ${clientId}`)\n    }\n  }\n\n  /**\n   * Process queries from a client\n   */\n  private async processQueries(socket: UniversalSocket, clientId: string): Promise<void> {\n    const reader = socket.readable.getReader()\n    const writer = socket.writable.getWriter()\n    const decoder = new TextDecoder()\n    const encoder = new TextEncoder()\n\n    let buffer = ''\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n\n        if (done) break\n\n        // Accumulate data in buffer\n        buffer += decoder.decode(value, { stream: true })\n\n        // Process complete lines (queries separated by newlines)\n        const lines = buffer.split('\\n')\n        buffer = lines.pop() ?? '' // Keep incomplete line in buffer\n\n        for (const line of lines) {\n          const trimmed = line.trim()\n          if (!trimmed) continue\n\n          await this.handleQuery(writer, encoder, clientId, trimmed)\n        }\n      }\n    } finally {\n      reader.releaseLock()\n      writer.releaseLock()\n    }\n  }\n\n  /**\n   * Handle a single query\n   */\n  private async handleQuery(\n    writer: WritableStreamDefaultWriter<Uint8Array>,\n    encoder: TextEncoder,\n    _clientId: string,\n    sql: string\n  ): Promise<void> {\n    try {\n      // Execute query through pooler with default priority\n      const result = await this.config.pooler.query(sql, [], QueryPriority.MEDIUM)\n\n      // Send success response\n      const response = JSON.stringify({\n        status: 'success',\n        rows: result.rows,\n        rowCount: result.rows.length,\n        fields: result.fields,\n      })\n\n      await writer.write(encoder.encode(response + '\\n'))\n    } catch (error) {\n      // Send error response\n      const response = JSON.stringify({\n        status: 'error',\n        message: error instanceof Error ? error.message : String(error),\n      })\n\n      await writer.write(encoder.encode(response + '\\n'))\n    }\n  }\n\n  /**\n   * Get connected clients\n   */\n  getClients(): readonly string[] {\n    return Array.from(this.clients)\n  }\n}\n"],
  "mappings": "6HAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,gBAAAE,EAAA,YAAAC,EAAA,WAAAC,IAKA,OAAmC,gBAAgBC,MAAuB,WA2I1E,eAAsBF,EACpBG,EACAC,EAC0B,CAC1B,GAAM,CAAE,iBAAAC,CAAiB,EAAI,KAAM,QAAO,UAAU,EAE9CC,EAASD,EAAiB,CAC9B,KAAMF,EAAQ,SACd,KAAMA,EAAQ,IAChB,CAAC,EAED,OAAO,IAAIJ,EAAWO,CAAM,CAC9B,CAKA,eAAsBL,EAAOM,EAAuC,CAClE,IAAMC,EAASN,EAAiBI,GAAW,CACzC,IAAMG,EAAkB,IAAIV,EAAWO,CAAM,EACxCC,EAAQ,QAAQ,aAAaE,CAAe,CACnD,CAAC,EAED,OAAAD,EAAO,GAAG,QAAUE,GAAU,CAC5BH,EAAQ,QAAQ,UAAUG,CAAK,CACjC,CAAC,EAEM,IAAI,QAASC,GAAY,CAC9BH,EAAO,OAAOD,EAAQ,KAAMA,EAAQ,UAAY,UAAW,IAAM,CAC/DI,EAAQ,CACV,CAAC,CACH,CAAC,CACH,CAhLA,IAkBaZ,EAlBba,EAAAC,EAAA,kBAkBad,EAAN,KAA4C,CACxC,SACA,SACA,OACA,OAED,OACA,cACA,aACA,cAER,YAAYO,EAAmB,CAC7B,KAAK,OAASA,EAGd,KAAK,OAAS,IAAI,QAAQ,CAACK,EAASG,IAAW,CAC7C,KAAK,cAAgBH,EACrB,KAAK,aAAeG,CACtB,CAAC,EAGD,KAAK,OAAS,IAAI,QAASH,GAAY,CACrC,KAAK,cAAgBA,CACvB,CAAC,EAGD,KAAK,SAAW,IAAI,eAAe,CACjC,MAAQI,GAAe,CACrBT,EAAO,GAAG,OAASU,GAAkB,CACnCD,EAAW,QAAQ,IAAI,WAAWC,CAAK,CAAC,CAC1C,CAAC,EAEDV,EAAO,GAAG,MAAO,IAAM,CACrBS,EAAW,MAAM,CACnB,CAAC,EAEDT,EAAO,GAAG,QAAUI,GAAU,CAC5BK,EAAW,MAAML,CAAK,EACtB,KAAK,aAAaA,CAAK,CACzB,CAAC,CACH,EAEA,OAAQ,IAAM,CACZJ,EAAO,QAAQ,CACjB,CACF,CAAC,EAGD,KAAK,SAAW,IAAI,eAAe,CACjC,MAAQU,GACC,IAAI,QAAQ,CAACL,EAASG,IAAW,CAClBR,EAAO,MAAMU,EAAQN,GAAU,CAC7CA,EAAOI,EAAOJ,CAAK,EAClBC,EAAQ,CACf,CAAC,GAICL,EAAO,KAAK,QAASK,CAAO,CAEhC,CAAC,EAGH,MAAO,IACE,IAAI,QAASA,GAAY,CAC9BL,EAAO,IAAI,IAAMK,EAAQ,CAAC,CAC5B,CAAC,EAGH,MAAQM,GAAW,CACjBX,EAAO,QAAQW,aAAkB,MAAQA,EAAS,IAAI,MAAM,OAAOA,CAAM,CAAC,CAAC,CAC7E,CACF,CAAC,EAKD,IAAMC,EAAgB,IAAM,CAC1B,IAAMC,EAAYb,EAAO,QAAQ,EAC3Bc,EAAad,EAAO,cACpBe,EAAaf,EAAO,WAGxB,OAAOa,GAAc,UACrBA,GACA,YAAaA,GACb,SAAUA,GACVC,GACA,OAAOC,GAAe,UAEtB,KAAK,cAAc,CACjB,aAAc,CACZ,SAAUF,EAAU,QACpB,KAAMA,EAAU,IAClB,EACA,cAAe,CACb,SAAUC,EACV,KAAMC,CACR,CACF,CAAC,CAEL,EAGIf,EAAO,eAAiBA,EAAO,WAEjC,aAAaY,CAAa,EAG1BZ,EAAO,GAAG,UAAWY,CAAa,EAGpCZ,EAAO,GAAG,QAAS,IAAM,CACvB,KAAK,cAAc,CACrB,CAAC,CACH,CAEA,MAAM,OAAuB,CAC3B,YAAK,OAAO,QAAQ,EACb,KAAK,MACd,CACF,ICtIA,OAAOgB,GAAQ,oBAAAC,MAAwB,kDACvC,OAAS,gBAAAC,MAAoB,wCAoBtB,IAAMC,EAAN,MAAMC,CAAgB,CACV,OACjB,OAAe,YAAuC,KAEtD,aAAc,CACZ,KAAK,OAASF,EAAa,CAC7B,CASA,aAAa,MAAsB,CAC5BE,EAAgB,cACnBA,EAAgB,YAAcJ,EAAK,GAErC,MAAMI,EAAgB,WACxB,CAuBA,aAAa,WAAWC,EAA6C,CACnE,MAAMD,EAAgB,KAAK,EAC3B,MAAMH,EAAiBI,CAAa,CACtC,CASA,YAAYC,EAAeC,EAAsB,GAAiB,CAChE,OAAO,KAAK,aAAa,MAAOD,EAAOC,CAAW,CACpD,CASA,YACED,EACAE,EACAD,EAAsB,GACT,CACb,OAAO,KAAK,aAAa,OAAQD,EAAOC,EAAaC,CAAI,CAC3D,CASA,YACEF,EACAE,EACAD,EACa,CACb,OAAO,KAAK,aAAa,QAASD,EAAOC,EAAaC,CAAI,CAC5D,CASA,YAAYF,EAAeC,EAAkC,CAC3D,OAAO,KAAK,aAAa,SAAUD,EAAOC,CAAW,CACvD,CASA,SACEE,EACAC,EACAH,EAAsB,GACT,CACb,IAAMI,EAAO,OAAOF,CAAY,GAChC,OAAO,KAAK,aAAa,OAAQE,EAAMJ,EAAaG,CAAI,CAC1D,CAUA,aACEE,EACAD,EACAJ,EAAsB,GACtBM,EACa,CACb,IAAMC,EAAS,KAAK,OAAO,aAAaF,EAAQD,EAAMJ,EAAaM,GAAQ,KAAM,IAAI,EACrF,OAAO,KAAK,cAAcC,CAAM,CAClC,CAKQ,cAAcA,EAAwC,CAC5D,MAAO,CACL,IAAKA,EAAO,MACZ,OAAQ,MAAM,QAAQA,EAAO,MAAM,EAAIA,EAAO,OAAS,CAAC,EACxD,OAAQ,MAAM,QAAQA,EAAO,MAAM,EAAIA,EAAO,OAAS,CAAC,CAC1D,CACF,CACF,ECnIO,IAAMC,EAAN,KAAqB,CACT,GACA,OAEjB,YAAYC,EAAYC,EAAyB,CAC/C,KAAK,GAAKD,EACV,KAAK,OAASC,CAChB,CAKA,KAAkBC,EAAgC,CAChD,OAAO,IAAIC,EAAyB,KAAK,GAAI,KAAK,OAAQD,CAAK,CACjE,CAKA,MAAM,IACJE,EACAC,EACkD,CAClD,GAAI,CACF,IAAMC,EAAS,KAAK,OAAO,SAASF,EAAcC,CAAM,EAExD,MAAO,CAAE,MADM,MAAM,KAAK,GAAG,MAAMC,EAAO,IAAK,CAAC,GAAGA,EAAO,MAAM,CAAC,GAC3C,KAAW,MAAO,IAAK,CAC/C,OAASC,EAAO,CACd,MAAO,CAAE,KAAM,KAAM,MAAOA,CAAe,CAC7C,CACF,CACF,EAKMJ,EAAN,KAA0D,CACvC,GACA,OACA,MACT,cACA,QAAoB,CAAC,EACrB,QACA,WACA,YACA,WACA,WACA,SAAW,GACX,aAAe,GACf,kBAAoB,GAE5B,YAAYH,EAAYC,EAAyBC,EAAe,CAC9D,KAAK,GAAKF,EACV,KAAK,OAASC,EACd,KAAK,MAAQC,CACf,CAEA,OAAOM,EAAU,IAAsB,CACrC,YAAK,cAAgBA,EACd,IACT,CAEA,OAAOC,EAA4E,CACjF,YAAK,WAAaA,EACX,IACT,CAEA,OAAOA,EAAgD,CACrD,YAAK,WAAaA,EACX,IACT,CAEA,QAA0B,CACxB,YAAK,SAAW,GACT,IACT,CAEA,GAAGC,EAAgBC,EAAiC,CAClD,YAAK,QAAQ,KAAK,GAAGD,CAAM,OAAO,OAAOC,CAAK,CAAC,EAAE,EAC1C,IACT,CAEA,IAAID,EAAgBC,EAAiC,CACnD,YAAK,QAAQ,KAAK,GAAGD,CAAM,QAAQ,OAAOC,CAAK,CAAC,EAAE,EAC3C,IACT,CAEA,GAAGD,EAAgBC,EAAiC,CAClD,YAAK,QAAQ,KAAK,GAAGD,CAAM,OAAO,OAAOC,CAAK,CAAC,EAAE,EAC1C,IACT,CAEA,IAAID,EAAgBC,EAAiC,CACnD,YAAK,QAAQ,KAAK,GAAGD,CAAM,QAAQ,OAAOC,CAAK,CAAC,EAAE,EAC3C,IACT,CAEA,GAAGD,EAAgBC,EAAiC,CAClD,YAAK,QAAQ,KAAK,GAAGD,CAAM,OAAO,OAAOC,CAAK,CAAC,EAAE,EAC1C,IACT,CAEA,IAAID,EAAgBC,EAAiC,CACnD,YAAK,QAAQ,KAAK,GAAGD,CAAM,QAAQ,OAAOC,CAAK,CAAC,EAAE,EAC3C,IACT,CAEA,KAAKD,EAAgBE,EAAkC,CACrD,YAAK,QAAQ,KAAK,GAAGF,CAAM,SAASE,CAAO,EAAE,EACtC,IACT,CAEA,MAAMF,EAAgBE,EAAkC,CACtD,YAAK,QAAQ,KAAK,GAAGF,CAAM,UAAUE,CAAO,EAAE,EACvC,IACT,CAEA,GAAGF,EAAgBG,EAAoC,CACrD,IAAMC,EAASD,EAAO,IAAI,MAAM,EAAE,KAAK,GAAG,EAC1C,YAAK,QAAQ,KAAK,GAAGH,CAAM,QAAQI,CAAM,GAAG,EACrC,IACT,CAEA,GAAGJ,EAAgBC,EAAwC,CACzD,IAAMI,EAAMJ,IAAU,KAAO,OAASA,EAAQ,OAAS,QACvD,YAAK,QAAQ,KAAK,GAAGD,CAAM,OAAOK,CAAG,EAAE,EAChC,IACT,CAEA,MAAML,EAAgBM,EAA0E,CAC9F,IAAMC,EAAYD,GAAS,YAAc,GAAQ,OAAS,MACpDE,EAAQF,GAAS,WAAa,aAAe,YACnD,YAAK,QAAU,GAAGN,CAAM,IAAIO,CAAS,IAAIC,CAAK,GACvC,IACT,CAEA,MAAMC,EAAgC,CACpC,YAAK,WAAaA,EACX,IACT,CAEA,MAAMC,EAAcC,EAA6B,CAC/C,YAAK,YAAcD,EACnB,KAAK,WAAaC,EAAKD,EAAO,EACvB,IACT,CAEA,QAA0B,CACxB,YAAK,aAAe,GACpB,KAAK,WAAa,EACX,IACT,CAEA,aAA+B,CAC7B,YAAK,kBAAoB,GACzB,KAAK,WAAa,EACX,IACT,CAEA,MAAM,KACJE,EACkB,CAClB,IAAMC,EAAS,MAAM,KAAK,QAAQ,EAClC,OAAOD,EAAcA,EAAYC,CAAM,EAAKA,CAC9C,CAEA,MAAc,SAA4D,CACxE,GAAI,CACF,IAAMC,EAAc,KAAK,iBAAiB,EAEtClB,EACJ,GAAI,KAAK,aAAe,OAAW,CACjC,IAAMG,EAAgC,MAAM,QAAQ,KAAK,UAAU,EAC9D,KAAK,WAAW,CAAC,GAAK,CAAC,EACxB,KAAK,WACTH,EAAS,KAAK,OAAO,YAAY,KAAK,MAAOG,EAAMe,CAAW,CAChE,MAAW,KAAK,aAAe,OAC7BlB,EAAS,KAAK,OAAO,YAAY,KAAK,MAAO,KAAK,WAAYkB,CAAW,EAChE,KAAK,SACdlB,EAAS,KAAK,OAAO,YAAY,KAAK,MAAOkB,CAAW,EAExDlB,EAAS,KAAK,OAAO,YAAY,KAAK,MAAOkB,CAAW,EAG1D,IAAMD,EAAS,MAAM,KAAK,GAAG,MAAMjB,EAAO,IAAK,CAAC,GAAGA,EAAO,MAAM,CAAC,EAEjE,GAAI,KAAK,cAAgBiB,EAAO,KAAK,SAAW,EAC9C,MAAM,IAAI,MAAM,kBAAkB,EAGpC,GAAI,KAAK,cAAgBA,EAAO,KAAK,OAAS,EAC5C,MAAM,IAAI,MAAM,wBAAwB,EAO1C,MAAO,CAAE,KAJI,KAAK,cAAgB,KAAK,kBAClCA,EAAO,KAAK,CAAC,GAAW,KACxBA,EAAO,KAEG,MAAO,IAAK,CAC7B,OAAShB,EAAO,CACd,MAAO,CAAE,KAAM,KAAM,MAAOA,CAAe,CAC7C,CACF,CAEQ,kBAA2B,CACjC,IAAMkB,EAAkB,CAAC,EAEzB,OAAI,KAAK,eACPA,EAAM,KAAK,UAAU,KAAK,aAAa,EAAE,EAG3CA,EAAM,KAAK,GAAG,KAAK,OAAO,EAEtB,KAAK,SACPA,EAAM,KAAK,SAAS,KAAK,OAAO,EAAE,EAGhC,KAAK,aAAe,QACtBA,EAAM,KAAK,SAAS,KAAK,UAAU,EAAE,EAGnC,KAAK,cAAgB,QACvBA,EAAM,KAAK,UAAU,KAAK,WAAW,EAAE,EAGlCA,EAAM,KAAK,GAAG,CACvB,CACF,EAKA,eAAsBC,EAAqB1B,EAAqC,CAC9E,MAAM2B,EAAgB,KAAK,EAG3B,MAAMA,EAAgB,WAAW,MAAOC,IAE/B,CAAE,MADM,MAAM5B,EAAG,MAAM4B,CAAG,GACX,IAAK,EAC5B,EAED,IAAM3B,EAAS,IAAI0B,EACnB,OAAO,IAAI5B,EAAeC,EAAIC,CAAM,CACtC,CC1RA,OAAS,cAAA4B,MAAkB,cCOpB,IAAMC,EAAN,KAAoB,CACR,OACA,QAEjB,YAAYC,EAAkB,IAAM,CAClC,KAAK,QAAUA,EACf,KAAK,OAAS,IAAI,IAAI,CACpB,CAAC,EAAG,CAAC,CAAC,EACN,CAAC,EAAG,CAAC,CAAC,EACN,CAAC,EAAG,CAAC,CAAC,EACN,CAAC,EAAG,CAAC,CAAC,CACR,CAAC,CACH,CAMA,QAAQC,EAA0B,CAChC,IAAMC,EAAQ,KAAK,OAAO,IAAID,EAAM,QAAQ,EAC5C,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,qBAAqBD,EAAM,QAAQ,EAAE,EAGvD,GAAI,KAAK,KAAK,GAAK,KAAK,QACtB,MAAM,IAAI,MAAM,eAAe,EAGjCC,EAAM,KAAKD,CAAK,CAClB,CAMA,SAA8B,CAE5B,QAAWE,IAAY,CAAC,EAAG,EAAG,EAAG,CAAC,EAAY,CAC5C,IAAMD,EAAQ,KAAK,OAAO,IAAIC,CAAQ,EACtC,GAAID,GAASA,EAAM,OAAS,EAC1B,OAAOA,EAAM,MAAM,GAAK,IAE5B,CACA,OAAO,IACT,CAKA,MAAe,CACb,OAAO,MAAM,KAAK,KAAK,OAAO,OAAO,CAAC,EACnC,OAAO,CAACE,EAAKC,IAAMD,EAAMC,EAAE,OAAQ,CAAC,CACzC,CAKA,SAAmB,CACjB,OAAO,KAAK,KAAK,IAAM,CACzB,CAKA,OAAc,CACZ,QAAWH,KAAS,KAAK,OAAO,OAAO,EACrCA,EAAM,OAAS,CAEnB,CACF,EDjEO,IAAMI,EAAN,KAAmB,CACP,GACA,MACT,QAAmB,GACV,OAEjB,YAAYC,EAAYC,EAAgC,CAAC,EAAG,CAC1D,KAAK,GAAKD,EACV,KAAK,MAAQ,IAAIE,EAAcD,EAAO,cAAgB,GAAI,EAC1D,KAAK,OAAS,CACZ,aAAcA,EAAO,cAAgB,IACrC,eAAgBA,EAAO,gBAAkB,GAC3C,CACF,CAMA,MAAM,OAAuB,CAC3B,GAAI,KAAK,QACP,MAAM,IAAI,MAAM,wBAAwB,EAE1C,KAAK,QAAU,GAIf,aAAa,IAAM,CACjB,KAAK,aAAa,EAAE,MAAME,GAAO,CAC/B,QAAQ,MAAM,yBAA0BA,CAAG,EAC3C,KAAK,QAAU,EACjB,CAAC,CACH,CAAC,EAGD,MAAM,IAAI,QAAQC,GAAW,aAAaA,CAAO,CAAC,CACpD,CAMA,MAAM,MAAsB,CAC1B,KAAK,QAAU,EACjB,CAMA,MAAM,MACJC,EACAC,EACAC,EAA0B,EACJ,CACtB,OAAO,IAAI,QAAQ,CAACH,EAASI,IAAW,CACtC,IAAMC,EAAqB,CACzB,GAAIC,EAAW,EACf,IAAAL,EACA,OAAAC,EACA,SAAAC,EACA,WAAY,KAAK,IAAI,EACrB,QAAAH,EACA,OAAAI,EACA,UAAW,KAAK,OAAO,cACzB,EAEA,GAAI,CACF,KAAK,MAAM,QAAQC,CAAK,CAC1B,OAASE,EAAO,CACdH,EAAOG,aAAiB,MAAQA,EAAQ,IAAI,MAAM,OAAOA,CAAK,CAAC,CAAC,CAClE,CACF,CAAC,CACH,CAMA,MAAc,cAA8B,CAC1C,KAAO,KAAK,SAAS,CACnB,IAAMF,EAAQ,KAAK,MAAM,QAAQ,EAEjC,GAAI,CAACA,EAAO,CAEV,MAAM,IAAI,QAAQ,GAAK,WAAW,EAAG,EAAE,CAAC,EACxC,QACF,CAGA,GAAI,CACF,IAAMG,EAAS,MAAM,KAAK,mBAAmBH,CAAK,EAClDA,EAAM,QAAQG,CAAM,CACtB,OAASD,EAAO,CACdF,EAAM,OAAOE,aAAiB,MAAQA,EAAQ,IAAI,MAAM,OAAOA,CAAK,CAAC,CAAC,CACxE,CACF,CACF,CAMA,MAAc,mBAAmBF,EAA0C,CACzE,IAAMI,EAAYJ,EAAM,WAAa,KAAK,OAAO,eAE7CK,EAAmC,KAEjCC,EAAiB,IAAI,QAAe,CAACC,EAAGR,IAAW,CACvDM,EAAY,WAAW,IAAM,CAC3BN,EAAO,IAAI,MAAM,eAAe,CAAC,CACnC,EAAGK,CAAS,CACd,CAAC,EAGKI,EAAe,KAAK,GAAG,MAAMR,EAAM,IAAKA,EAAM,MAAmB,EACpE,QAAQ,IAAM,CAETK,GAAW,aAAaA,CAAS,CACvC,CAAC,EAEH,OAAO,QAAQ,KAAK,CAACG,EAAcF,CAAc,CAAC,CACpD,CACF,EExHO,SAASG,GAAyB,CAEvC,OAAI,OAAO,KAAS,KAAe,MAAM,SAAS,KACzC,OAIL,OAAO,IAAQ,KAAe,KAAK,QAC9B,MAIL,OAAO,UAAc,KAAe,UAAU,YAAc,qBACvD,UAIL,OAAO,QAAY,KAAe,QAAQ,UAAU,KAC/C,OAGF,SACT,CAKO,IAAMC,EAAUD,EAAc,EAKxBE,EAASD,IAAY,OACrBE,EAASF,IAAY,OACrBG,EAAQH,IAAY,MACpBI,EAAYJ,IAAY,UCrCrC,eAAsBK,EACpBC,EACAC,EAC0B,CAC1B,OAAQC,EAAS,CACf,IAAK,OAAQ,CACX,GAAM,CAAE,QAASC,CAAY,EAAI,KAAM,qCACvC,OAAOA,EAAYH,EAASC,CAAO,CACrC,CAEA,IAAK,OAEH,MAAM,IAAI,MAAM,kCAAkC,EAGpD,IAAK,MAEH,MAAM,IAAI,MAAM,iCAAiC,EAGnD,IAAK,UAEH,MAAM,IAAI,MAAM,gDAAgD,EAGlE,QACE,MAAM,IAAI,MAAM,wBAAwBC,CAAO,EAAE,CACrD,CACF,CAMA,eAAsBE,EAAOH,EAAuC,CAClE,OAAQC,EAAS,CACf,IAAK,OAAQ,CACX,GAAM,CAAE,OAAQG,CAAW,EAAI,KAAM,qCACrC,OAAOA,EAAWJ,CAAO,CAC3B,CAEA,IAAK,OAEH,MAAM,IAAI,MAAM,kCAAkC,EAGpD,IAAK,MAEH,MAAM,IAAI,MAAM,iCAAiC,EAGnD,IAAK,UAEH,MAAM,IAAI,MAAM,iEAAiE,EAGnF,QACE,MAAM,IAAI,MAAM,wBAAwBC,CAAO,EAAE,CACrD,CACF,CCnEO,IAAKI,OACVA,IAAA,SAAW,GAAX,WACAA,IAAA,KAAO,GAAP,OACAA,IAAA,OAAS,GAAT,SACAA,IAAA,IAAM,GAAN,MAJUA,OAAA,ICoBL,IAAMC,EAAN,KAAmB,CACP,OACA,QAAU,IAAI,IAE/B,YAAYC,EAAsB,CAChC,KAAK,OAASA,CAChB,CAKA,MAAM,OAAuB,CAC3B,MAAM,KAAK,OAAO,OAAO,MAAM,EAE/B,MAAMC,EAAO,CACX,SAAU,KAAK,OAAO,UAAY,UAClC,KAAM,KAAK,OAAO,KAClB,QAAS,CACP,aAAeC,GAAW,KAAK,iBAAiBA,CAAM,EACtD,QAAUC,GAAU,QAAQ,MAAM,kBAAmBA,CAAK,CAC5D,CACF,CAAC,EAED,QAAQ,IAAI,yBAAyB,KAAK,OAAO,UAAY,SAAS,IAAI,KAAK,OAAO,IAAI,EAAE,CAC9F,CAKA,MAAM,MAAsB,CAC1B,MAAM,KAAK,OAAO,OAAO,KAAK,EAC9B,QAAQ,IAAI,kBAAkB,CAChC,CAKA,MAAc,iBAAiBD,EAAwC,CACrE,IAAME,EAAO,MAAMF,EAAO,OACpBG,EAAW,GAAGD,EAAK,cAAc,QAAQ,IAAIA,EAAK,cAAc,IAAI,GAE1E,KAAK,QAAQ,IAAIC,CAAQ,EACzB,QAAQ,IAAI,8BAA8BA,CAAQ,EAAE,EAEpD,GAAI,CACF,MAAM,KAAK,eAAeH,EAAQG,CAAQ,CAC5C,OAASF,EAAO,CACd,QAAQ,MAAM,kCAAkCE,CAAQ,IAAKF,CAAK,CACpE,QAAE,CACA,KAAK,QAAQ,OAAOE,CAAQ,EAC5B,QAAQ,IAAI,iCAAiCA,CAAQ,EAAE,CACzD,CACF,CAKA,MAAc,eAAeH,EAAyBG,EAAiC,CACrF,IAAMC,EAASJ,EAAO,SAAS,UAAU,EACnCK,EAASL,EAAO,SAAS,UAAU,EACnCM,EAAU,IAAI,YACdC,EAAU,IAAI,YAEhBC,EAAS,GAEb,GAAI,CACF,OAAa,CACX,GAAM,CAAE,KAAAC,EAAM,MAAAC,CAAM,EAAI,MAAMN,EAAO,KAAK,EAE1C,GAAIK,EAAM,MAGVD,GAAUF,EAAQ,OAAOI,EAAO,CAAE,OAAQ,EAAK,CAAC,EAGhD,IAAMC,EAAQH,EAAO,MAAM;AAAA,CAAI,EAC/BA,EAASG,EAAM,IAAI,GAAK,GAExB,QAAWC,KAAQD,EAAO,CACxB,IAAME,EAAUD,EAAK,KAAK,EACrBC,GAEL,MAAM,KAAK,YAAYR,EAAQE,EAASJ,EAAUU,CAAO,CAC3D,CACF,CACF,QAAE,CACAT,EAAO,YAAY,EACnBC,EAAO,YAAY,CACrB,CACF,CAKA,MAAc,YACZA,EACAE,EACAO,EACAC,EACe,CACf,GAAI,CAEF,IAAMC,EAAS,MAAM,KAAK,OAAO,OAAO,MAAMD,EAAK,CAAC,GAAuB,EAGrEE,EAAW,KAAK,UAAU,CAC9B,OAAQ,UACR,KAAMD,EAAO,KACb,SAAUA,EAAO,KAAK,OACtB,OAAQA,EAAO,MACjB,CAAC,EAED,MAAMX,EAAO,MAAME,EAAQ,OAAOU,EAAW;AAAA,CAAI,CAAC,CACpD,OAAShB,EAAO,CAEd,IAAMgB,EAAW,KAAK,UAAU,CAC9B,OAAQ,QACR,QAAShB,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAChE,CAAC,EAED,MAAMI,EAAO,MAAME,EAAQ,OAAOU,EAAW;AAAA,CAAI,CAAC,CACpD,CACF,CAKA,YAAgC,CAC9B,OAAO,MAAM,KAAK,KAAK,OAAO,CAChC,CACF",
  "names": ["node_exports", "__export", "NodeSocket", "connect", "listen", "createNetServer", "address", "_options", "createConnection", "socket", "options", "server", "universalSocket", "error", "resolve", "init_node", "__esmMin", "reject", "controller", "chunk", "reason", "resolveOpened", "localAddr", "remoteAddr", "remotePort", "init", "initSchemaFromDb", "createClient", "PostgrestParser", "_PostgrestParser", "queryExecutor", "table", "queryString", "data", "functionName", "args", "path", "method", "body", "result", "SupabaseClient", "db", "parser", "table", "PostgrestQueryBuilder", "functionName", "params", "parsed", "error", "columns", "data", "column", "value", "pattern", "values", "joined", "val", "options", "direction", "nulls", "count", "from", "to", "onfulfilled", "result", "queryString", "parts", "createSupabaseClient", "PostgrestParser", "sql", "randomUUID", "PriorityQueue", "maxSize", "query", "queue", "priority", "sum", "q", "PGlitePooler", "db", "config", "PriorityQueue", "err", "resolve", "sql", "params", "priority", "reject", "query", "randomUUID", "error", "result", "timeoutMs", "timeoutId", "timeoutPromise", "_", "queryPromise", "detectRuntime", "RUNTIME", "isNode", "isDeno", "isBun", "isWorkerd", "connect", "address", "options", "RUNTIME", "nodeConnect", "listen", "nodeListen", "QueryPriority", "PGliteServer", "config", "listen", "socket", "error", "info", "clientId", "reader", "writer", "decoder", "encoder", "buffer", "done", "value", "lines", "line", "trimmed", "_clientId", "sql", "result", "response"]
}
