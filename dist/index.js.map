{
  "version": 3,
  "sources": ["../node_modules/.pnpm/postgrest-parser@https+++codeload.github.com+filipecabaco+native_postgrest_parser+tar.g_478e50d4a3dc609104fe7248934cac86/node_modules/postgrest-parser/pkg/postgrest_parser.js", "../node_modules/.pnpm/postgrest-parser@https+++codeload.github.com+filipecabaco+native_postgrest_parser+tar.g_478e50d4a3dc609104fe7248934cac86/node_modules/postgrest-parser/pkg/client.js", "../src/postgrest-parser.ts", "../src/auth/schema.ts", "../src/auth/jwt.ts", "../src/auth/crypto.ts", "../src/auth/handler.ts", "../src/fetch-adapter/auth-routes.ts", "../src/fetch-adapter/auth-context.ts", "../src/fetch-adapter/error-handler.ts", "../src/fetch-adapter/data-routes.ts", "../src/fetch-adapter/index.ts", "../src/client.ts", "../src/supabase-client.ts", "../src/queue.ts", "../src/pooler.ts", "../src/types.ts"],
  "sourcesContent": ["/* @ts-self-types=\"./postgrest_parser.d.ts\" */\n\n/**\n * Result of parsing a PostgREST query, designed for TypeScript consumption.\n */\nexport class WasmQueryResult {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WasmQueryResult.prototype);\n        obj.__wbg_ptr = ptr;\n        WasmQueryResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WasmQueryResultFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_wasmqueryresult_free(ptr, 0);\n    }\n    /**\n     * Get the query parameters as a JSON string\n     * @returns {any}\n     */\n    get params() {\n        const ret = wasm.wasmqueryresult_params(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the SQL query string\n     * @returns {string}\n     */\n    get query() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.wasmqueryresult_query(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export4(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the list of tables as a JSON array\n     * @returns {any}\n     */\n    get tables() {\n        const ret = wasm.wasmqueryresult_tables(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the entire result as a JSON object\n     * @returns {any}\n     */\n    toJSON() {\n        const ret = wasm.wasmqueryresult_toJSON(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) WasmQueryResult.prototype[Symbol.dispose] = WasmQueryResult.prototype.free;\n\n/**\n * Build a WHERE clause from parsed filters.\n *\n * # Arguments\n *\n * * `filters_json` - JSON array of filter conditions\n *\n * # Returns\n *\n * Returns an object with `clause` (SQL string) and `params` (array of values).\n * @param {any} filters_json\n * @returns {any}\n */\nexport function buildFilterClause(filters_json) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.buildFilterClause(retptr, addHeapObject(filters_json));\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Initialize schema cache from a database query executor.\n *\n * This function accepts a JavaScript async function that executes SQL queries\n * and returns results. The schema introspection queries will be executed via\n * this callback to populate the relationship cache.\n *\n * # Arguments\n *\n * * `query_executor` - An async JavaScript function with signature:\n *   `async (sql: string) => { rows: any[] }`\n *\n * # Example (TypeScript with PGlite)\n *\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite';\n * import { initSchemaFromDb } from './pkg/postgrest_parser.js';\n *\n * const db = new PGlite();\n *\n * // Create query executor for WASM\n * const queryExecutor = async (sql: string) => {\n *   const result = await db.query(sql);\n *   return { rows: result.rows };\n * };\n *\n * // Initialize schema from database\n * await initSchemaFromDb(queryExecutor);\n * ```\n * @param {Function} query_executor\n * @returns {Promise<void>}\n */\nexport function initSchemaFromDb(query_executor) {\n    const ret = wasm.initSchemaFromDb(addHeapObject(query_executor));\n    return takeObject(ret);\n}\n\n/**\n * Initialize WASM module (call this first from JavaScript)\n */\nexport function init_panic_hook() {\n    wasm.init_panic_hook();\n}\n\n/**\n * Parse and generate SQL for a DELETE operation.\n *\n * # Arguments\n *\n * * `table` - The table name\n * * `query_string` - Query string with filters and optional returning\n * * `headers` - Optional headers as JSON string\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseDelete(\"users\", \"id=eq.123&returning=id\", null);\n * console.log(result.query);   // DELETE FROM \"users\" WHERE ...\n * console.log(result.params);  // [\"123\"]\n * ```\n * @param {string} table\n * @param {string} query_string\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseDelete(table, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.parseDelete(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse and generate SQL for an INSERT operation.\n *\n * # Arguments\n *\n * * `table` - The table name\n * * `body` - JSON body (single object or array of objects)\n * * `query_string` - Optional query string for returning, on_conflict, etc.\n * * `headers` - Optional headers as JSON string (e.g., '{\"Prefer\":\"return=representation\"}')\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseInsert(\"users\",\n *   JSON.stringify({ name: \"Alice\", email: \"alice@example.com\" }),\n *   \"on_conflict=email&returning=id,name\",\n *   JSON.stringify({ Prefer: \"return=representation\" })\n * );\n * console.log(result.query);   // INSERT INTO \"users\" ...\n * console.log(result.params);  // [\"Alice\", \"alice@example.com\"]\n * ```\n * @param {string} table\n * @param {string} body\n * @param {string | null} [query_string]\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseInsert(table, body, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(query_string) ? 0 : passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.parseInsert(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse only the query string without generating SQL.\n *\n * Useful if you want to inspect the parsed structure before generating SQL.\n *\n * # Arguments\n *\n * * `query_string` - The PostgREST query string\n *\n * # Returns\n *\n * Returns the parsed parameters as a JSON object.\n * @param {string} query_string\n * @returns {any}\n */\nexport function parseOnly(query_string) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.parseOnly(retptr, ptr0, len0);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse a PostgREST query string and convert it to SQL.\n *\n * # Arguments\n *\n * * `table` - The table name to query\n * * `query_string` - The PostgREST query string (e.g., \"select=id,name&age=gte.18\")\n *\n * # Returns\n *\n * Returns a `WasmQueryResult` containing the SQL query, parameters, and affected tables.\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseQueryString(\"users\", \"age=gte.18&status=eq.active\");\n * console.log(result.query);   // SELECT * FROM \"users\" WHERE ...\n * console.log(result.params);  // [\"18\", \"active\"]\n * console.log(result.tables);  // [\"users\"]\n * ```\n * @param {string} table\n * @param {string} query_string\n * @returns {WasmQueryResult}\n */\nexport function parseQueryString(table, query_string) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.parseQueryString(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse a complete HTTP request and generate appropriate SQL.\n *\n * This is the most comprehensive function - it handles all HTTP methods\n * and automatically chooses between SELECT, INSERT, UPDATE, DELETE, or RPC.\n *\n * # Arguments\n *\n * * `method` - HTTP method: \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"\n * * `path` - Resource path (table name or \"rpc/function_name\")\n * * `query_string` - URL query string\n * * `body` - Request body as JSON string (or null)\n * * `headers` - Optional headers as JSON object (for Prefer header)\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * // SELECT query\n * const getResult = parseRequest(\"GET\", \"users\", \"age=gte.18&limit=10\", null, null);\n *\n * // INSERT with upsert\n * const postResult = parseRequest(\"POST\", \"users\", \"on_conflict=email\",\n *   JSON.stringify({ name: \"Alice\", email: \"alice@example.com\" }),\n *   JSON.stringify({ Prefer: \"return=representation\" })\n * );\n *\n * // RPC call\n * const rpcResult = parseRequest(\"POST\", \"rpc/my_function\",\n *   \"select=result\",\n *   JSON.stringify({ arg1: \"value\" }),\n *   null\n * );\n * ```\n * @param {string} method\n * @param {string} path\n * @param {string} query_string\n * @param {string | null} [body]\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseRequest(method, path, query_string, body, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(method, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        var ptr4 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len4 = WASM_VECTOR_LEN;\n        wasm.parseRequest(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse and generate SQL for an RPC (stored procedure/function) call.\n *\n * # Arguments\n *\n * * `function_name` - The function name (can include schema: \"schema.function\")\n * * `body` - JSON object with function arguments (or null for no args)\n * * `query_string` - Optional query string for filtering/ordering results\n * * `headers` - Optional headers as JSON string\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseRpc(\"calculate_total\",\n *   JSON.stringify({ order_id: 123, tax_rate: 0.08 }),\n *   \"select=total,tax&limit=1\",\n *   null\n * );\n * console.log(result.query);   // SELECT * FROM calculate_total(...)\n * console.log(result.params);  // [123, 0.08]\n * ```\n * @param {string} function_name\n * @param {string | null} [body]\n * @param {string | null} [query_string]\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseRpc(function_name, body, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(query_string) ? 0 : passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.parseRpc(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n * Parse and generate SQL for an UPDATE operation.\n *\n * # Arguments\n *\n * * `table` - The table name\n * * `body` - JSON object with fields to update\n * * `query_string` - Query string with filters and optional returning\n * * `headers` - Optional headers as JSON string\n *\n * # Example (TypeScript)\n *\n * ```typescript\n * const result = parseUpdate(\"users\",\n *   JSON.stringify({ status: \"active\" }),\n *   \"id=eq.123&returning=id,status\",\n *   null\n * );\n * console.log(result.query);   // UPDATE \"users\" SET ...\n * console.log(result.params);  // [\"active\", \"123\"]\n * ```\n * @param {string} table\n * @param {string} body\n * @param {string} query_string\n * @param {string | null} [headers]\n * @returns {WasmQueryResult}\n */\nexport function parseUpdate(table, body, query_string, headers) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(table, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(body, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(query_string, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(headers) ? 0 : passStringToWasm0(headers, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.parseUpdate(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return WasmQueryResult.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction __wbg_get_imports() {\n    const import0 = {\n        __proto__: null,\n        __wbg_Error_8c4e43fe74559d73: function(arg0, arg1) {\n            const ret = Error(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        },\n        __wbg_Number_04624de7d0e8332d: function(arg0) {\n            const ret = Number(getObject(arg0));\n            return ret;\n        },\n        __wbg_String_8f0eb39a4a4c2f66: function(arg0, arg1) {\n            const ret = String(getObject(arg1));\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_bigint_get_as_i64_8fcf4ce7f1ca72a2: function(arg0, arg1) {\n            const v = getObject(arg1);\n            const ret = typeof(v) === 'bigint' ? v : undefined;\n            getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_boolean_get_bbbb1c18aa2f5e25: function(arg0) {\n            const v = getObject(arg0);\n            const ret = typeof(v) === 'boolean' ? v : undefined;\n            return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n        },\n        __wbg___wbindgen_debug_string_0bc8482c6e3508ae: function(arg0, arg1) {\n            const ret = debugString(getObject(arg1));\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_in_47fa6863be6f2f25: function(arg0, arg1) {\n            const ret = getObject(arg0) in getObject(arg1);\n            return ret;\n        },\n        __wbg___wbindgen_is_bigint_31b12575b56f32fc: function(arg0) {\n            const ret = typeof(getObject(arg0)) === 'bigint';\n            return ret;\n        },\n        __wbg___wbindgen_is_function_0095a73b8b156f76: function(arg0) {\n            const ret = typeof(getObject(arg0)) === 'function';\n            return ret;\n        },\n        __wbg___wbindgen_is_object_5ae8e5880f2c1fbd: function(arg0) {\n            const val = getObject(arg0);\n            const ret = typeof(val) === 'object' && val !== null;\n            return ret;\n        },\n        __wbg___wbindgen_is_string_cd444516edc5b180: function(arg0) {\n            const ret = typeof(getObject(arg0)) === 'string';\n            return ret;\n        },\n        __wbg___wbindgen_is_undefined_9e4d92534c42d778: function(arg0) {\n            const ret = getObject(arg0) === undefined;\n            return ret;\n        },\n        __wbg___wbindgen_jsval_eq_11888390b0186270: function(arg0, arg1) {\n            const ret = getObject(arg0) === getObject(arg1);\n            return ret;\n        },\n        __wbg___wbindgen_jsval_loose_eq_9dd77d8cd6671811: function(arg0, arg1) {\n            const ret = getObject(arg0) == getObject(arg1);\n            return ret;\n        },\n        __wbg___wbindgen_number_get_8ff4255516ccad3e: function(arg0, arg1) {\n            const obj = getObject(arg1);\n            const ret = typeof(obj) === 'number' ? obj : undefined;\n            getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_string_get_72fb696202c56729: function(arg0, arg1) {\n            const obj = getObject(arg1);\n            const ret = typeof(obj) === 'string' ? obj : undefined;\n            var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_throw_be289d5034ed271b: function(arg0, arg1) {\n            throw new Error(getStringFromWasm0(arg0, arg1));\n        },\n        __wbg__wbg_cb_unref_d9b87ff7982e3b21: function(arg0) {\n            getObject(arg0)._wbg_cb_unref();\n        },\n        __wbg_call_389efe28435a9388: function() { return handleError(function (arg0, arg1) {\n            const ret = getObject(arg0).call(getObject(arg1));\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_call_4708e0c13bdc8e95: function() { return handleError(function (arg0, arg1, arg2) {\n            const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_done_57b39ecd9addfe81: function(arg0) {\n            const ret = getObject(arg0).done;\n            return ret;\n        },\n        __wbg_entries_58c7934c745daac7: function(arg0) {\n            const ret = Object.entries(getObject(arg0));\n            return addHeapObject(ret);\n        },\n        __wbg_error_7534b8e9a36f1ab4: function(arg0, arg1) {\n            let deferred0_0;\n            let deferred0_1;\n            try {\n                deferred0_0 = arg0;\n                deferred0_1 = arg1;\n                console.error(getStringFromWasm0(arg0, arg1));\n            } finally {\n                wasm.__wbindgen_export4(deferred0_0, deferred0_1, 1);\n            }\n        },\n        __wbg_get_9b94d73e6221f75c: function(arg0, arg1) {\n            const ret = getObject(arg0)[arg1 >>> 0];\n            return addHeapObject(ret);\n        },\n        __wbg_get_b3ed3ad4be2bc8ac: function() { return handleError(function (arg0, arg1) {\n            const ret = Reflect.get(getObject(arg0), getObject(arg1));\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_get_with_ref_key_1dc361bd10053bfe: function(arg0, arg1) {\n            const ret = getObject(arg0)[getObject(arg1)];\n            return addHeapObject(ret);\n        },\n        __wbg_instanceof_ArrayBuffer_c367199e2fa2aa04: function(arg0) {\n            let result;\n            try {\n                result = getObject(arg0) instanceof ArrayBuffer;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Map_53af74335dec57f4: function(arg0) {\n            let result;\n            try {\n                result = getObject(arg0) instanceof Map;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Uint8Array_9b9075935c74707c: function(arg0) {\n            let result;\n            try {\n                result = getObject(arg0) instanceof Uint8Array;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_isArray_d314bb98fcf08331: function(arg0) {\n            const ret = Array.isArray(getObject(arg0));\n            return ret;\n        },\n        __wbg_isSafeInteger_bfbc7332a9768d2a: function(arg0) {\n            const ret = Number.isSafeInteger(getObject(arg0));\n            return ret;\n        },\n        __wbg_iterator_6ff6560ca1568e55: function() {\n            const ret = Symbol.iterator;\n            return addHeapObject(ret);\n        },\n        __wbg_length_32ed9a279acd054c: function(arg0) {\n            const ret = getObject(arg0).length;\n            return ret;\n        },\n        __wbg_length_35a7bace40f36eac: function(arg0) {\n            const ret = getObject(arg0).length;\n            return ret;\n        },\n        __wbg_log_6b5ca2e6124b2808: function(arg0) {\n            console.log(getObject(arg0));\n        },\n        __wbg_new_361308b2356cecd0: function() {\n            const ret = new Object();\n            return addHeapObject(ret);\n        },\n        __wbg_new_3eb36ae241fe6f44: function() {\n            const ret = new Array();\n            return addHeapObject(ret);\n        },\n        __wbg_new_8a6f238a6ece86ea: function() {\n            const ret = new Error();\n            return addHeapObject(ret);\n        },\n        __wbg_new_b5d9e2fb389fef91: function(arg0, arg1) {\n            try {\n                var state0 = {a: arg0, b: arg1};\n                var cb0 = (arg0, arg1) => {\n                    const a = state0.a;\n                    state0.a = 0;\n                    try {\n                        return __wasm_bindgen_func_elem_442(a, state0.b, arg0, arg1);\n                    } finally {\n                        state0.a = a;\n                    }\n                };\n                const ret = new Promise(cb0);\n                return addHeapObject(ret);\n            } finally {\n                state0.a = state0.b = 0;\n            }\n        },\n        __wbg_new_dca287b076112a51: function() {\n            const ret = new Map();\n            return addHeapObject(ret);\n        },\n        __wbg_new_dd2b680c8bf6ae29: function(arg0) {\n            const ret = new Uint8Array(getObject(arg0));\n            return addHeapObject(ret);\n        },\n        __wbg_new_no_args_1c7c842f08d00ebb: function(arg0, arg1) {\n            const ret = new Function(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        },\n        __wbg_next_3482f54c49e8af19: function() { return handleError(function (arg0) {\n            const ret = getObject(arg0).next();\n            return addHeapObject(ret);\n        }, arguments); },\n        __wbg_next_418f80d8f5303233: function(arg0) {\n            const ret = getObject(arg0).next;\n            return addHeapObject(ret);\n        },\n        __wbg_prototypesetcall_bdcdcc5842e4d77d: function(arg0, arg1, arg2) {\n            Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), getObject(arg2));\n        },\n        __wbg_queueMicrotask_0aa0a927f78f5d98: function(arg0) {\n            const ret = getObject(arg0).queueMicrotask;\n            return addHeapObject(ret);\n        },\n        __wbg_queueMicrotask_5bb536982f78a56f: function(arg0) {\n            queueMicrotask(getObject(arg0));\n        },\n        __wbg_resolve_002c4b7d9d8f6b64: function(arg0) {\n            const ret = Promise.resolve(getObject(arg0));\n            return addHeapObject(ret);\n        },\n        __wbg_set_1eb0999cf5d27fc8: function(arg0, arg1, arg2) {\n            const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n            return addHeapObject(ret);\n        },\n        __wbg_set_3f1d0b984ed272ed: function(arg0, arg1, arg2) {\n            getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n        },\n        __wbg_set_f43e577aea94465b: function(arg0, arg1, arg2) {\n            getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n        },\n        __wbg_stack_0ed75d68575b0f3c: function(arg0, arg1) {\n            const ret = getObject(arg1).stack;\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg_static_accessor_GLOBAL_12837167ad935116: function() {\n            const ret = typeof global === 'undefined' ? null : global;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_static_accessor_GLOBAL_THIS_e628e89ab3b1c95f: function() {\n            const ret = typeof globalThis === 'undefined' ? null : globalThis;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_static_accessor_SELF_a621d3dfbb60d0ce: function() {\n            const ret = typeof self === 'undefined' ? null : self;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_static_accessor_WINDOW_f8727f0cf888e0bd: function() {\n            const ret = typeof window === 'undefined' ? null : window;\n            return isLikeNone(ret) ? 0 : addHeapObject(ret);\n        },\n        __wbg_then_0d9fe2c7b1857d32: function(arg0, arg1, arg2) {\n            const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n            return addHeapObject(ret);\n        },\n        __wbg_then_b9e7b3b5f1a9e1b5: function(arg0, arg1) {\n            const ret = getObject(arg0).then(getObject(arg1));\n            return addHeapObject(ret);\n        },\n        __wbg_value_0546255b415e96c1: function(arg0) {\n            const ret = getObject(arg0).value;\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000001: function(arg0, arg1) {\n            // Cast intrinsic for `Closure(Closure { dtor_idx: 51, function: Function { arguments: [Externref], shim_idx: 52, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n            const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_366, __wasm_bindgen_func_elem_367);\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000002: function(arg0) {\n            // Cast intrinsic for `F64 -> Externref`.\n            const ret = arg0;\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000003: function(arg0) {\n            // Cast intrinsic for `I64 -> Externref`.\n            const ret = arg0;\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000004: function(arg0, arg1) {\n            // Cast intrinsic for `Ref(String) -> Externref`.\n            const ret = getStringFromWasm0(arg0, arg1);\n            return addHeapObject(ret);\n        },\n        __wbindgen_cast_0000000000000005: function(arg0) {\n            // Cast intrinsic for `U64 -> Externref`.\n            const ret = BigInt.asUintN(64, arg0);\n            return addHeapObject(ret);\n        },\n        __wbindgen_object_clone_ref: function(arg0) {\n            const ret = getObject(arg0);\n            return addHeapObject(ret);\n        },\n        __wbindgen_object_drop_ref: function(arg0) {\n            takeObject(arg0);\n        },\n    };\n    return {\n        __proto__: null,\n        \"./postgrest_parser_bg.js\": import0,\n    };\n}\n\nfunction __wasm_bindgen_func_elem_367(arg0, arg1, arg2) {\n    wasm.__wasm_bindgen_func_elem_367(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wasm_bindgen_func_elem_442(arg0, arg1, arg2, arg3) {\n    wasm.__wasm_bindgen_func_elem_442(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\nconst WasmQueryResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_wasmqueryresult_free(ptr >>> 0, 1));\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => state.dtor(state.a, state.b));\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedDataViewMemory0 = null;\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export3(addHeapObject(e));\n    }\n}\n\nlet heap = new Array(128).fill(undefined);\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            state.a = a;\n            real._wbg_cb_unref();\n        }\n    };\n    real._wbg_cb_unref = () => {\n        if (--state.cnt === 0) {\n            state.dtor(state.a, state.b);\n            state.a = 0;\n            CLOSURE_DTORS.unregister(state);\n        }\n    };\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\ncachedTextDecoder.decode();\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet wasmModule, wasm;\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    wasmModule = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && expectedResponseType(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else { throw e; }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        } else {\n            return instance;\n        }\n    }\n\n    function expectedResponseType(type) {\n        switch (type) {\n            case 'basic': case 'cors': case 'default': return true;\n        }\n        return false;\n    }\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module !== undefined) {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module_or_path !== undefined) {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (module_or_path === undefined) {\n        module_or_path = new URL('postgrest_parser_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync, __wbg_init as default };\n", "/**\n * Type-safe TypeScript wrapper for PostgREST Parser\n *\n * This module provides a type-safe, idiomatic TypeScript API on top of\n * the auto-generated WASM bindings, improving developer experience.\n */\nimport { parseRequest as wasmParseRequest, parseInsert as wasmParseInsert, parseUpdate as wasmParseUpdate, parseDelete as wasmParseDelete, parseRpc as wasmParseRpc, parseOnly as wasmParseOnly, buildFilterClause as wasmBuildFilterClause, } from \"./postgrest_parser.js\";\n// Re-export WASM initialization functions\nexport { default as init, initSchemaFromDb } from \"./postgrest_parser.js\";\n/**\n * Convert WASM result to typed QueryResult\n */\nfunction toQueryResult(wasmResult) {\n    return {\n        query: wasmResult.query,\n        params: wasmResult.params,\n        tables: wasmResult.tables,\n    };\n}\n/**\n * Convert headers object to JSON string\n */\nfunction headersToJson(headers) {\n    return headers ? JSON.stringify(headers) : undefined;\n}\n/**\n * Convert PreferOptions to Prefer header value\n */\nfunction preferToHeader(prefer) {\n    if (!prefer)\n        return undefined;\n    const parts = [];\n    if (prefer.return)\n        parts.push(`return=${prefer.return}`);\n    if (prefer.resolution)\n        parts.push(`resolution=${prefer.resolution}`);\n    if (prefer.missing)\n        parts.push(`missing=${prefer.missing}`);\n    if (prefer.count)\n        parts.push(`count=${prefer.count}`);\n    return parts.length > 0 ? parts.join(\",\") : undefined;\n}\n/**\n * Build query string from filters and options\n */\nfunction buildQueryString(filters, options) {\n    const parts = [];\n    // Add filters\n    if (filters) {\n        for (const [key, value] of Object.entries(filters)) {\n            parts.push(`${key}=${value}`);\n        }\n    }\n    // Add select\n    if (options?.select) {\n        const select = Array.isArray(options.select)\n            ? options.select.join(\",\")\n            : options.select;\n        parts.push(`select=${select}`);\n    }\n    // Add order\n    if (options?.order) {\n        const order = Array.isArray(options.order)\n            ? options.order.join(\",\")\n            : options.order;\n        parts.push(`order=${order}`);\n    }\n    // Add limit\n    if (options?.limit !== undefined) {\n        parts.push(`limit=${options.limit}`);\n    }\n    // Add offset\n    if (options?.offset !== undefined) {\n        parts.push(`offset=${options.offset}`);\n    }\n    // Add on_conflict\n    if (options?.onConflict) {\n        const onConflict = Array.isArray(options.onConflict)\n            ? options.onConflict.join(\",\")\n            : options.onConflict;\n        parts.push(`on_conflict=${onConflict}`);\n    }\n    // Add returning\n    if (options?.returning) {\n        const returning = Array.isArray(options.returning)\n            ? options.returning.join(\",\")\n            : options.returning;\n        parts.push(`returning=${returning}`);\n    }\n    return parts.join(\"&\");\n}\n/**\n * Type-safe PostgREST Parser client\n *\n * Provides strongly-typed methods for generating PostgREST-compatible SQL queries.\n *\n * @example\n * ```typescript\n * const client = new PostgRESTParser();\n *\n * // SELECT query\n * const getUsers = client.select(\"users\", {\n *   filters: { \"age\": \"gte.18\", \"status\": \"eq.active\" },\n *   order: [\"created_at.desc\"],\n *   limit: 10\n * });\n *\n * // INSERT query\n * const createUser = client.insert(\"users\", {\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * }, {\n *   returning: \"*\",\n *   prefer: { return: \"representation\" }\n * });\n *\n * // Execute with your database client\n * const rows = await db.query(getUsers.query, getUsers.params);\n * ```\n */\nexport class PostgRESTParser {\n    /**\n     * Parse a complete HTTP request and generate appropriate SQL\n     *\n     * This is the universal routing method that handles all HTTP methods.\n     *\n     * @param method - HTTP method: \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"\n     * @param path - Resource path (table name or \"rpc/function_name\")\n     * @param queryString - URL query string\n     * @param body - Request body (object or null)\n     * @param headers - Request headers (object or null)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.parseRequest(\"GET\", \"users\", \"age=gte.18\", null, null);\n     * const rows = await db.query(result.query, result.params);\n     * ```\n     */\n    parseRequest(method, path, queryString, body, headers) {\n        const bodyJson = body ? JSON.stringify(body) : undefined;\n        const headersJson = headers ? headersToJson(headers) : undefined;\n        const result = wasmParseRequest(method, path, queryString, bodyJson, headersJson);\n        return toQueryResult(result);\n    }\n    /**\n     * Generate a SELECT query\n     *\n     * @param table - Table name to query\n     * @param options - Query options (filters, ordering, pagination)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.select(\"users\", {\n     *   filters: { \"age\": \"gte.18\", \"status\": \"eq.active\" },\n     *   order: [\"created_at.desc\"],\n     *   limit: 10,\n     *   offset: 0\n     * });\n     * ```\n     */\n    select(table, options = {}) {\n        const queryString = buildQueryString(options.filters, options);\n        const headers = options.count\n            ? { Prefer: `count=${options.count}` }\n            : undefined;\n        const result = wasmParseRequest(\"GET\", table, queryString, undefined, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an INSERT query\n     *\n     * @param table - Table name\n     * @param data - Data to insert (single object or array of objects)\n     * @param options - Insert options (returning, onConflict, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.insert(\"users\", {\n     *   name: \"Alice\",\n     *   email: \"alice@example.com\"\n     * }, {\n     *   returning: \"*\",\n     *   prefer: { return: \"representation\" }\n     * });\n     * ```\n     */\n    insert(table, data, options = {}) {\n        const queryString = buildQueryString(undefined, {\n            onConflict: options.onConflict,\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseInsert(table, JSON.stringify(data), queryString || undefined, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an UPSERT query (INSERT with ON CONFLICT)\n     *\n     * PUT method auto-generates ON CONFLICT from filter columns.\n     *\n     * @param table - Table name\n     * @param data - Data to upsert\n     * @param conflictColumns - Columns to use for conflict detection\n     * @param options - Upsert options (returning, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.upsert(\"users\", {\n     *   email: \"alice@example.com\",\n     *   name: \"Alice Updated\"\n     * }, [\"email\"], {\n     *   returning: \"*\"\n     * });\n     * ```\n     */\n    upsert(table, data, conflictColumns, options = {}) {\n        // Build filters from conflict columns for PUT auto-conflict\n        const filters = {};\n        for (const col of conflictColumns) {\n            if (col in data) {\n                filters[col] = `eq.${data[col]}`;\n            }\n        }\n        const queryString = buildQueryString(filters, {\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseRequest(\"PUT\", table, queryString, JSON.stringify(data), headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an UPDATE query\n     *\n     * @param table - Table name\n     * @param data - Data to update\n     * @param filters - Filter conditions to match rows\n     * @param options - Update options (returning, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.update(\"users\", {\n     *   status: \"active\"\n     * }, {\n     *   \"id\": \"eq.123\"\n     * }, {\n     *   returning: \"id,status\"\n     * });\n     * ```\n     */\n    update(table, data, filters, options = {}) {\n        const queryString = buildQueryString(filters, {\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseUpdate(table, JSON.stringify(data), queryString, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate a DELETE query\n     *\n     * @param table - Table name\n     * @param filters - Filter conditions to match rows to delete\n     * @param options - Delete options (returning, prefer)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.delete(\"users\", {\n     *   \"status\": \"eq.inactive\",\n     *   \"last_login\": \"lt.2023-01-01\"\n     * }, {\n     *   returning: \"id\"\n     * });\n     * ```\n     */\n    delete(table, filters, options = {}) {\n        const queryString = buildQueryString(filters, {\n            returning: options.returning,\n        });\n        const preferHeader = preferToHeader(options.prefer);\n        const headers = preferHeader\n            ? { Prefer: preferHeader }\n            : undefined;\n        const result = wasmParseDelete(table, queryString, headersToJson(headers));\n        return toQueryResult(result);\n    }\n    /**\n     * Generate an RPC (stored procedure/function) call\n     *\n     * @param functionName - Function name (can include schema)\n     * @param args - Function arguments as object\n     * @param options - RPC options (select, filters, ordering)\n     * @returns Query result with SQL, params, and tables\n     *\n     * @example\n     * ```typescript\n     * const result = client.rpc(\"calculate_total\", {\n     *   order_id: 123,\n     *   tax_rate: 0.08\n     * }, {\n     *   select: [\"total\", \"tax\"],\n     *   limit: 1\n     * });\n     * ```\n     */\n    rpc(functionName, args = {}, options = {}) {\n        const queryString = buildQueryString(options.filters, options);\n        const result = wasmParseRpc(functionName, JSON.stringify(args), queryString || undefined, undefined);\n        return toQueryResult(result);\n    }\n    /**\n     * Parse a query string without generating SQL\n     *\n     * Useful for inspecting the parsed structure before generating SQL.\n     *\n     * @param queryString - PostgREST query string\n     * @returns Parsed query parameters as object\n     *\n     * @example\n     * ```typescript\n     * const parsed = client.parseOnly(\"age=gte.18&status=eq.active&order=created_at.desc\");\n     * console.log(parsed); // { filters: [...], order: [...] }\n     * ```\n     */\n    parseOnly(queryString) {\n        return wasmParseOnly(queryString);\n    }\n    /**\n     * Build a WHERE clause from filter conditions\n     *\n     * @param filters - Filter conditions as object\n     * @returns Object with clause (SQL string) and params (array of values)\n     *\n     * @example\n     * ```typescript\n     * const filters = [\n     *   { column: \"age\", operator: \"gte\", value: \"18\" },\n     *   { column: \"status\", operator: \"eq\", value: \"active\" }\n     * ];\n     * const result = client.buildFilterClause(filters);\n     * console.log(result.clause); // \"age >= $1 AND status = $2\"\n     * console.log(result.params);  // [\"18\", \"active\"]\n     * ```\n     */\n    buildFilterClause(filters) {\n        return wasmBuildFilterClause(filters);\n    }\n}\n/**\n * Create a new PostgREST Parser client instance\n *\n * @returns New PostgRESTParser instance\n *\n * @example\n * ```typescript\n * import { createClient } from './pkg/client.js';\n *\n * const client = createClient();\n * const result = client.select(\"users\", { limit: 10 });\n * ```\n */\nexport function createClient() {\n    return new PostgRESTParser();\n}\n", "/**\n * PostgREST Query Parser Wrapper\n * Uses native_postgrest_parser WASM to convert PostgREST queries to SQL\n */\n\nimport init, { initSchemaFromDb } from 'native_postgrest_parser/pkg/postgrest_parser.js'\nimport { createClient } from 'native_postgrest_parser/pkg/client.js'\nimport type { QueryResult as ParserQueryResult } from 'native_postgrest_parser/pkg/types.js'\n\n/**\n * Query executor function type for schema introspection\n */\nexport type QueryExecutor = (sql: string) => Promise<{ rows: unknown[] }>\n\n/**\n * Parsed SQL query with parameters\n */\nexport interface ParsedQuery {\n  readonly sql: string\n  readonly params: readonly unknown[]\n  readonly tables: readonly string[]\n}\n\n/**\n * PostgREST parser for converting REST queries to SQL\n */\nexport class PostgrestParser {\n  private readonly client: ReturnType<typeof createClient>\n  private static initPromise: Promise<unknown> | null = null\n\n  constructor() {\n    this.client = createClient()\n  }\n\n  /**\n   * Initialize the WASM module (must be called before first use)\n   * Safe to call multiple times - initialization happens only once\n   *\n   * Note: This uses the web target build which works in webcontainers and edge workers.\n   * For Node.js, the native_postgrest_parser package needs to be built with --target nodejs.\n   */\n  static async init(): Promise<void> {\n    if (!PostgrestParser.initPromise) {\n      PostgrestParser.initPromise = init()\n    }\n    await PostgrestParser.initPromise\n  }\n\n  /**\n   * Initialize schema introspection from a database connection\n   * This enables the parser to validate queries against the actual database schema\n   *\n   * @param queryExecutor - Function that executes SQL queries and returns rows\n   *\n   * @example\n   * ```typescript\n   * import { PGlite } from '@electric-sql/pglite'\n   * import { PostgrestParser } from './postgrest-parser'\n   *\n   * const db = new PGlite()\n   * await PostgrestParser.init()\n   *\n   * // Initialize schema introspection\n   * await PostgrestParser.initSchema(async (sql) => {\n   *   const result = await db.query(sql)\n   *   return { rows: result.rows }\n   * })\n   * ```\n   */\n  static async initSchema(queryExecutor: QueryExecutor): Promise<void> {\n    await PostgrestParser.init()\n    await initSchemaFromDb(queryExecutor)\n  }\n\n  /**\n   * Parse a SELECT query from PostgREST format\n   *\n   * @example\n   * parseSelect('users', 'id=eq.1&select=id,name')\n   * // => { sql: 'SELECT \"id\", \"name\" FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseSelect(table: string, queryString: string = ''): ParsedQuery {\n    return this.parseRequest('GET', table, queryString)\n  }\n\n  /**\n   * Parse an INSERT query from PostgREST format\n   *\n   * @example\n   * parseInsert('users', { name: 'Alice', email: 'alice@example.com' })\n   * // => { sql: 'INSERT INTO \"users\" (\"name\", \"email\") VALUES ($1, $2)', params: ['Alice', 'alice@example.com'] }\n   */\n  parseInsert(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string = ''\n  ): ParsedQuery {\n    return this.parseRequest('POST', table, queryString, data)\n  }\n\n  /**\n   * Parse an UPDATE query from PostgREST format\n   *\n   * @example\n   * parseUpdate('users', { name: 'Alice' }, 'id=eq.1')\n   * // => { sql: 'UPDATE \"users\" SET \"name\" = $1 WHERE \"id\" = $2', params: ['Alice', 1] }\n   */\n  parseUpdate(\n    table: string,\n    data: Record<string, unknown>,\n    queryString: string\n  ): ParsedQuery {\n    return this.parseRequest('PATCH', table, queryString, data)\n  }\n\n  /**\n   * Parse a DELETE query from PostgREST format\n   *\n   * @example\n   * parseDelete('users', 'id=eq.1')\n   * // => { sql: 'DELETE FROM \"users\" WHERE \"id\" = $1', params: [1] }\n   */\n  parseDelete(table: string, queryString: string): ParsedQuery {\n    return this.parseRequest('DELETE', table, queryString)\n  }\n\n  /**\n   * Parse an RPC (function call) from PostgREST format\n   *\n   * @example\n   * parseRpc('calculate_total', { order_id: 123 })\n   * // => { sql: 'SELECT * FROM \"calculate_total\"($1)', params: [123] }\n   */\n  parseRpc(\n    functionName: string,\n    args?: Record<string, unknown>,\n    queryString: string = ''\n  ): ParsedQuery {\n    const path = `rpc/${functionName}`\n    return this.parseRequest('POST', path, queryString, args)\n  }\n\n  /**\n   * Parse a generic HTTP request to SQL\n   *\n   * @param method - HTTP method (GET, POST, PATCH, DELETE)\n   * @param path - Path without leading slash (e.g., 'users' or 'rpc/function_name')\n   * @param queryString - URL query parameters\n   * @param body - Request body (for POST/PATCH)\n   */\n  parseRequest(\n    method: 'GET' | 'POST' | 'PATCH' | 'DELETE',\n    path: string,\n    queryString: string = '',\n    body?: Record<string, unknown>\n  ): ParsedQuery {\n    const result = this.client.parseRequest(method, path, queryString, body ?? null, null)\n    return this.convertResult(result)\n  }\n\n  /**\n   * Convert WASM result to our ParsedQuery format\n   */\n  private convertResult(result: ParserQueryResult): ParsedQuery {\n    return {\n      sql: result.query,\n      params: Array.isArray(result.params) ? result.params : [],\n      tables: Array.isArray(result.tables) ? result.tables : [],\n    }\n  }\n}\n", "/**\n * SQL schema for auth tables (compatible with Supabase auth schema)\n * Uses pgcrypto extension for password hashing (available in PGlite)\n */\n\nexport const AUTH_SCHEMA_SQL = `\n-- Enable pgcrypto extension for password hashing\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n\n-- Create auth schema\nCREATE SCHEMA IF NOT EXISTS auth;\n\n-- Create PostgreSQL roles for RLS\nDO $$\nBEGIN\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'anon') THEN\n    CREATE ROLE anon NOLOGIN NOINHERIT;\n  END IF;\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'authenticated') THEN\n    CREATE ROLE authenticated NOLOGIN NOINHERIT;\n  END IF;\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'service_role') THEN\n    CREATE ROLE service_role NOLOGIN NOINHERIT BYPASSRLS;\n  END IF;\nEND\n$$;\n\n-- Grant necessary permissions to roles\nGRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;\nGRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;\nGRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon, authenticated, service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO anon, authenticated, service_role;\n\n-- Grant service_role full access to auth schema (needed for auth operations)\nGRANT USAGE ON SCHEMA auth TO service_role;\nGRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;\nGRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON TABLES TO service_role;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON SEQUENCES TO service_role;\n\n-- Users table\nCREATE TABLE IF NOT EXISTS auth.users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  instance_id UUID DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,\n  aud VARCHAR(255) DEFAULT 'authenticated',\n  role VARCHAR(255) DEFAULT 'authenticated',\n  email VARCHAR(255) UNIQUE,\n  encrypted_password VARCHAR(255),\n  email_confirmed_at TIMESTAMPTZ,\n  invited_at TIMESTAMPTZ,\n  confirmation_token VARCHAR(255),\n  confirmation_sent_at TIMESTAMPTZ,\n  recovery_token VARCHAR(255),\n  recovery_sent_at TIMESTAMPTZ,\n  email_change_token_new VARCHAR(255),\n  email_change VARCHAR(255),\n  email_change_sent_at TIMESTAMPTZ,\n  last_sign_in_at TIMESTAMPTZ,\n  raw_app_meta_data JSONB DEFAULT '{}'::jsonb,\n  raw_user_meta_data JSONB DEFAULT '{}'::jsonb,\n  is_super_admin BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  phone VARCHAR(255) UNIQUE,\n  phone_confirmed_at TIMESTAMPTZ,\n  phone_change VARCHAR(255),\n  phone_change_token VARCHAR(255),\n  phone_change_sent_at TIMESTAMPTZ,\n  email_change_token_current VARCHAR(255),\n  email_change_confirm_status SMALLINT DEFAULT 0,\n  banned_until TIMESTAMPTZ,\n  reauthentication_token VARCHAR(255),\n  reauthentication_sent_at TIMESTAMPTZ,\n  is_sso_user BOOLEAN DEFAULT FALSE,\n  deleted_at TIMESTAMPTZ,\n  is_anonymous BOOLEAN DEFAULT FALSE\n);\n\n-- Sessions table\nCREATE TABLE IF NOT EXISTS auth.sessions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  factor_id UUID,\n  aal VARCHAR(255) DEFAULT 'aal1',\n  not_after TIMESTAMPTZ,\n  refreshed_at TIMESTAMPTZ,\n  user_agent TEXT,\n  ip INET,\n  tag TEXT\n);\n\n-- Refresh tokens table\nCREATE TABLE IF NOT EXISTS auth.refresh_tokens (\n  id BIGSERIAL PRIMARY KEY,\n  token VARCHAR(255) UNIQUE NOT NULL,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  revoked BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  parent VARCHAR(255),\n  session_id UUID REFERENCES auth.sessions(id) ON DELETE CASCADE\n);\n\n-- Indexes for performance\nCREATE INDEX IF NOT EXISTS users_email_idx ON auth.users(email);\nCREATE INDEX IF NOT EXISTS users_instance_id_idx ON auth.users(instance_id);\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON auth.sessions(user_id);\nCREATE INDEX IF NOT EXISTS sessions_not_after_idx ON auth.sessions(not_after);\nCREATE INDEX IF NOT EXISTS refresh_tokens_token_idx ON auth.refresh_tokens(token);\nCREATE INDEX IF NOT EXISTS refresh_tokens_user_id_idx ON auth.refresh_tokens(user_id);\nCREATE INDEX IF NOT EXISTS refresh_tokens_session_id_idx ON auth.refresh_tokens(session_id);\n\n-- Function to get current user ID (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.uid() RETURNS UUID AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.sub', true), '')::uuid;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get current user role (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.role() RETURNS TEXT AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.role', true), '');\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get current user email (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.email() RETURNS TEXT AS $$\n  SELECT NULLIF(current_setting('request.jwt.claim.email', true), '');\n$$ LANGUAGE SQL STABLE;\n\n-- Function to get JWT claims (for RLS policies)\nCREATE OR REPLACE FUNCTION auth.jwt() RETURNS JSONB AS $$\n  SELECT COALESCE(\n    NULLIF(current_setting('request.jwt.claims', true), ''),\n    '{}'\n  )::jsonb;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to hash a password using pgcrypto\nCREATE OR REPLACE FUNCTION auth.hash_password(password TEXT) RETURNS TEXT AS $$\n  SELECT crypt(password, gen_salt('bf', 10));\n$$ LANGUAGE SQL;\n\n-- Function to verify a password against a hash\nCREATE OR REPLACE FUNCTION auth.verify_password(password TEXT, password_hash TEXT) RETURNS BOOLEAN AS $$\n  SELECT password_hash = crypt(password, password_hash);\n$$ LANGUAGE SQL;\n\n-- Function to generate a secure random token\nCREATE OR REPLACE FUNCTION auth.generate_token(length INT DEFAULT 32) RETURNS TEXT AS $$\n  SELECT encode(gen_random_bytes(length), 'hex');\n$$ LANGUAGE SQL;\n\n-- Function to create a new user with hashed password\nCREATE OR REPLACE FUNCTION auth.create_user(\n  p_email TEXT,\n  p_password TEXT,\n  p_user_metadata JSONB DEFAULT '{}'::jsonb,\n  p_app_metadata JSONB DEFAULT '{}'::jsonb\n) RETURNS auth.users AS $$\nDECLARE\n  v_user auth.users;\nBEGIN\n  INSERT INTO auth.users (\n    email,\n    encrypted_password,\n    email_confirmed_at,\n    raw_user_meta_data,\n    raw_app_meta_data,\n    created_at,\n    updated_at\n  ) VALUES (\n    p_email,\n    auth.hash_password(p_password),\n    NOW(), -- Auto-confirm for local development\n    p_user_metadata,\n    p_app_metadata,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_user;\n\n  RETURN v_user;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify user credentials and return user if valid\nCREATE OR REPLACE FUNCTION auth.verify_user_credentials(\n  p_email TEXT,\n  p_password TEXT\n) RETURNS auth.users AS $$\nDECLARE\n  v_user auth.users;\nBEGIN\n  SELECT * INTO v_user\n  FROM auth.users\n  WHERE email = p_email\n    AND deleted_at IS NULL\n    AND (banned_until IS NULL OR banned_until < NOW());\n\n  IF v_user IS NULL THEN\n    RETURN NULL;\n  END IF;\n\n  IF NOT auth.verify_password(p_password, v_user.encrypted_password) THEN\n    RETURN NULL;\n  END IF;\n\n  -- Update last sign in time\n  UPDATE auth.users\n  SET last_sign_in_at = NOW(), updated_at = NOW()\n  WHERE id = v_user.id;\n\n  RETURN v_user;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to create a session for a user\nCREATE OR REPLACE FUNCTION auth.create_session(\n  p_user_id UUID,\n  p_user_agent TEXT DEFAULT NULL,\n  p_ip TEXT DEFAULT NULL\n) RETURNS auth.sessions AS $$\nDECLARE\n  v_session auth.sessions;\nBEGIN\n  INSERT INTO auth.sessions (\n    user_id,\n    user_agent,\n    ip,\n    created_at,\n    updated_at,\n    refreshed_at\n  ) VALUES (\n    p_user_id,\n    p_user_agent,\n    p_ip::inet,\n    NOW(),\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_session;\n\n  RETURN v_session;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to create a refresh token for a session\nCREATE OR REPLACE FUNCTION auth.create_refresh_token(\n  p_user_id UUID,\n  p_session_id UUID\n) RETURNS auth.refresh_tokens AS $$\nDECLARE\n  v_refresh_token auth.refresh_tokens;\nBEGIN\n  INSERT INTO auth.refresh_tokens (\n    token,\n    user_id,\n    session_id,\n    created_at,\n    updated_at\n  ) VALUES (\n    auth.generate_token(32),\n    p_user_id,\n    p_session_id,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_refresh_token;\n\n  RETURN v_refresh_token;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to refresh a token (revoke old, create new)\nCREATE OR REPLACE FUNCTION auth.refresh_token(\n  p_refresh_token TEXT\n) RETURNS TABLE(\n  new_token TEXT,\n  user_id UUID,\n  session_id UUID\n) AS $$\nDECLARE\n  v_old_token auth.refresh_tokens;\n  v_new_token auth.refresh_tokens;\nBEGIN\n  -- Find and validate the old token\n  SELECT * INTO v_old_token\n  FROM auth.refresh_tokens rt\n  WHERE rt.token = p_refresh_token\n    AND rt.revoked = FALSE;\n\n  IF v_old_token IS NULL THEN\n    RETURN;\n  END IF;\n\n  -- Revoke the old token\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE id = v_old_token.id;\n\n  -- Update session refreshed_at\n  UPDATE auth.sessions\n  SET refreshed_at = NOW(), updated_at = NOW()\n  WHERE id = v_old_token.session_id;\n\n  -- Create new token\n  INSERT INTO auth.refresh_tokens (\n    token,\n    user_id,\n    session_id,\n    parent,\n    created_at,\n    updated_at\n  ) VALUES (\n    auth.generate_token(32),\n    v_old_token.user_id,\n    v_old_token.session_id,\n    v_old_token.token,\n    NOW(),\n    NOW()\n  ) RETURNING * INTO v_new_token;\n\n  RETURN QUERY SELECT v_new_token.token, v_new_token.user_id, v_new_token.session_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to revoke all sessions for a user (sign out)\nCREATE OR REPLACE FUNCTION auth.sign_out(p_session_id UUID) RETURNS VOID AS $$\nBEGIN\n  -- Revoke all refresh tokens for this session\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE session_id = p_session_id;\n\n  -- Delete the session\n  DELETE FROM auth.sessions WHERE id = p_session_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to sign out all sessions for a user\nCREATE OR REPLACE FUNCTION auth.sign_out_all(p_user_id UUID) RETURNS VOID AS $$\nBEGIN\n  -- Revoke all refresh tokens\n  UPDATE auth.refresh_tokens\n  SET revoked = TRUE, updated_at = NOW()\n  WHERE user_id = p_user_id;\n\n  -- Delete all sessions\n  DELETE FROM auth.sessions WHERE user_id = p_user_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Config table for storing signing key\nCREATE TABLE IF NOT EXISTS auth.config (\n  key TEXT PRIMARY KEY,\n  value TEXT NOT NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Function to get or create the signing key\nCREATE OR REPLACE FUNCTION auth.get_signing_key() RETURNS TEXT AS $$\nDECLARE\n  v_key TEXT;\nBEGIN\n  SELECT value INTO v_key FROM auth.config WHERE key = 'jwt_signing_key';\n\n  IF v_key IS NULL THEN\n    v_key := encode(gen_random_bytes(32), 'hex');\n    INSERT INTO auth.config (key, value) VALUES ('jwt_signing_key', v_key);\n  END IF;\n\n  RETURN v_key;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to base64url encode\nCREATE OR REPLACE FUNCTION auth.base64url_encode(data BYTEA) RETURNS TEXT AS $$\n  SELECT replace(replace(rtrim(encode(data, 'base64'), '='), '+', '-'), '/', '_');\n$$ LANGUAGE SQL IMMUTABLE;\n\n-- Function to base64url decode\nCREATE OR REPLACE FUNCTION auth.base64url_decode(data TEXT) RETURNS BYTEA AS $$\nDECLARE\n  v_padded TEXT;\n  v_converted TEXT;\nBEGIN\n  v_converted := replace(replace(data, '-', '+'), '_', '/');\n  v_padded := v_converted || repeat('=', (4 - length(v_converted) % 4) % 4);\n  RETURN decode(v_padded, 'base64');\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE;\n\n-- Function to create an access token (JWT-like structure using HMAC)\nCREATE OR REPLACE FUNCTION auth.create_access_token(\n  p_user_id UUID,\n  p_session_id UUID,\n  p_email TEXT,\n  p_role TEXT DEFAULT 'authenticated',\n  p_user_metadata JSONB DEFAULT '{}'::jsonb,\n  p_app_metadata JSONB DEFAULT '{}'::jsonb,\n  p_expires_in INT DEFAULT 3600\n) RETURNS TEXT AS $$\nDECLARE\n  v_key TEXT;\n  v_now BIGINT;\n  v_exp BIGINT;\n  v_header TEXT;\n  v_payload TEXT;\n  v_header_b64 TEXT;\n  v_payload_b64 TEXT;\n  v_signature_input TEXT;\n  v_signature TEXT;\nBEGIN\n  v_key := auth.get_signing_key();\n  v_now := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  v_exp := v_now + p_expires_in;\n\n  -- Create header\n  v_header := '{\"alg\":\"HS256\",\"typ\":\"JWT\"}';\n  v_header_b64 := auth.base64url_encode(v_header::bytea);\n\n  -- Create payload\n  v_payload := json_build_object(\n    'sub', p_user_id,\n    'aud', 'authenticated',\n    'role', p_role,\n    'email', p_email,\n    'session_id', p_session_id,\n    'iat', v_now,\n    'exp', v_exp,\n    'user_metadata', p_user_metadata,\n    'app_metadata', p_app_metadata\n  )::text;\n  v_payload_b64 := auth.base64url_encode(v_payload::bytea);\n\n  -- Create signature\n  v_signature_input := v_header_b64 || '.' || v_payload_b64;\n  v_signature := auth.base64url_encode(\n    hmac(v_signature_input::bytea, decode(v_key, 'hex'), 'sha256')\n  );\n\n  RETURN v_signature_input || '.' || v_signature;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify an access token and return payload\nCREATE OR REPLACE FUNCTION auth.verify_access_token(p_token TEXT) RETURNS TABLE(\n  valid BOOLEAN,\n  user_id UUID,\n  session_id UUID,\n  email TEXT,\n  role TEXT,\n  exp BIGINT,\n  user_metadata JSONB,\n  app_metadata JSONB,\n  error TEXT\n) AS $$\nDECLARE\n  v_parts TEXT[];\n  v_header_b64 TEXT;\n  v_payload_b64 TEXT;\n  v_signature_b64 TEXT;\n  v_key TEXT;\n  v_signature_input TEXT;\n  v_expected_sig TEXT;\n  v_payload JSONB;\n  v_now BIGINT;\nBEGIN\n  -- Split token into parts\n  v_parts := string_to_array(p_token, '.');\n\n  IF array_length(v_parts, 1) != 3 THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid token format'::TEXT;\n    RETURN;\n  END IF;\n\n  v_header_b64 := v_parts[1];\n  v_payload_b64 := v_parts[2];\n  v_signature_b64 := v_parts[3];\n\n  -- Verify signature\n  v_key := auth.get_signing_key();\n  v_signature_input := v_header_b64 || '.' || v_payload_b64;\n  v_expected_sig := auth.base64url_encode(\n    hmac(v_signature_input::bytea, decode(v_key, 'hex'), 'sha256')\n  );\n\n  IF v_signature_b64 != v_expected_sig THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid signature'::TEXT;\n    RETURN;\n  END IF;\n\n  -- Decode payload\n  BEGIN\n    v_payload := convert_from(auth.base64url_decode(v_payload_b64), 'UTF8')::jsonb;\n  EXCEPTION WHEN OTHERS THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Invalid payload'::TEXT;\n    RETURN;\n  END;\n\n  -- Check expiration\n  v_now := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  IF (v_payload->>'exp')::BIGINT < v_now THEN\n    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::BIGINT, NULL::JSONB, NULL::JSONB, 'Token expired'::TEXT;\n    RETURN;\n  END IF;\n\n  -- Return valid token data\n  RETURN QUERY SELECT\n    true,\n    (v_payload->>'sub')::UUID,\n    (v_payload->>'session_id')::UUID,\n    v_payload->>'email',\n    v_payload->>'role',\n    (v_payload->>'exp')::BIGINT,\n    COALESCE(v_payload->'user_metadata', '{}'::jsonb),\n    COALESCE(v_payload->'app_metadata', '{}'::jsonb),\n    NULL::TEXT;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Grant execute permissions on auth schema functions to roles\n-- This allows RLS policies and DEFAULT values to use these functions\nGRANT USAGE ON SCHEMA auth TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.uid() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.role() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.email() TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.jwt() TO anon, authenticated, service_role;\n\n-- Grant execute on auth management functions\n-- These have SECURITY DEFINER so they run with elevated privileges\nGRANT EXECUTE ON FUNCTION auth.create_user(TEXT, TEXT, JSONB, JSONB) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.verify_user_credentials(TEXT, TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_session(UUID, TEXT, TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.create_refresh_token(UUID, UUID) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.refresh_token(TEXT) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.sign_out(UUID) TO anon, authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.sign_out_all(UUID) TO authenticated, service_role;\nGRANT EXECUTE ON FUNCTION auth.get_signing_key() TO service_role;\nGRANT EXECUTE ON FUNCTION auth.create_access_token(UUID, UUID, TEXT, TEXT, JSONB, JSONB, INT) TO service_role;\nGRANT EXECUTE ON FUNCTION auth.verify_access_token(TEXT) TO service_role;\n`\n\n/**\n * Escape single quotes for SQL string literals\n */\nfunction escapeSqlString(value: string): string {\n  return value.replace(/'/g, \"''\")\n}\n\n/**\n * SQL to set auth context for a request (called before each query when authenticated)\n */\nexport function getSetAuthContextSQL(userId: string, role: string, email: string): string {\n  const claims = JSON.stringify({\n    sub: userId,\n    role: role,\n    email: email,\n    aud: 'authenticated',\n  })\n\n  // Properly escape all values for SQL\n  const escapedUserId = escapeSqlString(userId)\n  const escapedRole = escapeSqlString(role)\n  const escapedEmail = escapeSqlString(email)\n  const escapedClaims = escapeSqlString(claims)\n\n  // IMPORTANT: SET ROLE switches the database role to enforce RLS\n  // Without this, queries run as superuser which bypasses RLS entirely\n  // Note: Using SET ROLE (not SET LOCAL ROLE) because each db call may be in a separate transaction\n  return `\n    SET ROLE ${escapedRole};\n    SELECT set_config('request.jwt.claim.sub', '${escapedUserId}', false);\n    SELECT set_config('request.jwt.claim.role', '${escapedRole}', false);\n    SELECT set_config('request.jwt.claim.email', '${escapedEmail}', false);\n    SELECT set_config('request.jwt.claims', '${escapedClaims}', false);\n  `\n}\n\n/**\n * SQL to clear auth context (for anonymous/unauthenticated requests)\n */\nexport const CLEAR_AUTH_CONTEXT_SQL = `\n  SET ROLE anon;\n  SELECT set_config('request.jwt.claim.sub', '', false);\n  SELECT set_config('request.jwt.claim.role', 'anon', false);\n  SELECT set_config('request.jwt.claim.email', '', false);\n  SELECT set_config('request.jwt.claims', '{\"role\": \"anon\"}', false);\n`\n", "/**\n * JWT utilities using Web Crypto API\n * Compatible with: Browser, Cloudflare Workers, Deno, Bun\n */\n\n/**\n * Base64URL encode (no padding)\n */\nfunction base64UrlEncode(data: Uint8Array): string {\n  const base64 = btoa(String.fromCharCode(...data))\n  return base64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n}\n\n/**\n * Base64URL decode\n */\nfunction base64UrlDecode(str: string): Uint8Array<ArrayBuffer> {\n  const base64 = str\n    .replace(/-/g, '+')\n    .replace(/_/g, '/')\n    .padEnd(str.length + ((4 - (str.length % 4)) % 4), '=')\n\n  const binary = atob(base64)\n  const bytes = new Uint8Array(binary.length)\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * Text encoder/decoder (available in all modern runtimes)\n */\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\n/**\n * JWT payload structure\n */\nexport interface JWTPayload {\n  sub: string           // user ID\n  aud: string           // audience ('authenticated')\n  role: string          // user role\n  email?: string        // user email\n  session_id: string    // session ID\n  iat: number           // issued at (seconds)\n  exp: number           // expires at (seconds)\n  user_metadata: Record<string, unknown>\n  app_metadata: Record<string, unknown>\n}\n\n/**\n * Sign a JWT using HMAC-SHA256 (Web Crypto API)\n */\nexport async function signJWT(\n  payload: JWTPayload,\n  secret: string\n): Promise<string> {\n  // Create header\n  const header = {\n    alg: 'HS256',\n    typ: 'JWT'\n  }\n\n  // Encode header and payload\n  const headerB64 = base64UrlEncode(encoder.encode(JSON.stringify(header)))\n  const payloadB64 = base64UrlEncode(encoder.encode(JSON.stringify(payload)))\n  const data = `${headerB64}.${payloadB64}`\n\n  // Sign with HMAC-SHA256\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign']\n  )\n\n  const signature = await crypto.subtle.sign(\n    'HMAC',\n    key,\n    encoder.encode(data)\n  )\n\n  const signatureB64 = base64UrlEncode(new Uint8Array(signature))\n\n  return `${data}.${signatureB64}`\n}\n\n/**\n * Verify a JWT signature using HMAC-SHA256 (Web Crypto API)\n */\nexport async function verifyJWT(\n  token: string,\n  secret: string\n): Promise<{\n  valid: boolean\n  payload?: JWTPayload\n  error?: string\n}> {\n  try {\n    const parts = token.split('.')\n    if (parts.length !== 3) {\n      return { valid: false, error: 'Invalid token format' }\n    }\n\n    const [headerB64, payloadB64, signatureB64] = parts\n\n    if (!headerB64 || !payloadB64 || !signatureB64) {\n      return { valid: false, error: 'Invalid token format' }\n    }\n\n    const data = `${headerB64}.${payloadB64}`\n\n    // Verify signature\n    const key = await crypto.subtle.importKey(\n      'raw',\n      encoder.encode(secret),\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['verify']\n    )\n\n    const signature = base64UrlDecode(signatureB64)\n    const isValid = await crypto.subtle.verify(\n      'HMAC',\n      key,\n      signature,\n      encoder.encode(data)\n    )\n\n    if (!isValid) {\n      return { valid: false, error: 'Invalid signature' }\n    }\n\n    // Decode payload\n    const payloadJson = decoder.decode(base64UrlDecode(payloadB64))\n    const payload = JSON.parse(payloadJson) as JWTPayload\n\n    // Check expiration\n    const now = Math.floor(Date.now() / 1000)\n    if (payload.exp && payload.exp < now) {\n      return { valid: false, error: 'Token expired' }\n    }\n\n    return { valid: true, payload }\n  } catch (err) {\n    return {\n      valid: false,\n      error: err instanceof Error ? err.message : 'Verification failed'\n    }\n  }\n}\n\n/**\n * Decode JWT payload without verification (for quick checks)\n */\nexport function decodeJWT(token: string): JWTPayload | null {\n  try {\n    const parts = token.split('.')\n    if (parts.length !== 3) return null\n\n    const payloadB64 = parts[1]\n    if (!payloadB64) return null\n\n    const payloadJson = decoder.decode(base64UrlDecode(payloadB64))\n    return JSON.parse(payloadJson) as JWTPayload\n  } catch {\n    return null\n  }\n}\n", "/**\n * Crypto utilities for auth tokens\n * Uses Web Crypto API for JWT operations (browser/edge runtime compatible)\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport type { User, TokenPair } from './types.ts'\nimport { signJWT, verifyJWT, decodeJWT, type JWTPayload } from './jwt.ts'\n\n// Default token expiry: 1 hour (in seconds)\nconst DEFAULT_ACCESS_TOKEN_EXPIRY = 3600\n\n// JWT secret key (in production, this should come from environment)\n// For now, we'll store it in the database and retrieve it\nlet cachedSecret: string | null = null\n\n/**\n * Get or create JWT secret from database\n */\nasync function getJWTSecret(db: PGlite): Promise<string> {\n  if (cachedSecret) return cachedSecret\n\n  // Get or create secret from database\n  const result = await db.query<{ value: string }>(\n    `SELECT value FROM auth.config WHERE key = 'jwt_secret'`\n  )\n\n  if (result.rows.length > 0 && result.rows[0]) {\n    cachedSecret = result.rows[0].value\n    return cachedSecret\n  }\n\n  // Generate new secret (256-bit random hex string)\n  const bytes = new Uint8Array(32)\n  crypto.getRandomValues(bytes)\n  const secret = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('')\n\n  await db.exec(`\n    INSERT INTO auth.config (key, value)\n    VALUES ('jwt_secret', '${secret}')\n    ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value\n  `)\n\n  cachedSecret = secret\n  return secret\n}\n\n/**\n * Create an access token using Web Crypto API\n */\nexport async function createAccessToken(\n  db: PGlite,\n  user: User,\n  sessionId: string,\n  expiresIn: number = DEFAULT_ACCESS_TOKEN_EXPIRY\n): Promise<string> {\n  const secret = await getJWTSecret(db)\n  const now = Math.floor(Date.now() / 1000)\n\n  const payload: JWTPayload = {\n    sub: user.id,\n    aud: 'authenticated',\n    role: user.role,\n    email: user.email || undefined,\n    session_id: sessionId,\n    iat: now,\n    exp: now + expiresIn,\n    user_metadata: user.user_metadata || {},\n    app_metadata: user.app_metadata || {},\n  }\n\n  return signJWT(payload, secret)\n}\n\n/**\n * Verify and decode an access token using Web Crypto API\n */\nexport async function verifyAccessToken(\n  db: PGlite,\n  token: string\n): Promise<{\n  valid: boolean\n  payload?: {\n    sub: string\n    aud: string\n    role: string\n    email?: string\n    session_id: string\n    iat: number\n    exp: number\n    user_metadata: Record<string, unknown>\n    app_metadata: Record<string, unknown>\n  }\n  error?: string\n}> {\n  const secret = await getJWTSecret(db)\n  return verifyJWT(token, secret)\n}\n\n/**\n * Generate a token pair (access + refresh) for a user session\n */\nexport async function generateTokenPair(\n  db: PGlite,\n  user: User,\n  sessionId: string,\n  refreshToken: string,\n  expiresIn: number = DEFAULT_ACCESS_TOKEN_EXPIRY\n): Promise<TokenPair> {\n  const accessToken = await createAccessToken(db, user, sessionId, expiresIn)\n  const now = Math.floor(Date.now() / 1000)\n\n  return {\n    accessToken,\n    refreshToken,\n    expiresIn,\n    expiresAt: now + expiresIn,\n  }\n}\n\n/**\n * Extract user ID from access token without full verification\n * (useful for quick checks, but should verify for security-sensitive operations)\n */\nexport function extractUserIdFromToken(token: string): string | null {\n  const payload = decodeJWT(token)\n  return payload?.sub || null\n}\n\n/**\n * Extract session ID from access token without full verification\n */\nexport function extractSessionIdFromToken(token: string): string | null {\n  const payload = decodeJWT(token)\n  return payload?.session_id || null\n}\n", "/**\n * Auth handler - processes auth requests and manages auth state\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport type {\n  User,\n  Session,\n  AuthResponse,\n  AuthError,\n  AuthChangeEvent,\n  AuthStateChangeCallback,\n  AuthSubscription,\n  StoredUser,\n  StoredSession,\n  StoredRefreshToken,\n} from './types.ts'\nimport { AUTH_SCHEMA_SQL } from './schema.ts'\nimport {\n  createAccessToken,\n  verifyAccessToken,\n  extractSessionIdFromToken,\n} from './crypto.ts'\n\n// Default access token expiry: 1 hour\nconst ACCESS_TOKEN_EXPIRY = 3600\n\n/**\n * Convert stored user to public user format\n */\nfunction toPublicUser(storedUser: StoredUser): User {\n  return {\n    id: storedUser.id,\n    aud: storedUser.aud,\n    role: storedUser.role,\n    email: storedUser.email,\n    email_confirmed_at: storedUser.email_confirmed_at || undefined,\n    phone: storedUser.phone || undefined,\n    phone_confirmed_at: storedUser.phone_confirmed_at || undefined,\n    confirmed_at: storedUser.email_confirmed_at || storedUser.phone_confirmed_at || undefined,\n    last_sign_in_at: storedUser.last_sign_in_at || undefined,\n    app_metadata: storedUser.raw_app_meta_data || {},\n    user_metadata: storedUser.raw_user_meta_data || {},\n    created_at: storedUser.created_at,\n    updated_at: storedUser.updated_at,\n  }\n}\n\n/**\n * Create auth error response\n */\nfunction authError(message: string, status: number, code?: string): AuthError {\n  return { message, status, code }\n}\n\n/**\n * Auth handler class\n */\nexport class AuthHandler {\n  private db: PGlite\n  private initialized = false\n  private subscriptions = new Map<string, AuthStateChangeCallback>()\n  private currentSession: Session | null = null\n\n  constructor(db: PGlite) {\n    this.db = db\n  }\n\n  /**\n   * Initialize auth schema in the database\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return\n    }\n\n    await this.db.exec(AUTH_SCHEMA_SQL)\n    this.initialized = true\n  }\n\n  /**\n   * Emit auth state change to all subscribers\n   */\n  private emitAuthStateChange(event: AuthChangeEvent, session: Session | null): void {\n    this.currentSession = session\n    for (const callback of this.subscriptions.values()) {\n      try {\n        callback(event, session)\n      } catch (err) {\n        console.error('Auth state change callback error:', err)\n      }\n    }\n  }\n\n  /**\n   * Subscribe to auth state changes\n   */\n  onAuthStateChange(callback: AuthStateChangeCallback): AuthSubscription {\n    const id = crypto.randomUUID()\n    this.subscriptions.set(id, callback)\n\n    // Emit initial session state\n    setTimeout(() => {\n      callback('INITIAL_SESSION', this.currentSession)\n    }, 0)\n\n    return {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.subscriptions.delete(id)\n      },\n    }\n  }\n\n  /**\n   * Sign up a new user\n   */\n  async signUp(\n    email: string,\n    password: string,\n    options?: { data?: Record<string, unknown> }\n  ): Promise<AuthResponse> {\n    await this.initialize()\n\n    // Reset role to default before auth operation\n    await this.db.exec('RESET ROLE')\n\n    try {\n      // Check if user already exists\n      const existingUser = await this.db.query<StoredUser>(\n        'SELECT * FROM auth.users WHERE email = $1',\n        [email]\n      )\n\n      if (existingUser.rows.length > 0) {\n        return {\n          data: { user: null, session: null },\n          error: authError('User already registered', 400, 'user_already_exists'),\n        }\n      }\n\n      // Create user using database function\n      const userMetadata = options?.data ? JSON.stringify(options.data) : '{}'\n      const result = await this.db.query<StoredUser>(\n        `SELECT * FROM auth.create_user($1, $2, $3::jsonb)`,\n        [email, password, userMetadata]\n      )\n\n      if (result.rows.length === 0) {\n        return {\n          data: { user: null, session: null },\n          error: authError('Failed to create user', 500, 'user_creation_failed'),\n        }\n      }\n\n      const storedUser = result.rows[0]\n      if (!storedUser) {\n        return {\n          data: { user: null, session: null },\n          error: authError('Failed to create user', 500, 'user_creation_failed'),\n        }\n      }\n      const user = toPublicUser(storedUser)\n\n      // Create session\n      const session = await this.createSession(storedUser)\n\n      this.emitAuthStateChange('SIGNED_IN', session)\n\n      return {\n        data: { user, session },\n        error: null,\n      }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Sign up failed'\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, 'sign_up_failed'),\n      }\n    }\n  }\n\n  /**\n   * Sign in with email and password\n   */\n  async signInWithPassword(\n    email: string,\n    password: string\n  ): Promise<AuthResponse> {\n    await this.initialize()\n\n    // Reset role to default before auth operation\n    await this.db.exec('RESET ROLE')\n\n    try {\n      // Verify credentials using database function\n      const result = await this.db.query<StoredUser>(\n        'SELECT * FROM auth.verify_user_credentials($1, $2)',\n        [email, password]\n      )\n\n      const storedUser = result.rows[0]\n      if (!storedUser || !storedUser.id) {\n        return {\n          data: { user: null, session: null },\n          error: authError('Invalid login credentials', 400, 'invalid_credentials'),\n        }\n      }\n\n      const user = toPublicUser(storedUser)\n\n      // Create session\n      const session = await this.createSession(storedUser)\n\n      this.emitAuthStateChange('SIGNED_IN', session)\n\n      return {\n        data: { user, session },\n        error: null,\n      }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Sign in failed'\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, 'sign_in_failed'),\n      }\n    }\n  }\n\n  /**\n   * Create a session for a user\n   */\n  private async createSession(storedUser: StoredUser): Promise<Session> {\n    // Create session in database\n    const sessionResult = await this.db.query<StoredSession>(\n      'SELECT * FROM auth.create_session($1)',\n      [storedUser.id]\n    )\n    const session = sessionResult.rows[0]\n    if (!session) {\n      throw new Error('Failed to create session')\n    }\n\n    // Create refresh token in database\n    const refreshResult = await this.db.query<StoredRefreshToken>(\n      'SELECT * FROM auth.create_refresh_token($1, $2)',\n      [storedUser.id, session.id]\n    )\n    const refreshToken = refreshResult.rows[0]\n    if (!refreshToken) {\n      throw new Error('Failed to create refresh token')\n    }\n\n    const user = toPublicUser(storedUser)\n\n    // Generate access token\n    const accessToken = await createAccessToken(this.db, user, session.id, ACCESS_TOKEN_EXPIRY)\n\n    return {\n      access_token: accessToken,\n      token_type: 'bearer',\n      expires_in: ACCESS_TOKEN_EXPIRY,\n      expires_at: Math.floor(Date.now() / 1000) + ACCESS_TOKEN_EXPIRY,\n      refresh_token: refreshToken.token,\n      user,\n    }\n  }\n\n  /**\n   * Refresh the session using a refresh token\n   */\n  async refreshSession(refreshToken: string): Promise<AuthResponse> {\n    await this.initialize()\n\n    try {\n      // Use database function to refresh token\n      const result = await this.db.query<{\n        new_token: string\n        user_id: string\n        session_id: string\n      }>('SELECT * FROM auth.refresh_token($1)', [refreshToken])\n\n      const tokenResult = result.rows[0]\n      if (!tokenResult || !tokenResult.new_token) {\n        return {\n          data: { user: null, session: null },\n          error: authError('Invalid refresh token', 401, 'invalid_refresh_token'),\n        }\n      }\n\n      const { new_token, user_id, session_id } = tokenResult\n\n      // Get user\n      const userResult = await this.db.query<StoredUser>(\n        'SELECT * FROM auth.users WHERE id = $1',\n        [user_id]\n      )\n\n      const storedUser = userResult.rows[0]\n      if (!storedUser) {\n        return {\n          data: { user: null, session: null },\n          error: authError('User not found', 404, 'user_not_found'),\n        }\n      }\n\n      const user = toPublicUser(storedUser)\n\n      // Generate new access token\n      const accessToken = await createAccessToken(this.db, user, session_id, ACCESS_TOKEN_EXPIRY)\n\n      const session: Session = {\n        access_token: accessToken,\n        token_type: 'bearer',\n        expires_in: ACCESS_TOKEN_EXPIRY,\n        expires_at: Math.floor(Date.now() / 1000) + ACCESS_TOKEN_EXPIRY,\n        refresh_token: new_token,\n        user,\n      }\n\n      this.emitAuthStateChange('TOKEN_REFRESHED', session)\n\n      return {\n        data: { user, session },\n        error: null,\n      }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Token refresh failed'\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, 'refresh_failed'),\n      }\n    }\n  }\n\n  /**\n   * Sign out the current session\n   */\n  async signOut(accessToken?: string): Promise<{ error: AuthError | null }> {\n    await this.initialize()\n\n    try {\n      if (accessToken) {\n        const sessionId = extractSessionIdFromToken(accessToken)\n        if (sessionId) {\n          await this.db.query('SELECT auth.sign_out($1::uuid)', [sessionId])\n        }\n      }\n\n      // Reset role to default after sign out\n      await this.db.exec('RESET ROLE')\n\n      this.emitAuthStateChange('SIGNED_OUT', null)\n      return { error: null }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Sign out failed'\n      return { error: authError(message, 500, 'sign_out_failed') }\n    }\n  }\n\n  /**\n   * Get user from access token\n   */\n  async getUser(accessToken: string): Promise<{\n    data: { user: User | null }\n    error: AuthError | null\n  }> {\n    await this.initialize()\n\n    try {\n      const verified = await verifyAccessToken(this.db, accessToken)\n\n      if (!verified.valid || !verified.payload) {\n        return {\n          data: { user: null },\n          error: authError(verified.error || 'Invalid token', 401, 'invalid_token'),\n        }\n      }\n\n      // Get fresh user data from database\n      const result = await this.db.query<StoredUser>(\n        'SELECT * FROM auth.users WHERE id = $1',\n        [verified.payload.sub]\n      )\n\n      const storedUser = result.rows[0]\n      if (!storedUser) {\n        return {\n          data: { user: null },\n          error: authError('User not found', 404, 'user_not_found'),\n        }\n      }\n\n      return {\n        data: { user: toPublicUser(storedUser) },\n        error: null,\n      }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Get user failed'\n      return {\n        data: { user: null },\n        error: authError(message, 500, 'get_user_failed'),\n      }\n    }\n  }\n\n  /**\n   * Update user data\n   */\n  async updateUser(\n    accessToken: string,\n    attributes: {\n      email?: string\n      password?: string\n      data?: Record<string, unknown>\n    }\n  ): Promise<AuthResponse> {\n    await this.initialize()\n\n    try {\n      const verified = await verifyAccessToken(this.db, accessToken)\n\n      if (!verified.valid || !verified.payload) {\n        return {\n          data: { user: null, session: null },\n          error: authError(verified.error || 'Invalid token', 401, 'invalid_token'),\n        }\n      }\n\n      const userId = verified.payload.sub\n      const updates: string[] = []\n      const params: unknown[] = []\n      let paramIndex = 1\n\n      if (attributes.email) {\n        updates.push(`email = $${paramIndex}`)\n        params.push(attributes.email)\n        paramIndex++\n      }\n\n      if (attributes.password) {\n        updates.push(`encrypted_password = auth.hash_password($${paramIndex})`)\n        params.push(attributes.password)\n        paramIndex++\n      }\n\n      if (attributes.data) {\n        updates.push(`raw_user_meta_data = raw_user_meta_data || $${paramIndex}::jsonb`)\n        params.push(JSON.stringify(attributes.data))\n        paramIndex++\n      }\n\n      if (updates.length === 0) {\n        // No updates, just return current user\n        const result = await this.db.query<StoredUser>(\n          'SELECT * FROM auth.users WHERE id = $1',\n          [userId]\n        )\n        const storedUser = result.rows[0]\n        if (!storedUser) {\n          return {\n            data: { user: null, session: null },\n            error: authError('User not found', 404, 'user_not_found'),\n          }\n        }\n        return {\n          data: { user: toPublicUser(storedUser), session: this.currentSession },\n          error: null,\n        }\n      }\n\n      updates.push('updated_at = NOW()')\n      params.push(userId)\n\n      const result = await this.db.query<StoredUser>(\n        `UPDATE auth.users SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\n        params\n      )\n\n      const storedUser = result.rows[0]\n      if (!storedUser) {\n        return {\n          data: { user: null, session: null },\n          error: authError('User not found', 404, 'user_not_found'),\n        }\n      }\n\n      const user = toPublicUser(storedUser)\n\n      // Update session with new user data if we have a current session\n      let session = this.currentSession\n      if (session) {\n        const newAccessToken = await createAccessToken(\n          this.db,\n          user,\n          verified.payload.session_id,\n          ACCESS_TOKEN_EXPIRY\n        )\n        session = {\n          ...session,\n          access_token: newAccessToken,\n          user,\n        }\n      }\n\n      this.emitAuthStateChange('USER_UPDATED', session)\n\n      return {\n        data: { user, session },\n        error: null,\n      }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Update user failed'\n      return {\n        data: { user: null, session: null },\n        error: authError(message, 500, 'update_user_failed'),\n      }\n    }\n  }\n\n  /**\n   * Get current session\n   */\n  getSession(): Session | null {\n    return this.currentSession\n  }\n\n  /**\n   * Set current session (for restoring from storage)\n   */\n  setSession(session: Session | null): void {\n    this.currentSession = session\n    if (session) {\n      this.emitAuthStateChange('SIGNED_IN', session)\n    }\n  }\n\n  /**\n   * Verify access token and return payload\n   */\n  async verifyToken(accessToken: string) {\n    return verifyAccessToken(this.db, accessToken)\n  }\n}\n", "/**\n * Auth routes handler - processes /auth/v1/* requests\n */\n\nimport type { AuthHandler } from '../auth/handler.ts'\n\n/**\n * Create a JSON response\n */\nfunction jsonResponse(data: unknown, status: number = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\n\n/**\n * Extract bearer token from Authorization header\n */\nfunction extractBearerToken(headers: Headers): string | null {\n  const auth = headers.get('Authorization')\n  if (!auth || !auth.startsWith('Bearer ')) {\n    return null\n  }\n  return auth.slice(7)\n}\n\n/**\n * Parse request body as JSON\n */\nasync function parseBody(request: Request): Promise<Record<string, unknown>> {\n  try {\n    const text = await request.text()\n    if (!text) return {}\n    return JSON.parse(text)\n  } catch {\n    return {}\n  }\n}\n\n/**\n * Handle auth routes\n */\nexport async function handleAuthRoute(\n  request: Request,\n  pathname: string,\n  authHandler: AuthHandler\n): Promise<Response> {\n  const method = request.method.toUpperCase()\n  const url = new URL(request.url)\n  const searchParams = url.searchParams\n\n  // POST /auth/v1/signup\n  if (method === 'POST' && pathname === '/auth/v1/signup') {\n    const body = await parseBody(request)\n    const email = body.email as string\n    const password = body.password as string\n    const options = body.options as { data?: Record<string, unknown> } | undefined\n\n    if (!email || !password) {\n      return jsonResponse(\n        { error: 'email and password are required', error_description: 'Missing credentials' },\n        400\n      )\n    }\n\n    const result = await authHandler.signUp(email, password, options)\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status\n      )\n    }\n\n    if (!result.data.session) {\n      return jsonResponse(\n        { error: 'session_creation_failed', error_description: 'Failed to create session' },\n        500\n      )\n    }\n\n    // Return token response format (same as sign in)\n    return jsonResponse({\n      access_token: result.data.session.access_token,\n      token_type: 'bearer',\n      expires_in: result.data.session.expires_in,\n      expires_at: result.data.session.expires_at,\n      refresh_token: result.data.session.refresh_token,\n      user: result.data.user,\n    })\n  }\n\n  // POST /auth/v1/token?grant_type=password (sign in)\n  if (method === 'POST' && pathname === '/auth/v1/token') {\n    const grantType = searchParams.get('grant_type')\n\n    if (grantType === 'password') {\n      const body = await parseBody(request)\n      const email = body.email as string\n      const password = body.password as string\n\n      if (!email || !password) {\n        return jsonResponse(\n          { error: 'invalid_grant', error_description: 'Missing credentials' },\n          400\n        )\n      }\n\n      const result = await authHandler.signInWithPassword(email, password)\n\n      if (result.error) {\n        return jsonResponse(\n          { error: 'invalid_grant', error_description: result.error.message },\n          result.error.status\n        )\n      }\n\n      // Return token response format\n      return jsonResponse({\n        access_token: result.data.session?.access_token,\n        token_type: 'bearer',\n        expires_in: result.data.session?.expires_in,\n        expires_at: result.data.session?.expires_at,\n        refresh_token: result.data.session?.refresh_token,\n        user: result.data.user,\n      })\n    }\n\n    if (grantType === 'refresh_token') {\n      const body = await parseBody(request)\n      const refreshToken = body.refresh_token as string\n\n      if (!refreshToken) {\n        return jsonResponse(\n          { error: 'invalid_grant', error_description: 'Missing refresh token' },\n          400\n        )\n      }\n\n      const result = await authHandler.refreshSession(refreshToken)\n\n      if (result.error) {\n        return jsonResponse(\n          { error: 'invalid_grant', error_description: result.error.message },\n          result.error.status\n        )\n      }\n\n      return jsonResponse({\n        access_token: result.data.session?.access_token,\n        token_type: 'bearer',\n        expires_in: result.data.session?.expires_in,\n        expires_at: result.data.session?.expires_at,\n        refresh_token: result.data.session?.refresh_token,\n        user: result.data.user,\n      })\n    }\n\n    return jsonResponse(\n      { error: 'unsupported_grant_type', error_description: 'Grant type not supported' },\n      400\n    )\n  }\n\n  // POST /auth/v1/logout\n  if (method === 'POST' && pathname === '/auth/v1/logout') {\n    const token = extractBearerToken(request.headers)\n    const result = await authHandler.signOut(token || undefined)\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status\n      )\n    }\n\n    return jsonResponse({})\n  }\n\n  // GET /auth/v1/user\n  if (method === 'GET' && pathname === '/auth/v1/user') {\n    const token = extractBearerToken(request.headers)\n\n    if (!token) {\n      return jsonResponse(\n        { error: 'unauthorized', error_description: 'Missing authorization header' },\n        401\n      )\n    }\n\n    const result = await authHandler.getUser(token)\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status\n      )\n    }\n\n    return jsonResponse(result.data.user)\n  }\n\n  // PUT /auth/v1/user\n  if (method === 'PUT' && pathname === '/auth/v1/user') {\n    const token = extractBearerToken(request.headers)\n\n    if (!token) {\n      return jsonResponse(\n        { error: 'unauthorized', error_description: 'Missing authorization header' },\n        401\n      )\n    }\n\n    const body = await parseBody(request)\n    const result = await authHandler.updateUser(token, {\n      email: body.email as string | undefined,\n      password: body.password as string | undefined,\n      data: body.data as Record<string, unknown> | undefined,\n    })\n\n    if (result.error) {\n      return jsonResponse(\n        { error: result.error.code, error_description: result.error.message },\n        result.error.status\n      )\n    }\n\n    return jsonResponse(result.data.user)\n  }\n\n  // GET /auth/v1/session (get current session)\n  if (method === 'GET' && pathname === '/auth/v1/session') {\n    const token = extractBearerToken(request.headers)\n\n    if (!token) {\n      return jsonResponse({ session: null })\n    }\n\n    const userResult = await authHandler.getUser(token)\n    if (userResult.error) {\n      return jsonResponse({ session: null })\n    }\n\n    const session = authHandler.getSession()\n    return jsonResponse({ session })\n  }\n\n  // Not found\n  return jsonResponse(\n    { error: 'not_found', error_description: 'Auth endpoint not found' },\n    404\n  )\n}\n", "/**\n * Auth context management for RLS policies\n * Handles setting and clearing PostgreSQL session context for authenticated requests\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport { verifyAccessToken } from '../auth/crypto.ts'\nimport { getSetAuthContextSQL, CLEAR_AUTH_CONTEXT_SQL } from '../auth/schema.ts'\n\nexport interface AuthContext {\n  userId?: string\n  role: string\n  email?: string\n}\n\n/**\n * Set auth context for authenticated request\n */\nexport async function setAuthContext(\n  db: PGlite,\n  token: string | null\n): Promise<AuthContext> {\n  if (!token) {\n    await db.exec(CLEAR_AUTH_CONTEXT_SQL)\n    return { role: 'anon' }\n  }\n\n  const verified = await verifyAccessToken(db, token)\n  if (!verified.valid || !verified.payload) {\n    await db.exec(CLEAR_AUTH_CONTEXT_SQL)\n    return { role: 'anon' }\n  }\n\n  const { sub: userId, role, email } = verified.payload\n  const sql = getSetAuthContextSQL(userId, role, email || '')\n  await db.exec(sql)\n\n  return { userId, role, email }\n}\n\n/**\n * Clear auth context (set to anonymous)\n */\nexport async function clearAuthContext(db: PGlite): Promise<void> {\n  await db.exec(CLEAR_AUTH_CONTEXT_SQL)\n}\n", "/**\n * Error handling utilities for API routes\n */\n\nexport interface PostgresError extends Error {\n  detail?: string\n  hint?: string\n  code?: string\n}\n\nexport interface ApiError {\n  message: string\n  code: string\n  details?: string\n  hint?: string\n}\n\n/**\n * Extract PostgreSQL error details\n */\nexport function extractPostgresError(err: unknown): ApiError {\n  if (!(err instanceof Error)) {\n    return {\n      message: 'Unknown error occurred',\n      code: 'PGRST000',\n    }\n  }\n\n  const pgError = err as PostgresError\n  return {\n    message: err.message,\n    code: pgError.code || 'PGRST000',\n    details: pgError.detail,\n    hint: pgError.hint,\n  }\n}\n\n/**\n * Create JSON error response\n */\nexport function errorResponse(err: unknown, status: number = 400): Response {\n  const apiError = extractPostgresError(err)\n  return new Response(JSON.stringify(apiError), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\n", "/**\n * Data routes handler - processes /rest/v1/* requests using PostgREST parser\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport type { PostgrestParser } from '../postgrest-parser.ts'\nimport { setAuthContext } from './auth-context.ts'\nimport { errorResponse } from './error-handler.ts'\n\n/**\n * Create a JSON response\n */\nfunction jsonResponse(data: unknown, status: number = 200, headers: Record<string, string> = {}): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n  })\n}\n\n/**\n * Extract bearer token from Authorization header\n */\nfunction extractBearerToken(headers: Headers): string | null {\n  const auth = headers.get('Authorization')\n  if (!auth || !auth.startsWith('Bearer ')) {\n    return null\n  }\n  return auth.slice(7)\n}\n\n/**\n * Parse request body as JSON\n */\nasync function parseBody(request: Request): Promise<Record<string, unknown> | null> {\n  try {\n    const text = await request.text()\n    if (!text) return null\n    return JSON.parse(text)\n  } catch {\n    return null\n  }\n}\n\n\n/**\n * Handle data routes (PostgREST API)\n */\nexport async function handleDataRoute(\n  request: Request,\n  pathname: string,\n  db: PGlite,\n  parser: PostgrestParser\n): Promise<Response> {\n  const method = request.method.toUpperCase()\n  const url = new URL(request.url)\n\n  // Strip the 'columns' parameter that Supabase JS client adds\n  // The parser should derive columns from the body, not from query params\n  const params = new URLSearchParams(url.search)\n  params.delete('columns')\n  const queryString = params.toString()\n\n  // Extract table/resource from path: /rest/v1/{table}\n  const pathParts = pathname.split('/').filter(Boolean)\n  // pathParts: ['rest', 'v1', 'table'] or ['rest', 'v1', 'rpc', 'function_name']\n  if (pathParts.length < 3) {\n    return jsonResponse(\n      { message: 'Invalid path', code: 'PGRST000' },\n      400\n    )\n  }\n\n  const resourcePath = pathParts.slice(2).join('/') // 'table' or 'rpc/function_name'\n  const token = extractBearerToken(request.headers)\n\n  try {\n    // Set auth context for RLS\n    await setAuthContext(db, token)\n\n    let parsed: { sql: string; params: readonly unknown[] }\n    let body: Record<string, unknown> | null = null\n\n    // Parse body for POST/PATCH/PUT\n    if (['POST', 'PATCH', 'PUT'].includes(method)) {\n      body = await parseBody(request)\n    }\n\n    switch (method) {\n      case 'GET':\n        parsed = parser.parseRequest('GET', resourcePath, queryString)\n        break\n      case 'POST':\n        parsed = parser.parseRequest('POST', resourcePath, queryString, body || undefined)\n        break\n      case 'PATCH':\n        parsed = parser.parseRequest('PATCH', resourcePath, queryString, body || undefined)\n        break\n      case 'PUT':\n        // PUT is typically used for upsert, treat as POST with conflict handling\n        parsed = parser.parseRequest('POST', resourcePath, queryString, body || undefined)\n        break\n      case 'DELETE':\n        parsed = parser.parseRequest('DELETE', resourcePath, queryString)\n        break\n      default:\n        return jsonResponse(\n          { message: 'Method not allowed', code: 'PGRST105' },\n          405\n        )\n    }\n\n    /**\n     * Workaround: Parser quotes asterisk in RETURNING clause\n     * The postgrest_parser incorrectly generates: RETURNING \"*\"\n     * PostgreSQL expects: RETURNING *\n     * TODO: Fix in postgrest_parser upstream\n     */\n    parsed = {\n      sql: parsed.sql.replace(/RETURNING \"\\*\"/g, 'RETURNING *'),\n      params: parsed.params\n    }\n\n    // Execute the actual query with parameters\n    const result = await db.query(parsed.sql, [...parsed.params])\n\n    // Determine response format based on headers\n    const prefer = request.headers.get('Prefer') || ''\n    const returnRepresentation = prefer.includes('return=representation')\n    const returnMinimal = prefer.includes('return=minimal')\n    const countHeader = prefer.includes('count=exact') || prefer.includes('count=planned') || prefer.includes('count=estimated')\n\n    // Build response headers\n    const responseHeaders: Record<string, string> = {}\n\n    if (countHeader) {\n      responseHeaders['Content-Range'] = `0-${result.rows.length - 1}/${result.rows.length}`\n    }\n\n    // Handle different operations\n    if (method === 'GET') {\n      return jsonResponse(result.rows, 200, responseHeaders)\n    }\n\n    if (method === 'POST') {\n      if (returnMinimal) {\n        return new Response(null, { status: 201, headers: responseHeaders })\n      }\n      return jsonResponse(result.rows, 201, responseHeaders)\n    }\n\n    if (method === 'PATCH' || method === 'PUT') {\n      if (returnMinimal) {\n        return new Response(null, { status: 204, headers: responseHeaders })\n      }\n      if (returnRepresentation) {\n        return jsonResponse(result.rows, 200, responseHeaders)\n      }\n      return new Response(null, { status: 204, headers: responseHeaders })\n    }\n\n    if (method === 'DELETE') {\n      if (returnRepresentation) {\n        return jsonResponse(result.rows, 200, responseHeaders)\n      }\n      return new Response(null, { status: 204, headers: responseHeaders })\n    }\n\n    return jsonResponse(result.rows, 200, responseHeaders)\n  } catch (err) {\n    return errorResponse(err)\n  }\n}\n", "/**\n * Scoped Fetch Adapter\n *\n * Creates a custom fetch function that intercepts Supabase API calls:\n * - /auth/v1/* -> Local auth handler\n * - /rest/v1/* -> Local PostgREST parser + PGlite\n * - Everything else -> Passthrough to original fetch\n *\n * This allows using the standard @supabase/supabase-js client with local emulation\n * while still being able to interact with other APIs and Supabase products\n * (Storage, Realtime, Edge Functions, etc.)\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport type { PostgrestParser } from '../postgrest-parser.ts'\nimport type { AuthHandler } from '../auth/handler.ts'\nimport { handleAuthRoute } from './auth-routes.ts'\nimport { handleDataRoute } from './data-routes.ts'\n\nexport interface FetchAdapterConfig {\n  /** The PGlite database instance */\n  db: PGlite\n  /** The PostgREST parser instance */\n  parser: PostgrestParser\n  /** The auth handler instance */\n  authHandler: AuthHandler\n  /** The Supabase URL to intercept (used to match requests) */\n  supabaseUrl: string\n  /**\n   * Original fetch function to use for passthrough requests\n   * Defaults to globalThis.fetch\n   */\n  originalFetch?: typeof fetch\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean\n}\n\n/**\n * Route information extracted from a request\n */\ninterface RouteInfo {\n  /** Whether this request should be intercepted */\n  intercept: boolean\n  /** The route type (auth, data, or passthrough) */\n  type: 'auth' | 'data' | 'passthrough'\n  /** The pathname for intercepted routes */\n  pathname?: string\n}\n\n/**\n * Determine if and how a request should be routed\n */\nfunction getRouteInfo(request: Request, supabaseUrl: string): RouteInfo {\n  const url = new URL(request.url)\n  const supabaseHost = new URL(supabaseUrl).host\n\n  // Only intercept requests to the configured Supabase URL\n  if (url.host !== supabaseHost) {\n    return { intercept: false, type: 'passthrough' }\n  }\n\n  const pathname = url.pathname\n\n  // Auth routes: /auth/v1/*\n  if (pathname.startsWith('/auth/v1/')) {\n    return { intercept: true, type: 'auth', pathname }\n  }\n\n  // Data routes: /rest/v1/*\n  if (pathname.startsWith('/rest/v1/')) {\n    return { intercept: true, type: 'data', pathname }\n  }\n\n  // All other routes pass through (storage, realtime, edge functions, etc.)\n  return { intercept: false, type: 'passthrough' }\n}\n\n/**\n * Create a scoped fetch adapter that intercepts Supabase requests\n *\n * @example\n * ```typescript\n * import { createClient } from '@supabase/supabase-js'\n * import { createLocalFetch } from 'nano-supabase'\n *\n * const db = new PGlite()\n * const { fetch: localFetch, authHandler } = await createLocalFetch({\n *   db,\n *   parser,\n *   authHandler,\n *   supabaseUrl: 'http://localhost:54321',\n * })\n *\n * const supabase = createClient('http://localhost:54321', 'your-anon-key', {\n *   global: { fetch: localFetch }\n * })\n *\n * // Now auth and data calls are handled locally\n * await supabase.auth.signUp({ email: 'user@example.com', password: 'password' })\n * await supabase.from('users').select('*')\n *\n * // Other calls (storage, realtime, etc.) pass through to the network\n * await supabase.storage.from('avatars').upload('avatar.png', file)\n * ```\n */\nexport function createLocalFetch(config: FetchAdapterConfig): typeof fetch {\n  const {\n    db,\n    parser,\n    authHandler,\n    supabaseUrl,\n    originalFetch = globalThis.fetch.bind(globalThis),\n    debug = false,\n  } = config\n\n  const log = debug\n    ? (...args: unknown[]) => console.log('[nano-supabase]', ...args)\n    : () => {}\n\n  return async function localFetch(\n    input: RequestInfo | URL,\n    init?: RequestInit\n  ): Promise<Response> {\n    // Normalize input to Request object\n    const request = input instanceof Request\n      ? input\n      : new Request(input, init)\n\n    const routeInfo = getRouteInfo(request, supabaseUrl)\n\n    if (!routeInfo.intercept) {\n      log('Passthrough:', request.method, request.url)\n      // Pass through to original fetch\n      return originalFetch(input, init)\n    }\n\n    // Log all headers for debugging\n    const authHeader = request.headers.get('Authorization')\n    console.log('\uD83C\uDF10 [FETCH_ADAPTER] Intercepting:', {\n      type: routeInfo.type,\n      method: request.method,\n      pathname: routeInfo.pathname,\n      hasAuth: !!authHeader,\n      authPreview: authHeader ? `${authHeader.slice(0, 30)}...` : 'none'\n    })\n    log('Intercepting:', routeInfo.type, request.method, routeInfo.pathname)\n    log('Authorization header:', authHeader ? `${authHeader.slice(0, 20)}...` : 'none')\n\n    try {\n      let response: Response\n\n      if (routeInfo.type === 'auth' && routeInfo.pathname) {\n        response = await handleAuthRoute(request, routeInfo.pathname, authHandler)\n      } else if (routeInfo.type === 'data' && routeInfo.pathname) {\n        response = await handleDataRoute(request, routeInfo.pathname, db, parser)\n      } else {\n        // Should not reach here, but pass through just in case\n        return originalFetch(input, init)\n      }\n\n      // Log response status\n      log('Response status:', response.status)\n\n      return response\n    } catch (err) {\n      log('Error handling request:', err)\n\n      // Return error response\n      const message = err instanceof Error ? err.message : 'Internal error'\n      return new Response(\n        JSON.stringify({ error: 'internal_error', error_description: message }),\n        {\n          status: 500,\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n    }\n  }\n}\n\nexport { handleAuthRoute } from './auth-routes.ts'\nexport { handleDataRoute } from './data-routes.ts'\n", "/**\n * Local Supabase Client Factory\n *\n * Creates a fully local Supabase client that works with @supabase/supabase-js\n * All auth and data operations are handled in-browser/in-process using PGlite\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport { PostgrestParser } from './postgrest-parser.ts'\nimport { AuthHandler } from './auth/handler.ts'\nimport { createLocalFetch } from './fetch-adapter/index.ts'\n\n/**\n * Generic type for the Supabase client\n * This allows users to pass their own SupabaseClient type\n */\ntype SupabaseJsClient = unknown\n\n/**\n * Configuration for creating a local Supabase client\n */\nexport interface LocalSupabaseClientConfig {\n  /**\n   * The PGlite database instance\n   */\n  db: PGlite\n  /**\n   * URL to use for the local Supabase instance\n   * This should be a fake URL that won't conflict with real requests\n   * Defaults to 'http://localhost:54321'\n   */\n  supabaseUrl?: string\n  /**\n   * Anon key to use (can be any string for local usage)\n   * Defaults to 'local-anon-key'\n   */\n  supabaseAnonKey?: string\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean\n  /**\n   * Original fetch function to use for passthrough requests\n   * Defaults to globalThis.fetch\n   */\n  originalFetch?: typeof fetch\n}\n\n/**\n * Result from creating a local Supabase client\n */\nexport interface LocalSupabaseClientResult<T = SupabaseJsClient> {\n  /**\n   * The Supabase client configured to use local emulation\n   */\n  client: T\n  /**\n   * The auth handler for direct access to auth operations\n   */\n  authHandler: AuthHandler\n  /**\n   * The PostgREST parser for direct SQL parsing\n   */\n  parser: PostgrestParser\n  /**\n   * The custom fetch function (useful for custom integrations)\n   */\n  localFetch: typeof fetch\n}\n\n/**\n * Create a local Supabase client with full auth and data emulation\n *\n * This function initializes PGlite with the auth schema and creates a\n * custom fetch adapter that intercepts Supabase API calls:\n * - /auth/v1/* endpoints are handled by the local auth handler\n * - /rest/v1/* endpoints are parsed and executed against PGlite\n * - All other requests pass through to the original fetch\n *\n * @example\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite'\n * import { createClient } from '@supabase/supabase-js'\n * import { createLocalSupabaseClient } from 'nano-supabase'\n *\n * const db = new PGlite()\n *\n * // Create the local client\n * const { client: supabase, authHandler } = await createLocalSupabaseClient({\n *   db,\n *   createClient, // Pass the createClient function from @supabase/supabase-js\n * })\n *\n * // Use it like a normal Supabase client\n * await supabase.auth.signUp({ email: 'user@example.com', password: 'password' })\n * const { data } = await supabase.from('users').select('*')\n *\n * // Storage, Realtime, and Edge Functions still work via network\n * await supabase.storage.from('avatars').upload('avatar.png', file)\n * ```\n */\nexport async function createLocalSupabaseClient<T = SupabaseJsClient>(\n  config: LocalSupabaseClientConfig,\n  createClient: (url: string, key: string, options?: { global?: { fetch?: typeof fetch } }) => T\n): Promise<LocalSupabaseClientResult<T>> {\n  const {\n    db,\n    supabaseUrl = 'http://localhost:54321',\n    supabaseAnonKey = 'local-anon-key',\n    debug = false,\n    originalFetch,\n  } = config\n\n  // Initialize PostgREST parser\n  await PostgrestParser.init()\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql)\n    return { rows: result.rows }\n  })\n\n  const parser = new PostgrestParser()\n\n  // Initialize auth handler (creates auth schema)\n  const authHandler = new AuthHandler(db)\n  await authHandler.initialize()\n\n  // Create the scoped fetch adapter\n  const localFetch = createLocalFetch({\n    db,\n    parser,\n    authHandler,\n    supabaseUrl,\n    originalFetch,\n    debug,\n  })\n\n  // Create the Supabase client with our custom fetch\n  const client = createClient(supabaseUrl, supabaseAnonKey, {\n    global: { fetch: localFetch },\n  })\n\n  return {\n    client,\n    authHandler,\n    parser,\n    localFetch,\n  }\n}\n\n/**\n * Initialize auth schema in an existing PGlite database\n *\n * Use this if you want to set up auth without creating a full Supabase client\n *\n * @example\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite'\n * import { initializeAuth } from 'nano-supabase'\n *\n * const db = new PGlite()\n * const authHandler = await initializeAuth(db)\n *\n * // Use auth directly\n * const result = await authHandler.signUp('user@example.com', 'password')\n * ```\n */\nexport async function initializeAuth(db: PGlite): Promise<AuthHandler> {\n  const authHandler = new AuthHandler(db)\n  await authHandler.initialize()\n  return authHandler\n}\n\n/**\n * Create only the fetch adapter without a Supabase client\n *\n * Use this for custom integrations where you want to control client creation\n *\n * @example\n * ```typescript\n * import { PGlite } from '@electric-sql/pglite'\n * import { createClient } from '@supabase/supabase-js'\n * import { createFetchAdapter } from 'nano-supabase'\n *\n * const db = new PGlite()\n * const { localFetch, authHandler, parser } = await createFetchAdapter({ db })\n *\n * // Create client yourself\n * const supabase = createClient('http://localhost:54321', 'key', {\n *   global: { fetch: localFetch }\n * })\n * ```\n */\nexport async function createFetchAdapter(config: {\n  db: PGlite\n  supabaseUrl?: string\n  debug?: boolean\n  originalFetch?: typeof fetch\n}): Promise<{\n  localFetch: typeof fetch\n  authHandler: AuthHandler\n  parser: PostgrestParser\n}> {\n  const {\n    db,\n    supabaseUrl = 'http://localhost:54321',\n    debug = false,\n    originalFetch,\n  } = config\n\n  // Initialize PostgREST parser\n  await PostgrestParser.init()\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql)\n    return { rows: result.rows }\n  })\n\n  const parser = new PostgrestParser()\n\n  // Initialize auth handler\n  const authHandler = new AuthHandler(db)\n  await authHandler.initialize()\n\n  // Create the scoped fetch adapter\n  const localFetch = createLocalFetch({\n    db,\n    parser,\n    authHandler,\n    supabaseUrl,\n    originalFetch,\n    debug,\n  })\n\n  return {\n    localFetch,\n    authHandler,\n    parser,\n  }\n}\n", "/**\n * Supabase-compatible client for PGlite\n * Intercepts PostgREST-style API calls and converts them to SQL\n */\n\nimport type { PGlite } from '@electric-sql/pglite'\nimport { PostgrestParser } from './postgrest-parser.ts'\n\n/**\n * Query builder interface compatible with Supabase-js\n */\nexport interface QueryBuilder<T = unknown> {\n  select(columns?: string): QueryBuilder<T>\n  insert(data: Record<string, unknown> | Record<string, unknown>[]): QueryBuilder<T>\n  update(data: Record<string, unknown>): QueryBuilder<T>\n  delete(): QueryBuilder<T>\n  eq(column: string, value: unknown): QueryBuilder<T>\n  neq(column: string, value: unknown): QueryBuilder<T>\n  gt(column: string, value: unknown): QueryBuilder<T>\n  gte(column: string, value: unknown): QueryBuilder<T>\n  lt(column: string, value: unknown): QueryBuilder<T>\n  lte(column: string, value: unknown): QueryBuilder<T>\n  like(column: string, pattern: string): QueryBuilder<T>\n  ilike(column: string, pattern: string): QueryBuilder<T>\n  in(column: string, values: unknown[]): QueryBuilder<T>\n  is(column: string, value: null | boolean): QueryBuilder<T>\n  order(column: string, options?: { ascending?: boolean; nullsFirst?: boolean }): QueryBuilder<T>\n  limit(count: number): QueryBuilder<T>\n  range(from: number, to: number): QueryBuilder<T>\n  single(): QueryBuilder<T>\n  maybeSingle(): QueryBuilder<T>\n  then<TResult>(\n    onfulfilled?: ((value: { data: T | null; error: Error | null }) => TResult) | null\n  ): Promise<TResult>\n}\n\n/**\n * Supabase-compatible database client\n */\nexport class SupabaseClient {\n  private readonly db: PGlite\n  private readonly parser: PostgrestParser\n\n  constructor(db: PGlite, parser: PostgrestParser) {\n    this.db = db\n    this.parser = parser\n  }\n\n  /**\n   * Access a table for querying\n   */\n  from<T = unknown>(table: string): QueryBuilder<T> {\n    return new PostgrestQueryBuilder<T>(this.db, this.parser, table)\n  }\n\n  /**\n   * Call a stored procedure\n   */\n  async rpc<T = unknown>(\n    functionName: string,\n    params?: Record<string, unknown>\n  ): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const parsed = this.parser.parseRpc(functionName, params)\n      const result = await this.db.query(parsed.sql, [...parsed.params])\n      return { data: result.rows as T, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n}\n\n/**\n * Query builder implementation\n */\nclass PostgrestQueryBuilder<T> implements QueryBuilder<T> {\n  private readonly db: PGlite\n  private readonly parser: PostgrestParser\n  private readonly table: string\n  private selectColumns?: string\n  private filters: string[] = []\n  private orderBy?: string\n  private limitCount?: number\n  private offsetCount?: number\n  private insertData?: Record<string, unknown> | Record<string, unknown>[]\n  private updateData?: Record<string, unknown>\n  private isDelete = false\n  private expectSingle = false\n  private expectMaybeSingle = false\n\n  constructor(db: PGlite, parser: PostgrestParser, table: string) {\n    this.db = db\n    this.parser = parser\n    this.table = table\n  }\n\n  select(columns = '*'): QueryBuilder<T> {\n    this.selectColumns = columns\n    return this\n  }\n\n  insert(data: Record<string, unknown> | Record<string, unknown>[]): QueryBuilder<T> {\n    this.insertData = data\n    return this\n  }\n\n  update(data: Record<string, unknown>): QueryBuilder<T> {\n    this.updateData = data\n    return this\n  }\n\n  delete(): QueryBuilder<T> {\n    this.isDelete = true\n    return this\n  }\n\n  eq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=eq.${String(value)}`)\n    return this\n  }\n\n  neq(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=neq.${String(value)}`)\n    return this\n  }\n\n  gt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gt.${String(value)}`)\n    return this\n  }\n\n  gte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=gte.${String(value)}`)\n    return this\n  }\n\n  lt(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lt.${String(value)}`)\n    return this\n  }\n\n  lte(column: string, value: unknown): QueryBuilder<T> {\n    this.filters.push(`${column}=lte.${String(value)}`)\n    return this\n  }\n\n  like(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=like.${pattern}`)\n    return this\n  }\n\n  ilike(column: string, pattern: string): QueryBuilder<T> {\n    this.filters.push(`${column}=ilike.${pattern}`)\n    return this\n  }\n\n  in(column: string, values: unknown[]): QueryBuilder<T> {\n    const joined = values.map(String).join(',')\n    this.filters.push(`${column}=in.(${joined})`)\n    return this\n  }\n\n  is(column: string, value: null | boolean): QueryBuilder<T> {\n    const val = value === null ? 'null' : value ? 'true' : 'false'\n    this.filters.push(`${column}=is.${val}`)\n    return this\n  }\n\n  order(column: string, options?: { ascending?: boolean; nullsFirst?: boolean }): QueryBuilder<T> {\n    const direction = options?.ascending === false ? 'desc' : 'asc'\n    const nulls = options?.nullsFirst ? 'nullsfirst' : 'nullslast'\n    this.orderBy = `${column}.${direction}.${nulls}`\n    return this\n  }\n\n  limit(count: number): QueryBuilder<T> {\n    this.limitCount = count\n    return this\n  }\n\n  range(from: number, to: number): QueryBuilder<T> {\n    this.offsetCount = from\n    this.limitCount = to - from + 1\n    return this\n  }\n\n  single(): QueryBuilder<T> {\n    this.expectSingle = true\n    this.limitCount = 1\n    return this\n  }\n\n  maybeSingle(): QueryBuilder<T> {\n    this.expectMaybeSingle = true\n    this.limitCount = 1\n    return this\n  }\n\n  async then<TResult>(\n    onfulfilled?: ((value: { data: T | null; error: Error | null }) => TResult) | null\n  ): Promise<TResult> {\n    const result = await this.execute()\n    return onfulfilled ? onfulfilled(result) : (result as unknown as TResult)\n  }\n\n  private async execute(): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const queryString = this.buildQueryString()\n\n      let parsed\n      if (this.insertData !== undefined) {\n        const data: Record<string, unknown> = Array.isArray(this.insertData)\n          ? (this.insertData[0] ?? {})\n          : this.insertData\n        parsed = this.parser.parseInsert(this.table, data, queryString)\n      } else if (this.updateData !== undefined) {\n        parsed = this.parser.parseUpdate(this.table, this.updateData, queryString)\n      } else if (this.isDelete) {\n        parsed = this.parser.parseDelete(this.table, queryString)\n      } else {\n        parsed = this.parser.parseSelect(this.table, queryString)\n      }\n\n      const result = await this.db.query(parsed.sql, [...parsed.params])\n\n      if (this.expectSingle && result.rows.length === 0) {\n        throw new Error('No rows returned')\n      }\n\n      if (this.expectSingle && result.rows.length > 1) {\n        throw new Error('Multiple rows returned')\n      }\n\n      const data = this.expectSingle || this.expectMaybeSingle\n        ? (result.rows[0] as T) ?? null\n        : (result.rows as T)\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  private buildQueryString(): string {\n    const parts: string[] = []\n\n    if (this.selectColumns) {\n      parts.push(`select=${this.selectColumns}`)\n    }\n\n    parts.push(...this.filters)\n\n    if (this.orderBy) {\n      parts.push(`order=${this.orderBy}`)\n    }\n\n    if (this.limitCount !== undefined) {\n      parts.push(`limit=${this.limitCount}`)\n    }\n\n    if (this.offsetCount !== undefined) {\n      parts.push(`offset=${this.offsetCount}`)\n    }\n\n    return parts.join('&')\n  }\n}\n\n/**\n * Create a Supabase-compatible client with schema introspection\n */\nexport async function createSupabaseClient(db: PGlite): Promise<SupabaseClient> {\n  await PostgrestParser.init()\n\n  // Initialize schema introspection from the database\n  await PostgrestParser.initSchema(async (sql: string) => {\n    const result = await db.query(sql)\n    return { rows: result.rows }\n  })\n\n  const parser = new PostgrestParser()\n  return new SupabaseClient(db, parser)\n}\n", "import type { QueuedQuery, QueryPriority } from './types.ts'\n\n/**\n * Priority-based queue for managing query execution order\n * Uses separate queues for each priority level\n */\nexport class PriorityQueue {\n  private readonly queues: Map<QueryPriority, QueuedQuery[]>\n  private readonly maxSize: number\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize\n    this.queues = new Map([\n      [0, []], // QueryPriority.CRITICAL\n      [1, []], // QueryPriority.HIGH\n      [2, []], // QueryPriority.MEDIUM\n      [3, []], // QueryPriority.LOW\n    ])\n  }\n\n  /**\n   * Add a query to the appropriate priority queue\n   * @throws {Error} if queue is full\n   */\n  enqueue(query: QueuedQuery): void {\n    const queue = this.queues.get(query.priority)\n    if (!queue) {\n      throw new Error(`Invalid priority: ${query.priority}`)\n    }\n\n    if (this.size() >= this.maxSize) {\n      throw new Error('Queue is full')\n    }\n\n    queue.push(query)\n  }\n\n  /**\n   * Remove and return the highest priority query\n   * Returns null if queue is empty\n   */\n  dequeue(): QueuedQuery | null {\n    // Check queues in priority order (CRITICAL = 0 to LOW = 3)\n    for (const priority of [0, 1, 2, 3] as const) {\n      const queue = this.queues.get(priority)\n      if (queue && queue.length > 0) {\n        return queue.shift() ?? null\n      }\n    }\n    return null\n  }\n\n  /**\n   * Get total number of queued queries across all priorities\n   */\n  size(): number {\n    return Array.from(this.queues.values())\n      .reduce((sum, q) => sum + q.length, 0)\n  }\n\n  /**\n   * Check if queue is empty\n   */\n  isEmpty(): boolean {\n    return this.size() === 0\n  }\n\n  /**\n   * Clear all queued queries\n   */\n  clear(): void {\n    for (const queue of this.queues.values()) {\n      queue.length = 0\n    }\n  }\n}\n", "import type { PGlite } from '@electric-sql/pglite'\n\nimport { PriorityQueue } from './queue.ts'\nimport type { PoolerConfig, QueuedQuery, QueryPriority, QueryResult } from './types.ts'\n\n/**\n * Connection pooler that manages N-to-1 query execution against PGlite\n * Uses a priority queue to order query execution\n */\nexport class PGlitePooler {\n  private readonly db: PGlite\n  private readonly queue: PriorityQueue\n  private running: boolean = false\n  private readonly config: PoolerConfig\n  private sleepTimeoutId: number | null = null\n\n  constructor(db: PGlite, config: Partial<PoolerConfig> = {}) {\n    this.db = db\n    this.queue = new PriorityQueue(config.maxQueueSize ?? 1000)\n    this.config = {\n      maxQueueSize: config.maxQueueSize ?? 1000,\n      defaultTimeout: config.defaultTimeout ?? 5000\n    }\n  }\n\n  /**\n   * Start the queue processor\n   * Begins draining queries from the queue\n   */\n  async start(): Promise<void> {\n    if (this.running) {\n      throw new Error('Pooler already started')\n    }\n    this.running = true\n\n    // Start processing in background\n    // Use setTimeout(0) for cross-runtime compatibility (works in Node.js, Deno, Browser)\n    setTimeout(() => {\n      this.processQueue().catch(err => {\n        console.error('Queue processor error:', err)\n        this.running = false\n      })\n    }, 0)\n\n    // Give the processor a chance to start\n    await new Promise(resolve => setTimeout(resolve, 0))\n  }\n\n  /**\n   * Stop the queue processor\n   * Waits for current query to complete\n   */\n  async stop(): Promise<void> {\n    this.running = false\n\n    // Cancel any pending sleep timer\n    if (this.sleepTimeoutId !== null) {\n      clearTimeout(this.sleepTimeoutId as unknown as number)\n      this.sleepTimeoutId = null\n    }\n\n    // Give time for the background loop to exit\n    await new Promise(r => setTimeout(r, 20))\n  }\n\n  /**\n   * Submit a query to the pool\n   * Returns a promise that resolves when the query completes\n   */\n  async query(\n    sql: string,\n    params?: readonly unknown[],\n    priority: QueryPriority = 2 // MEDIUM\n  ): Promise<QueryResult> {\n    return new Promise((resolve, reject) => {\n      const query: QueuedQuery = {\n        id: crypto.randomUUID(),\n        sql,\n        params: params ?? [],\n        priority,\n        enqueuedAt: Date.now(),\n        resolve,\n        reject,\n        timeoutMs: this.config.defaultTimeout\n      }\n\n      try {\n        this.queue.enqueue(query)\n      } catch (error) {\n        reject(error instanceof Error ? error : new Error(String(error)))\n      }\n    })\n  }\n\n  /**\n   * Background queue processor\n   * Continuously dequeues and executes queries\n   */\n  private async processQueue(): Promise<void> {\n    while (this.running) {\n      const query = this.queue.dequeue()\n\n      if (!query) {\n        // No queries, sleep briefly then check if still running\n        await new Promise(r => {\n          const id = setTimeout(() => {\n            r(null)\n          }, 10)\n          // Store timeout ID so we can cancel it in stop()\n          this.sleepTimeoutId = id as unknown as number\n        })\n        this.sleepTimeoutId = null\n        continue\n      }\n\n      // Execute query with timeout\n      try {\n        const result = await this.executeWithTimeout(query)\n        query.resolve(result)\n      } catch (error) {\n        query.reject(error instanceof Error ? error : new Error(String(error)))\n      }\n    }\n  }\n\n  /**\n   * Execute a query with timeout protection\n   * Note: PGlite.query() already handles exclusive access internally via mutex\n   */\n  private async executeWithTimeout(query: QueuedQuery): Promise<QueryResult> {\n    const timeoutMs = query.timeoutMs ?? this.config.defaultTimeout\n\n    let timeoutId: number | null = null\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error('Query timeout'))\n      }, timeoutMs) as unknown as number\n    })\n\n    // PGlite.query() already uses a mutex internally, no need for runExclusive\n    const queryPromise = this.db.query(query.sql, query.params as unknown[])\n      .finally(() => {\n        // Cancel timeout if query completes\n        if (timeoutId) clearTimeout(timeoutId as unknown as number)\n      })\n\n    return Promise.race([queryPromise, timeoutPromise]) as Promise<QueryResult>\n  }\n}\n", "/**\n * Priority levels for query execution\n * Lower number = higher priority\n */\nexport enum QueryPriority {\n  CRITICAL = 0,\n  HIGH = 1,\n  MEDIUM = 2,\n  LOW = 3,\n}\n\n/**\n * Result from PGlite query execution\n */\nexport interface QueryResult {\n  readonly rows: readonly Record<string, unknown>[]\n  readonly fields?: readonly { name: string; dataTypeID: number }[]\n  readonly affectedRows?: number\n}\n\n/**\n * Query queued for execution\n */\nexport interface QueuedQuery {\n  readonly id: string\n  readonly sql: string\n  readonly params?: readonly unknown[]\n  priority: QueryPriority // Mutable for aging mechanism\n  readonly enqueuedAt: number\n  readonly resolve: (result: QueryResult) => void\n  readonly reject: (error: Error) => void\n  readonly timeoutMs?: number\n}\n\n/**\n * Configuration for the connection pooler\n */\nexport interface PoolerConfig {\n  readonly maxQueueSize: number\n  readonly defaultTimeout: number\n}\n\n/**\n * Queue metrics for monitoring\n */\nexport interface QueueMetrics {\n  readonly totalEnqueued: number\n  readonly totalDequeued: number\n  readonly currentSize: number\n  readonly avgWaitTimeMs: number\n  readonly sizeByPriority: Readonly<Record<QueryPriority, number>>\n}\n"],
  "mappings": "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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,E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",
  "names": ["WasmQueryResult", "_WasmQueryResult", "ptr", "obj", "WasmQueryResultFinalization", "wasm", "ret", "takeObject", "deferred1_0", "deferred1_1", "retptr", "r0", "getDataViewMemory0", "r1", "getStringFromWasm0", "buildFilterClause", "filters_json", "addHeapObject", "r2", "initSchemaFromDb", "query_executor", "parseDelete", "table", "query_string", "headers", "retptr", "wasm", "ptr0", "passStringToWasm0", "len0", "WASM_VECTOR_LEN", "ptr1", "len1", "ptr2", "isLikeNone", "len2", "r0", "getDataViewMemory0", "r1", "r2", "takeObject", "WasmQueryResult", "parseInsert", "body", "ptr3", "len3", "parseOnly", "parseRequest", "method", "path", "query_string", "body", "headers", "retptr", "wasm", "ptr0", "passStringToWasm0", "len0", "WASM_VECTOR_LEN", "ptr1", "len1", "ptr2", "len2", "ptr3", "isLikeNone", "len3", "ptr4", "len4", "r0", "getDataViewMemory0", "r1", "r2", "takeObject", "WasmQueryResult", "parseRpc", "function_name", "parseUpdate", "table", "__wbg_get_imports", "arg0", "arg1", "ret", "getStringFromWasm0", "addHeapObject", "getObject", "v", "debugString", "val", "obj", "handleError", "arg2", "deferred0_0", "deferred0_1", "result", "state0", "cb0", "a", "__wasm_bindgen_func_elem_442", "getArrayU8FromWasm0", "makeMutClosure", "__wasm_bindgen_func_elem_367", "arg3", "WasmQueryResultFinalization", "ptr", "heap_next", "heap", "idx", "CLOSURE_DTORS", "state", "type", "description", "name", "length", "debug", "i", "builtInMatches", "className", "dropObject", "len", "getUint8ArrayMemory0", "cachedDataViewMemory0", "decodeText", "cachedUint8ArrayMemory0", "f", "args", "e", "x", "dtor", "real", "arg", "malloc", "realloc", "buf", "cachedTextEncoder", "mem", "offset", "code", "view", "cachedTextDecoder", "MAX_SAFARI_DECODE_BYTES", "numBytesDecoded", "wasmModule", "__wbg_finalize_init", "instance", "module", "__wbg_load", "imports", "expectedResponseType", "bytes", "__wbg_init", "module_or_path", "wasm", "imports", "__wbg_get_imports", "instance", "module", "__wbg_load", "__wbg_finalize_init", "toQueryResult", "wasmResult", "headersToJson", "headers", "preferToHeader", "prefer", "parts", "buildQueryString", "filters", "options", "key", "value", "select", "order", "onConflict", "returning", "PostgRESTParser", "method", "path", "queryString", "body", "bodyJson", "headersJson", "result", "parseRequest", "table", "data", "preferHeader", "parseInsert", "conflictColumns", "col", "parseUpdate", "parseDelete", "functionName", "args", "parseRpc", "parseOnly", "buildFilterClause", "createClient", "PostgrestParser", "_PostgrestParser", "createClient", "__wbg_init", "queryExecutor", "initSchemaFromDb", "table", "queryString", "data", "functionName", "args", "path", "method", "body", "result", "AUTH_SCHEMA_SQL", "escapeSqlString", "value", "getSetAuthContextSQL", "userId", "role", "email", "claims", "escapedUserId", "escapedRole", "escapedEmail", "escapedClaims", "CLEAR_AUTH_CONTEXT_SQL", "base64UrlEncode", "data", "base64UrlDecode", "str", "base64", "binary", "bytes", "i", "encoder", "decoder", "signJWT", "payload", "secret", "header", "headerB64", "payloadB64", "key", "signature", "signatureB64", "verifyJWT", "token", "parts", "payloadJson", "now", "err", "decodeJWT", "DEFAULT_ACCESS_TOKEN_EXPIRY", "cachedSecret", "getJWTSecret", "db", "result", "bytes", "secret", "b", "createAccessToken", "user", "sessionId", "expiresIn", "now", "payload", "signJWT", "verifyAccessToken", "token", "verifyJWT", "generateTokenPair", "refreshToken", "accessToken", "extractUserIdFromToken", "decodeJWT", "extractSessionIdFromToken", "ACCESS_TOKEN_EXPIRY", "toPublicUser", "storedUser", "authError", "message", "status", "code", "AuthHandler", "db", "AUTH_SCHEMA_SQL", "event", "session", "callback", "err", "id", "email", "password", "options", "userMetadata", "result", "user", "refreshToken", "createAccessToken", "tokenResult", "new_token", "user_id", "session_id", "accessToken", "sessionId", "extractSessionIdFromToken", "verified", "verifyAccessToken", "attributes", "userId", "updates", "params", "paramIndex", "newAccessToken", "jsonResponse", "data", "status", "extractBearerToken", "headers", "auth", "parseBody", "request", "text", "handleAuthRoute", "pathname", "authHandler", "method", "searchParams", "body", "email", "password", "options", "result", "grantType", "refreshToken", "token", "session", "setAuthContext", "db", "token", "CLEAR_AUTH_CONTEXT_SQL", "verified", "verifyAccessToken", "userId", "role", "email", "sql", "getSetAuthContextSQL", "clearAuthContext", "extractPostgresError", "err", "pgError", "errorResponse", "status", "apiError", "jsonResponse", "data", "status", "headers", "extractBearerToken", "auth", "parseBody", "request", "text", "handleDataRoute", "pathname", "db", "parser", "method", "url", "params", "queryString", "pathParts", "resourcePath", "token", "setAuthContext", "parsed", "body", "result", "prefer", "returnRepresentation", "returnMinimal", "countHeader", "responseHeaders", "err", "errorResponse", "getRouteInfo", "request", "supabaseUrl", "url", "supabaseHost", "pathname", "createLocalFetch", "config", "db", "parser", "authHandler", "originalFetch", "debug", "log", "args", "input", "init", "routeInfo", "authHeader", "response", "handleAuthRoute", "handleDataRoute", "err", "message", "createLocalSupabaseClient", "config", "createClient", "db", "supabaseUrl", "supabaseAnonKey", "debug", "originalFetch", "PostgrestParser", "sql", "parser", "authHandler", "AuthHandler", "localFetch", "createLocalFetch", "initializeAuth", "createFetchAdapter", "SupabaseClient", "db", "parser", "table", "PostgrestQueryBuilder", "functionName", "params", "parsed", "error", "columns", "data", "column", "value", "pattern", "values", "joined", "val", "options", "direction", "nulls", "count", "from", "to", "onfulfilled", "result", "queryString", "parts", "createSupabaseClient", "PostgrestParser", "sql", "PriorityQueue", "maxSize", "query", "queue", "priority", "sum", "q", "PGlitePooler", "db", "config", "PriorityQueue", "err", "resolve", "r", "sql", "params", "priority", "reject", "query", "error", "id", "result", "timeoutMs", "timeoutId", "timeoutPromise", "_", "queryPromise", "QueryPriority"]
}
